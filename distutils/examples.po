# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/distutils/examples.rst:5
msgid "Distutils Examples"
msgstr "Distutils 예제"

#: ../Doc/distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at "
"https://setuptools.readthedocs.io/en/latest/setuptools.html independently"
" covers all of the relevant information currently included here."
msgstr ""
"이 문서는 https://setuptools.readthedocs.io/en/latest/setuptools.html 의 "
"``setuptools`` 설명서가 현재 여기에 포함된 모든 관련 정보를 독립적으로 다루기 전까지만 보존됩니다."

#: ../Doc/distutils/examples.rst:9
msgid ""
"This chapter provides a number of basic examples to help get started with"
" distutils.  Additional information about using distutils can be found in"
" the Distutils Cookbook."
msgstr ""
"이 장에서는 distutils를 시작하는 데 도움이 되는 여러 가지 기본 예를 제공합니다. distutils 사용에 대한 추가 "
"정보는 Distutils Cookbook에서 찾을 수 있습니다."

#: ../Doc/distutils/examples.rst:16
msgid "`Distutils Cookbook <https://wiki.python.org/moin/Distutils/Cookbook>`_"
msgstr "`Distutils Cookbook <https://wiki.python.org/moin/Distutils/Cookbook>`_"

#: ../Doc/distutils/examples.rst:17
msgid "Collection of recipes showing how to achieve more control over distutils."
msgstr "distutils를 더 잘 제어하는 방법을 보여주는 조리법 모음."

#: ../Doc/distutils/examples.rst:23
msgid "Pure Python distribution (by module)"
msgstr "순수한 파이썬 배포 (모듈별)"

#: ../Doc/distutils/examples.rst:25
msgid ""
"If you're just distributing a couple of modules, especially if they don't"
" live in a particular package, you can specify them individually using "
"the ``py_modules`` option in the setup script."
msgstr ""
"단지 몇 개의 모듈만 배포한다면, 특히 특정 패키지에 속하지 않는 모듈이면, 설정 스크립트에서 ``py_modules`` 옵션을 "
"사용하여 개별적으로 지정할 수 있습니다."

#: ../Doc/distutils/examples.rst:29
msgid ""
"In the simplest case, you'll have two files to worry about: a setup "
"script and the single module you're distributing, :file:`foo.py` in this "
"example::"
msgstr ""
"가장 간단한 경우, 두 가지 파일을 염두에 두어야 합니다: 설정 스크립트와 배포 할 단일 모듈, 이 예에서는 "
":file:`foo.py`::"

#: ../Doc/distutils/examples.rst:36
msgid ""
"(In all diagrams in this section, *<root>* will refer to the distribution"
" root directory.)  A minimal setup script to describe this situation "
"would be::"
msgstr ""
"(이 섹션의 모든 다이어그램에서 *<root>*\\는 배포 루트 디렉터리를 가리킵니다.) 이 상황을 설명하기 위한 최소 설정 "
"스크립트는 다음과 같습니다::"

#: ../Doc/distutils/examples.rst:45
msgid ""
"Note that the name of the distribution is specified independently with "
"the ``name`` option, and there's no rule that says it has to be the same "
"as the name of the sole module in the distribution (although that's "
"probably a good convention to follow).  However, the distribution name is"
" used to generate filenames, so you should stick to letters, digits, "
"underscores, and hyphens."
msgstr ""
"배포판의 이름은 ``name`` 옵션으로 독립적으로 지정되며, 배포판의 유일한 모듈 이름과 같아야 한다는 규칙은 없습니다 (아마도 "
"따라야 할 좋은 규칙임에도 불구하고). 그러나 배포판 이름은 파일명을 생성하는 데 사용되어서, 글자, 숫자, 밑줄 및 하이픈만 "
"사용해야 합니다."

#: ../Doc/distutils/examples.rst:51
msgid ""
"Since ``py_modules`` is a list, you can of course specify multiple "
"modules, eg. if you're distributing modules :mod:`foo` and :mod:`bar`, "
"your setup might look like this::"
msgstr ""
"``py_modules``\\는 리스트이므로, 여러 모듈을 지정할 수 있습니다, 예를 들어 :mod:`foo`\\와 "
":mod:`bar` 모듈을 배포한다면, 설정은 다음과 같습니다::"

#: ../Doc/distutils/examples.rst:60
msgid "and the setup script might be  ::"
msgstr "그리고 설정 스크립트는 이렇습니다 ::"

#: ../Doc/distutils/examples.rst:68
msgid ""
"You can put module source files into another directory, but if you have "
"enough modules to do that, it's probably easier to specify modules by "
"package rather than listing them individually."
msgstr ""
"모듈 소스 파일을 다른 디렉터리에 넣을 수 있지만, 그렇게 할 모듈이 아주 많다면, 개별적으로 나열하지 않고 패키지로 모듈을 "
"지정하기가 아마도 더 쉽습니다."

#: ../Doc/distutils/examples.rst:76
msgid "Pure Python distribution (by package)"
msgstr "순수한 파이썬 배포 (패키지별)"

#: ../Doc/distutils/examples.rst:78
msgid ""
"If you have more than a couple of modules to distribute, especially if "
"they are in multiple packages, it's probably easier to specify whole "
"packages rather than individual modules.  This works even if your modules"
" are not in a package; you can just tell the Distutils to process modules"
" from the root package, and that works the same as any other package "
"(except that you don't have to have an :file:`__init__.py` file)."
msgstr ""
"배포할 모듈이 많으면, 특히 여러 패키지에 있다면, 개별 모듈보다는 전체 패키지를 지정하기가 아마도 더 쉽습니다. 모듈이 패키지에 "
"없는 경우에도 작동합니다; 루트 패키지에서 모듈을 처리하도록 Distutils에 지시 할 수 있으며, 다른 패키지와 동일하게 "
"작동합니다 (:file:`__init__.py` 파일이 필요하지 않다는 것만 다릅니다)."

#: ../Doc/distutils/examples.rst:85
msgid "The setup script from the last example could also be written as  ::"
msgstr "마지막 예제의 설정 스크립트는 다음과 같이 작성할 수도 있습니다 ::"

#: ../Doc/distutils/examples.rst:93
msgid "(The empty string stands for the root package.)"
msgstr "(빈 문자열은 루트 패키지를 나타냅니다.)"

#: ../Doc/distutils/examples.rst:95
msgid ""
"If those two files are moved into a subdirectory, but remain in the root "
"package, e.g.::"
msgstr "이 두 파일이 하위 디렉터리로 이동했지만, 루트 패키지에 남아있다면, 예를 들어::"

#: ../Doc/distutils/examples.rst:103
msgid ""
"then you would still specify the root package, but you have to tell the "
"Distutils where source files in the root package live::"
msgstr "그러면 여전히 루트 패키지를 지정하지만, 루트 패키지의 소스 파일이 어디에 있는지 Distutils에 알려야 합니다::"

#: ../Doc/distutils/examples.rst:113
msgid ""
"More typically, though, you will want to distribute multiple modules in "
"the same package (or in sub-packages).  For example, if the :mod:`foo`  "
"and :mod:`bar` modules belong in package :mod:`foobar`, one way to layout"
" your source tree is ::"
msgstr ""
"그러나 더 일반적으로는, 같은 패키지(또는 서브 패키지)에 있는 여러 모듈을 배포하고자 합니다. 예를 들어, "
":mod:`foo`\\와 :mod:`bar` 모듈이 패키지 :mod:`foobar`\\에 속하면, 소스 트리를 배치하는 한 가지 "
"방법은 다음과 같습니다::"

#: ../Doc/distutils/examples.rst:125
msgid ""
"This is in fact the default layout expected by the Distutils, and the one"
" that requires the least work to describe in your setup script::"
msgstr "이것은 사실 Distutils가 예상하는 기본 배치이며, 설정 스크립트에서 설명할 작업이 가장 적은 배치입니다::"

#: ../Doc/distutils/examples.rst:134
msgid ""
"If you want to put modules in directories not named for their package, "
"then you need to use the ``package_dir`` option again.  For example, if "
"the :file:`src` directory holds modules in the :mod:`foobar` package::"
msgstr ""
"패키지 이름으로 지정되지 않은 디렉터리에 모듈을 넣으려면, ``package_dir`` 옵션을 다시 사용해야 합니다. 예를 들어, "
":file:`src` 디렉터리에 :mod:`foobar` 패키지의 모듈이 있다면::"

#: ../Doc/distutils/examples.rst:145
msgid "an appropriate setup script would be  ::"
msgstr "적절한 설정 스크립트는 다음과 같습니다 ::"

#: ../Doc/distutils/examples.rst:154
msgid ""
"Or, you might put modules from your main package right in the "
"distribution root::"
msgstr "또는, 메인 패키지의 모듈을 배포 루트에 바로 넣을 수 있습니다::"

#: ../Doc/distutils/examples.rst:163
msgid "in which case your setup script would be  ::"
msgstr "이 경우 설정 스크립트는 다음과 같습니다 ::"

#: ../Doc/distutils/examples.rst:172
msgid "(The empty string also stands for the current directory.)"
msgstr "(빈 문자열은 현재 디렉터리를 나타냅니다.)"

#: ../Doc/distutils/examples.rst:174
msgid ""
"If you have sub-packages, they must be explicitly listed in ``packages``,"
" but any entries in ``package_dir`` automatically extend to sub-packages."
" (In other words, the Distutils does *not* scan your source tree, trying "
"to figure out which directories correspond to Python packages by looking "
"for :file:`__init__.py` files.)  Thus, if the default layout grows a sub-"
"package::"
msgstr ""
"서브 패키지가 있으면, ``packages``\\에 명시적으로 나열되어야 하지만, ``package_dir``\\의 모든 항목은 "
"서브 패키지로 자동 확장됩니다. (즉, Distutils는 :file:`__init__.py` 파일을 찾아서 어떤 디렉터리가 파이썬"
" 패키지에 해당하는지 파악하려고 시도하면서 소스 트리를 스캔하지 *않습니다*.) 따라서, 기본 배치가 서브 패키지로 뻗어 나가는 "
"경우::"

#: ../Doc/distutils/examples.rst:190
msgid "then the corresponding setup script would be  ::"
msgstr "해당 설정 스크립트는 이렇게 됩니다 ::"

#: ../Doc/distutils/examples.rst:202
msgid "Single extension module"
msgstr "단일 확장 모듈"

#: ../Doc/distutils/examples.rst:204
msgid ""
"Extension modules are specified using the ``ext_modules`` option. "
"``package_dir`` has no effect on where extension source files are found; "
"it only affects the source for pure Python modules.  The simplest  case, "
"a single extension module in a single C source file, is::"
msgstr ""
"확장 모듈은 ``ext_modules`` 옵션을 사용하여 지정됩니다. ``package_dir``\\은 확장 소스 파일이 있는 "
"위치를 찾는 데 영향을 미치지 않습니다; 순수한 파이썬 모듈의 소스에만 영향을 미칩니다. 단일 C 소스 파일에 단일 확장 모듈이 "
"들어 있는, 가장 간단한 경우는 이렇습니다::"

#: ../Doc/distutils/examples.rst:213
msgid ""
"If the :mod:`foo` extension belongs in the root package, the setup script"
" for this could be  ::"
msgstr ":mod:`foo` 확장이 루트 패키지에 속하면, 이를 위한 설정 스크립트는 다음과 같습니다 ::"

#: ../Doc/distutils/examples.rst:223
msgid "If the extension actually belongs in a package, say :mod:`foopkg`, then"
msgstr "확장이 실제로 패키지에 속하면, 가령 :mod:`foopkg`"

#: ../Doc/distutils/examples.rst:225
msgid ""
"With exactly the same source tree layout, this extension can be put in "
"the :mod:`foopkg` package simply by changing the name of the extension::"
msgstr "정확히 같은 소스 트리 배치로, 간단히 확장의 이름을 변경하여 이 확장을 :mod:`foopkg` 패키지에 넣을 수 있습니다::"

#: ../Doc/distutils/examples.rst:236
msgid "Checking a package"
msgstr "패키지 검사하기"

#: ../Doc/distutils/examples.rst:238
msgid ""
"The ``check`` command allows you to verify if your package meta-data meet"
" the minimum requirements to build a distribution."
msgstr "``check`` 명령을 사용하면 패키지 메타 데이터가 배포판을 빌드하기 위한 최소 요구 사항을 충족하는지 확인할 수 있습니다."

#: ../Doc/distutils/examples.rst:241
msgid ""
"To run it, just call it using your :file:`setup.py` script. If something "
"is missing, ``check`` will display a warning."
msgstr ""
"실행하려면, :file:`setup.py` 스크립트를 사용하여 호출하십시오. 뭔가 빠진 것이 있으면, ``check``\\는 경고를"
" 표시합니다."

#: ../Doc/distutils/examples.rst:244
msgid "Let's take an example with a simple script::"
msgstr "간단한 스크립트로 예를 들어 봅시다::"

#: ../Doc/distutils/examples.rst:250
msgid "Running the ``check`` command will display some warnings:"
msgstr "``check`` 명령을 실행하면 몇 가지 경고가 표시됩니다:"

#: ../Doc/distutils/examples.rst:261
msgid ""
"If you use the reStructuredText syntax in the ``long_description`` field "
"and `docutils`_  is installed you can check if the syntax is fine with "
"the ``check`` command, using the ``restructuredtext`` option."
msgstr ""
"``long_description`` 필드에 reStructuredText 문법을 사용하고 `docutils`_\\가 설치되었으면 "
"``restructuredtext`` 옵션을 사용하여 ``check`` 명령으로 문법이 올바른지 확인할 수 있습니다."

#: ../Doc/distutils/examples.rst:265
msgid "For example, if the :file:`setup.py` script is changed like this::"
msgstr "예를 들어, :file:`setup.py` 스크립트가 다음과 같이 변경되면::"

#: ../Doc/distutils/examples.rst:280
msgid ""
"Where the long description is broken, ``check`` will be able to detect it"
" by using the :mod:`docutils` parser:"
msgstr "긴 설명이 망가지면, ``check``\\는 :mod:`docutils` 구문 분석기를 사용하여 이를 감지할 수 있습니다:"

#: ../Doc/distutils/examples.rst:291
msgid "Reading the metadata"
msgstr "메타 데이터 읽기"

#: ../Doc/distutils/examples.rst:293
msgid ""
"The :func:`distutils.core.setup` function provides a command-line "
"interface that allows you to query the metadata fields of a project "
"through the ``setup.py`` script of a given project:"
msgstr ""
":func:`distutils.core.setup` 함수는 주어진 프로젝트의 ``setup.py`` 스크립트를 통해 프로젝트의 메타"
" 데이터 필드를 조회할 수 있는 명령 줄 인터페이스를 제공합니다:"

#: ../Doc/distutils/examples.rst:302
msgid ""
"This call reads the ``name`` metadata by running the "
":func:`distutils.core.setup`  function. Although, when a source or binary"
" distribution is created with Distutils, the metadata fields are written "
"in a static file called :file:`PKG-INFO`. When a Distutils-based project "
"is installed in Python, the :file:`PKG-INFO` file is copied alongside the"
" modules and packages of the distribution under :file:`NAME-VERSION-pyX.X"
".egg-info`, where ``NAME`` is the name of the project, ``VERSION`` its "
"version as defined in the Metadata, and ``pyX.X`` the major and minor "
"version of Python like ``2.7`` or ``3.2``."
msgstr ""
"이 호출은 :func:`distutils.core.setup` 함수를 실행하여 ``name`` 메타 데이터를 읽습니다. "
"Distutils로 소스나 바이너리 배포판이 만들어질 때, 메타 데이터 필드는 :file:`PKG-INFO`\\라는 정적 파일에 "
"기록됩니다. Distutils 기반 프로젝트가 파이썬에 설치되면, :file:`PKG-INFO` 파일은 배포판의 모듈과 패키지와 "
"함께 :file:`NAME-VERSION-pyX.X.egg-info` 밑에 복사됩니다, 여기서 ``NAME``\\은 프로젝트 이름,"
" ``VERSION``\\은 메타 데이터에 정의된 버전, ``pyX.X``\\는 ``2.7``\\이나 ``3.2``\\와 같은 "
"파이썬의 주와 부 버전입니다."

#: ../Doc/distutils/examples.rst:312
msgid ""
"You can read back this static file, by using the "
":class:`distutils.dist.DistributionMetadata` class and its "
":func:`read_pkg_file` method::"
msgstr ""
":class:`distutils.dist.DistributionMetadata` 클래스와 :func:`read_pkg_file` "
"메서드를 사용하여, 이 정적 파일을 다시 읽을 수 있습니다::"

#: ../Doc/distutils/examples.rst:326
msgid ""
"Notice that the class can also be instantiated with a metadata file path "
"to loads its values::"
msgstr "클래스를 메타 데이터 파일 경로로 인스턴스 화하여 해당 값을 로드 할 수도 있음에 유의하십시오::"

