# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-08 03:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:5
msgid "API Reference"
msgstr "API 레퍼런스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:11
msgid "`New and changed setup.py arguments in setuptools`_"
msgstr ""
"`setuptools의 신규 및 변경된 setup.py 인자 <New and changed setup.py arguments in "
"setuptools_>`_"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:10
msgid ""
"The ``setuptools`` project adds new capabilities to the ``setup`` "
"function and other APIs, makes the API consistent across different Python"
" versions, and is hence recommended over using ``distutils`` directly."
msgstr ""
"``setuptools`` 프로젝트는 ``setup`` 함수와 기타 API에 새로운 기능을 추가하고, API를 여러 파이썬 버전에서"
" 일관되게 만들어서, ``distutils``\\를 직접 사용하는 것보다 권장됩니다."

#: distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at "
"https://setuptools.readthedocs.io/en/latest/setuptools.html independently"
" covers all of the relevant information currently included here."
msgstr ""
"이 문서는 https://setuptools.readthedocs.io/en/latest/setuptools.html 의 "
"``setuptools`` 설명서가 현재 여기에 포함된 모든 관련 정보를 독립적으로 다루기 전까지만 보존됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:19
msgid ":mod:`distutils.core` --- Core Distutils functionality"
msgstr ":mod:`distutils.core` --- 핵심 Distutils 기능"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:25
msgid ""
"The :mod:`distutils.core` module is the only module that needs to be "
"installed to use the Distutils. It provides the :func:`setup` (which is "
"called from the setup script). Indirectly provides the  "
":class:`distutils.dist.Distribution` and :class:`distutils.cmd.Command` "
"class."
msgstr ""
":mod:`distutils.core` 모듈은 Distutils를 사용하기 위해 설치해야 하는 유일한 모듈입니다. "
":func:`setup`\\(설치 스크립트에서 호출됩니다)을 제공합니다. "
":class:`distutils.dist.Distribution`\\과 :class:`distutils.cmd.Command` "
"클래스를 간접적으로 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:33
msgid ""
"The basic do-everything function that does most everything you could ever"
" ask for from a Distutils method."
msgstr "Distutils 메서드에서 요청할 수 있는 대부분의 작업을 수행하는 기본 만능 함수."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:36
msgid ""
"The setup function takes a large number of arguments. These are laid out "
"in the following table."
msgstr "setup 함수는 많은 수의 인자를 취합니다. 이는 다음 표에 나와 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:42
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:185
msgid "argument name"
msgstr "인자 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:42
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:143
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:185
msgid "value"
msgstr "값"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:42
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:185
msgid "type"
msgstr "형"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:44
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:187
msgid "*name*"
msgstr "*name*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:44
msgid "The name of the package"
msgstr "패키지 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:44
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:46
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:50
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:53
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:56
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:58
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:61
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:68
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:72
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:75
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:96
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:106
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:187
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:278
msgid "a string"
msgstr "문자열"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:46
msgid "*version*"
msgstr "*version*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:46
msgid "The version number of the package; see :mod:`distutils.version`"
msgstr "패키지의 버전 번호; :mod:`distutils.version`\\을 참조하십시오"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:50
msgid "*description*"
msgstr "*description*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:50
msgid "A single line describing the package"
msgstr "패키지를 설명하는 한 줄"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:53
msgid "*long_description*"
msgstr "*long_description*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:53
msgid "Longer description of the package"
msgstr "패키지에 대한 자세한 설명"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:56
msgid "*author*"
msgstr "*author*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:56
msgid "The name of the package author"
msgstr "패키지 저자의 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:58
msgid "*author_email*"
msgstr "*author_email*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:58
msgid "The email address of the package author"
msgstr "패키지 저자의 이메일 주소"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:61
msgid "*maintainer*"
msgstr "*maintainer*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:61
msgid ""
"The name of the current maintainer, if different from the author. Note "
"that if the maintainer is provided, distutils will use it as the author "
"in :file:`PKG-INFO`"
msgstr ""
"저자와 다르다면, 현재 관리자의 이름. 관리자가 제공되면 distutils는, 이것을 :file:`PKG-INFO`\\에서 저자로 "
"사용함에 유의하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:68
msgid "*maintainer_email*"
msgstr "*maintainer_email*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:68
msgid "The email address of the current maintainer, if different from the author"
msgstr "작성자와 다르다면, 현재 관리자의 이메일 주소"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:72
msgid "*url*"
msgstr "*url*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:72
msgid "A URL for the package (homepage)"
msgstr "패키지의 URL (홈페이지)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:75
msgid "*download_url*"
msgstr "*download_url*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:75
msgid "A URL to download the package"
msgstr "패키지를 다운로드하기 위한 URL"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:77
msgid "*packages*"
msgstr "*packages*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:77
msgid "A list of Python packages that distutils will manipulate"
msgstr "distutils가 다룰 파이썬 패키지 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:77
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:80
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:83
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:100
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:193
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:207
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:223
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:226
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:230
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:234
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:240
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:247
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:258
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:267
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:275
msgid "a list of strings"
msgstr "문자열 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:80
msgid "*py_modules*"
msgstr "*py_modules*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:80
msgid "A list of Python modules that distutils will manipulate"
msgstr "distutils가 다룰 파이썬 모듈 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:83
msgid "*scripts*"
msgstr "*scripts*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:83
msgid "A list of standalone script files to be built and installed"
msgstr "빌드하고 설치할 독립 실행형 스크립트 파일 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:87
msgid "*ext_modules*"
msgstr "*ext_modules*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:87
msgid "A list of Python extensions to be built"
msgstr "빌드할 파이썬 확장 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:87
msgid "a list of instances of :class:`distutils.core.Extension`"
msgstr ":class:`distutils.core.Extension`\\의 인스턴스 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:90
msgid "*classifiers*"
msgstr "*classifiers*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:90
msgid "A list of categories for the package"
msgstr "패키지 범주 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:90
msgid ""
"a list of strings; valid classifiers are listed on `PyPI "
"<https://pypi.org/classifiers>`_."
msgstr "문자열 리스트; 유효한 분류자는 `PyPI <https://pypi.org/classifiers>`_\\에 나열됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:93
msgid "*distclass*"
msgstr "*distclass*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:93
msgid "the :class:`Distribution` class to use"
msgstr "사용할 :class:`Distribution` 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:93
msgid "a subclass of :class:`distutils.core.Distribution`"
msgstr ":class:`distutils.core.Distribution`\\의 서브 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:96
msgid "*script_name*"
msgstr "*script_name*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:96
msgid "The name of the setup.py script - defaults to ``sys.argv[0]``"
msgstr "setup.py 스크립트의 이름 - 기본값은 ``sys.argv[0]``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:100
msgid "*script_args*"
msgstr "*script_args*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:100
msgid "Arguments to supply to the setup script"
msgstr "설정 스크립트에 제공할 인자"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:103
msgid "*options*"
msgstr "*options*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:103
msgid "default options for the setup script"
msgstr "설정 스크립트의 기본 옵션"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:103
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:113
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:119
msgid "a dictionary"
msgstr "딕셔너리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:106
msgid "*license*"
msgstr "*license*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:106
msgid "The license for the package"
msgstr "패키지 라이선스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:108
msgid "*keywords*"
msgstr "*keywords*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:108
msgid "Descriptive meta-data, see :pep:`314`"
msgstr "설명 메타 데이터, :pep:`314`\\를 참조하십시오"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:108
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:111
msgid "a list of strings or a comma-separated string"
msgstr "문자열 리스트나 쉼표로 구분된 문자열"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:111
msgid "*platforms*"
msgstr "*platforms*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:113
msgid "*cmdclass*"
msgstr "*cmdclass*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:113
msgid "A mapping of command names to :class:`Command` subclasses"
msgstr "명령 이름에서 :class:`Command` 서브 클래스로의 매핑"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:116
msgid "*data_files*"
msgstr "*data_files*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:116
msgid "A list of data files to install"
msgstr "설치할 데이터 파일 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:116
msgid "a list"
msgstr "리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:119
msgid "*package_dir*"
msgstr "*package_dir*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:119
msgid "A mapping of package to directory names"
msgstr "패키지에서 디렉터리 이름으로의 매핑"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:127
msgid ""
"Run a setup script in a somewhat controlled environment, and return  the "
":class:`distutils.dist.Distribution` instance that drives things.   This "
"is useful if you need to find out the distribution meta-data  (passed as "
"keyword args from *script* to :func:`setup`), or  the contents of the "
"config files or command-line."
msgstr ""
"다소 통제된 환경에서 설정 스크립트를 실행하고, 작업을 구동하는 :class:`distutils.dist.Distribution` "
"인스턴스를 반환합니다. 이는 (*script*\\에서 :func:`setup`\\으로 키워드 인자로 전달된) 배포 메타 데이터나, "
"구성 파일이나 명령 줄의 내용을 찾아야 하는 경우 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:133
msgid ""
"*script_name* is a file that will be read and run with :func:`exec`.  "
"``sys.argv[0]`` will be replaced with *script* for the duration of the "
"call.  *script_args* is a list of strings; if supplied, ``sys.argv[1:]`` "
"will be replaced by *script_args* for the duration  of the call."
msgstr ""
"*script_name*\\은 :func:`exec`\\로 읽고 실행할 파일입니다. 호출 기간에 ``sys.argv[0]``\\은 "
"*script*\\로 대체됩니다. *script_args*\\는 문자열 리스트입니다; 제공되면 ``sys.argv[1:]``\\은 "
"호출 기간에 *script_args*\\로 대체됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:138
msgid ""
"*stop_after* tells :func:`setup` when to stop processing; possible  "
"values:"
msgstr "*stop_after*\\는 :func:`setup`\\에게 처리 중지 시기를 알려줍니다. 가능한 값:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:143
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:562
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1601
msgid "description"
msgstr "설명"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:145
msgid "*init*"
msgstr "*init*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:145
msgid ""
"Stop after the :class:`Distribution` instance has been created  and "
"populated with the keyword arguments to :func:`setup`"
msgstr ":class:`Distribution` 인스턴스가 생성되고 :func:`setup`\\에 대한 키워드 인자로 채워진 후 중지합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:149
msgid "*config*"
msgstr "*config*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:149
msgid ""
"Stop after config files have been parsed (and their data stored in the "
":class:`Distribution` instance)"
msgstr "구성 파일이 구문 분석된 (그리고 해당 데이터가 :class:`Distribution` 인스턴스에 저장된) 후 중지합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:153
msgid "*commandline*"
msgstr "*commandline*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:153
msgid ""
"Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have "
"been parsed (and the data stored in the :class:`Distribution` instance.)"
msgstr ""
"명령 줄(``sys.argv[1:]``\\이나 *script_args*)이 구문 분석된 (그리고 데이터가 "
":class:`Distribution` 인스턴스에 저장된) 후 중지합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:158
msgid "*run*"
msgstr "*run*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:158
msgid ""
"Stop after all commands have been run (the same as  if :func:`setup` had "
"been called in the usual way). This is the default value."
msgstr "모든 명령이 실행된 후 중지합니다 (:func:`setup`\\이 일반적인 방법으로 호출된 것과 같습니다). 이것이 기본값입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:164
msgid ""
"In addition, the :mod:`distutils.core` module exposed a number of  "
"classes that live elsewhere."
msgstr "또한, :mod:`distutils.core` 모듈은 다른 곳에 있는 여러 클래스를 노출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:167
msgid ":class:`~distutils.extension.Extension` from :mod:`distutils.extension`"
msgstr ":mod:`distutils.extension`\\의 :class:`~distutils.extension.Extension`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:169
msgid ":class:`~distutils.cmd.Command` from :mod:`distutils.cmd`"
msgstr ":mod:`distutils.cmd`\\의 :class:`~distutils.cmd.Command`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:171
msgid ":class:`~distutils.dist.Distribution` from :mod:`distutils.dist`"
msgstr ":mod:`distutils.dist`\\의 :class:`~distutils.dist.Distribution`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:173
msgid ""
"A short description of each of these follows, but see the relevant module"
" for the full reference."
msgstr "이들 각각에 대한 간략한 설명은 다음과 같지만, 전체 레퍼런스는 관련 모듈을 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:179
msgid ""
"The Extension class describes a single C or C++ extension module in a "
"setup script. It accepts the following keyword arguments in its "
"constructor:"
msgstr "Extension 클래스는 설정 스크립트의 단일 C나 C++ 확장 모듈을 기술합니다. 생성자에서 다음 키워드 인자를 받아들입니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:187
msgid ""
"the full name of the extension, including any packages --- ie. *not* a "
"filename or pathname, but Python dotted name"
msgstr "모든 패키지를 포함하여, 확장의 전체 이름 --- 즉 파일명이나 경로명이 *아니라*, 점으로 구분된 파이썬 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:193
msgid "*sources*"
msgstr "*sources*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:193
msgid ""
"list of source filenames, relative to the distribution root (where the "
"setup script lives), in Unix form (slash-separated) for portability. "
"Source files may be C, C++, SWIG (.i), platform-specific resource files, "
"or whatever else is recognized by the :command:`build_ext` command as "
"source for a Python extension."
msgstr ""
"이식성을 위해 유닉스 형식의 (슬래시로 구분된), 배포 루트(설치 스크립트가 있는 위치)에 상대적인, 소스 파일명 리스트. 소스 "
"파일은 C, C++, SWIG (.i), 플랫폼별 리소스 파일 또는 :command:`build_ext` 명령이 파이썬 확장의 "
"소스로 인식하는 다른 모든 것일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:207
msgid "*include_dirs*"
msgstr "*include_dirs*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:207
msgid ""
"list of directories to search for C/C++ header files (in Unix form for "
"portability)"
msgstr "C/C++ 헤더 파일을 검색할 디렉터리 리스트 (이식성을 위해 유닉스 형식으로)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:211
msgid "*define_macros*"
msgstr "*define_macros*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:211
msgid ""
"list of macros to define; each macro is defined using a 2-tuple ``(name, "
"value)``, where *value* is either the string to define it to or ``None`` "
"to define it without a particular value (equivalent of ``#define FOO`` in"
" source or :option:`!-DFOO` on Unix C compiler command line)"
msgstr ""
"정의할 매크로 리스트; 각 매크로는 2-튜플 ``(name, value)``\\를 사용하여 정의됩니다, 여기서 *value*\\는 "
"정의할 문자열이거나 특정 값없이 정의하는 ``None``\\입니다 (소스의 ``#define FOO``\\나 유닉스 C 컴파일러 "
"명령 줄의 :option:`!-DFOO`\\와 동등합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:211
msgid "a list of tuples"
msgstr "튜플 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:223
msgid "*undef_macros*"
msgstr "*undef_macros*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:223
msgid "list of macros to undefine explicitly"
msgstr "명시적으로 정의 해제(undef)할 매크로 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:226
msgid "*library_dirs*"
msgstr "*library_dirs*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:226
msgid "list of directories to search for C/C++ libraries at link time"
msgstr "링크 시점에 C/C++ 라이브러리를 검색할 디렉터리 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:230
msgid "*libraries*"
msgstr "*libraries*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:230
msgid "list of library names (not filenames or paths) to link against"
msgstr "링크할 라이브러리 이름 (파일명이나 경로가 아닙니다) 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:234
msgid "*runtime_library_dirs*"
msgstr "*runtime_library_dirs*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:234
msgid ""
"list of directories to search for C/C++ libraries at run time (for shared"
" extensions, this is when the extension is loaded)"
msgstr "실행 시점에 C/C++ 라이브러리를 검색할 디렉터리 리스트 (공유 확장의 경우, 확장이 로드될 때입니다)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:240
msgid "*extra_objects*"
msgstr "*extra_objects*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:240
msgid ""
"list of extra files to link with (eg. object files not implied by "
"'sources', static library that must be explicitly specified, binary "
"resource files, etc.)"
msgstr ""
"링크할 추가 파일 리스트 (예를 들어 'sources'가 암시하지 않는 오브젝트 파일, 명시적으로 지정해야 하는 정적 라이브러리, "
"바이너리 리소스 파일 등)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:247
msgid "*extra_compile_args*"
msgstr "*extra_compile_args*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:247
msgid ""
"any extra platform- and compiler-specific information to use when "
"compiling the source files in 'sources'. For platforms and compilers "
"where a command line makes sense, this is typically a list of command-"
"line arguments, but for other platforms it could be anything."
msgstr ""
"'sources'에 있는 소스 파일을 컴파일할 때 사용할 추가 플랫폼과 컴파일러별 정보. 명령 줄이 의미가 있는 플랫폼과 컴파일러의"
" 경우, 일반적으로 명령 줄 인자 리스트이지만, 다른 플랫폼의 경우 어떤 것이 든 될 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:258
msgid "*extra_link_args*"
msgstr "*extra_link_args*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:258
msgid ""
"any extra platform- and compiler-specific information to use when linking"
" object files together to create the extension (or to create a new static"
" Python interpreter). Similar interpretation as for 'extra_compile_args'."
msgstr ""
"확장을 만들기 위해 (또는 새로운 정적 파이썬 인터프리터를 만들기 위해) 오브젝트 파일을 함께 링크할 때 사용할 추가 플랫폼과 "
"컴파일러별 정보. 'extra_compile_args'와 유사한 해석."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:267
msgid "*export_symbols*"
msgstr "*export_symbols*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:267
msgid ""
"list of symbols to be exported from a shared extension. Not used on all "
"platforms, and not generally necessary for Python extensions, which "
"typically export exactly one symbol: ``init`` + extension_name."
msgstr ""
"공유 확장에서 내보낼 심볼 리스트. 모든 플랫폼에서 사용되지는 않으며, 일반적으로 정확히 하나의 심볼(``init`` + 확장 "
"이름)을 내보내는 파이썬 확장에는 필요하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:275
msgid "*depends*"
msgstr "*depends*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:275
msgid "list of files that the extension depends on"
msgstr "확장이 의존하는 파일 리스트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:278
msgid "*language*"
msgstr "*language*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:278
msgid ""
"extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be "
"detected from the source extensions if not provided."
msgstr "확장 언어(즉 ``'c'``, ``'c++'``, ``'objc'``). 제공되지 않으면 소스 확장자에서 감지됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:284
msgid "*optional*"
msgstr "*optional*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:284
msgid ""
"specifies that a build failure in the extension should not abort the "
"build process, but simply skip the extension."
msgstr "확장의 빌드 실패가 빌드 프로세스를 중단하지 않고, 단순히 확장을 건너뛰도록 지정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:284
msgid "a boolean"
msgstr "불리언"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:292
msgid ""
"On Unix, C extensions are no longer linked to libpython except on Android"
" and Cygwin."
msgstr "유닉스에서, 안드로이드와 Cygwin을 제외하고 C 확장은 더는 libpython에 링크되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:298
msgid ""
"A :class:`Distribution` describes how to build, install and package up a "
"Python software package."
msgstr ":class:`Distribution`\\은 파이썬 소프트웨어 패키지를 빌드, 설치 및 패키징하는 방법을 기술합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:301
msgid ""
"See the :func:`setup` function for a list of keyword arguments accepted  "
"by the Distribution constructor. :func:`setup` creates a Distribution "
"instance."
msgstr ""
"Distribution 생성자에서 허용되는 키워드 인자 리스트는 :func:`setup` 함수를 참조하십시오. "
":func:`setup`\\은 Distribution 인스턴스를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:304
msgid ""
":class:`~distutils.core.Distribution` now warns if ``classifiers``, "
"``keywords`` and ``platforms`` fields are not specified as a list or a "
"string."
msgstr ""
":class:`~distutils.core.Distribution`\\은 이제 ``classifiers``, ``keywords``"
" 및 ``platforms`` 필드가 리스트나 문자열로 지정되지 않으면 경고합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:311
msgid ""
"A :class:`Command` class (or rather, an instance of one of its "
"subclasses) implement a single distutils command."
msgstr ":class:`Command` 클래스(또는 서브 클래스 중 하나의 인스턴스)는 단일 distutils 명령을 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:316
msgid ":mod:`distutils.ccompiler` --- CCompiler base class"
msgstr ":mod:`distutils.ccompiler` --- CCompiler 베이스 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:322
msgid ""
"This module provides the abstract base class for the :class:`CCompiler` "
"classes.  A :class:`CCompiler` instance can be used for all the compile  "
"and link steps needed to build a single project. Methods are provided to"
"  set options for the compiler --- macro definitions, include "
"directories,  link path, libraries and the like."
msgstr ""
"이 모듈은 :class:`CCompiler` 클래스를 위한 추상 베이스 클래스를 제공합니다. :class:`CCompiler` "
"인스턴스는 단일 프로젝트를 빌드하는 데 필요한 모든 컴파일과 링크 단계에 사용할 수 있습니다. 컴파일러 옵션을 설정하는 메서드가 "
"제공됩니다 --- 매크로 정의, 인클루드 디렉터리, 링크 경로, 라이브러리 등."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:328
msgid "This module provides the following functions."
msgstr "이 모듈은 다음과 같은 함수를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:333
msgid ""
"Generate linker options for searching library directories and linking "
"with specific libraries.  *libraries* and *library_dirs* are, "
"respectively, lists of library names (not filenames!) and search "
"directories.  Returns a list of command-line options suitable for use "
"with some compiler (depending on the two format strings passed in)."
msgstr ""
"라이브러리 디렉터리를 검색하고 특정 라이브러리와 링크하기 위한 링커 옵션을 생성합니다. *libraries*\\와 "
"*library_dirs*\\는 각각 라이브러리 이름(파일명이 아닙니다)과 검색 디렉터리 리스트입니다. 일부 컴파일러에서 사용하기에"
" 적합한 명령 줄 옵션 리스트를 반환합니다 (전달된 두 포맷 문자열에 따라 다릅니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:342
msgid ""
"Generate C pre-processor options (:option:`!-D`, :option:`!-U`, "
":option:`!-I`) as used by at least two types of compilers: the typical "
"Unix compiler and Visual C++. *macros* is the usual thing, a list of 1- "
"or 2-tuples, where ``(name,)`` means undefine (:option:`!-U`) macro "
"*name*, and ``(name, value)`` means define (:option:`!-D`) macro *name* "
"to *value*.  *include_dirs* is just a list of directory names to be added"
" to the header file search path (:option:`!-I`). Returns a list of "
"command-line options suitable for either Unix compilers or Visual C++."
msgstr ""
"최소 두 가지 유형의 컴파일러에서 사용되는 C 전처리기 옵션(:option:`!-D`, :option:`!-U`, "
":option:`!-I`)을 생성합니다: 일반적인 유닉스 컴파일러와 Visual C++. *macros*\\는 일반적으로 1-튜플 "
"또는 2-튜플 리스트입니다. 여기서 ``(name,)``\\은 정의 해제 (:option:`!-U`) 매크로 *name*\\을 "
"의미하고, ``(name, value)``\\는 *name*\\을 *value*\\로 정의하는 (:option:`!-D`) 매크로를"
" 의미합니다. *include_dirs*\\는 헤더 파일 검색 경로에 추가할 디렉터리 이름 리스트입니다 "
"(:option:`!-I`). 유닉스 컴파일러나 Visual C++에 적합한 명령 줄 옵션 리스트를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:354
msgid "Determine the default compiler to use for the given platform."
msgstr "주어진 플랫폼에 사용할 기본 컴파일러를 파악합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:356
msgid ""
"*osname* should be one of the standard Python OS names (i.e. the ones "
"returned by ``os.name``) and *platform* the common value returned by "
"``sys.platform`` for the platform in question."
msgstr ""
"*osname*\\은 표준 파이썬 OS 이름 (즉, ``os.name``\\에서 반환된 이름) 중 하나여야 하며 "
"*platform*\\은 해당 플랫폼에서 ``sys.platform``\\이 반환하는 일반 값이어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:360
msgid ""
"The default values are ``os.name`` and ``sys.platform`` in case the "
"parameters are not given."
msgstr "매개 변수가 제공되지 않으면 기본값은 ``os.name``\\과 ``sys.platform``\\입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:366
msgid ""
"Factory function to generate an instance of some CCompiler subclass for "
"the supplied platform/compiler combination. *plat* defaults to "
"``os.name`` (eg. ``'posix'``, ``'nt'``), and *compiler*  defaults to the "
"default compiler for that platform. Currently only ``'posix'`` and "
"``'nt'`` are supported, and the default compilers are \"traditional Unix "
"interface\" (:class:`UnixCCompiler` class) and Visual C++ "
"(:class:`MSVCCompiler` class).  Note that it's perfectly possible to ask "
"for a Unix compiler object under Windows, and a Microsoft compiler object"
" under Unix---if you supply a value for *compiler*, *plat* is ignored."
msgstr ""
"제공된 플랫폼/컴파일러 조합에 대한 어떤 CCompiler 서브 클래스의 인스턴스를 생성하는 팩토리 함수. *plat*\\의 "
"기본값은 ``os.name``\\이고 (예를 들어 ``'posix'``, ``'nt'``), *compiler*\\의 기본값은 해당"
" 플랫폼의 기본 컴파일러입니다. 현재 ``'posix'``\\와 ``'nt'`` 만 지원되며, 기본 컴파일러는 \"전통적인 유닉스 "
"인터페이스\"(:class:`UnixCCompiler` 클래스)와 Visual C++(:class:`MSVCCompiler` "
"클래스)입니다. 윈도우에서 유닉스 컴파일러 객체를, 유닉스에서 Microsoft 컴파일러 객체를 요청하는 것도 완벽히 가능함에 "
"유의하십시오 --- *compiler*\\에 대한 값을 제공하면, *plat*\\은 무시됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:382
msgid ""
"Print list of available compilers (used by the :option:`!--help-compiler`"
" options to :command:`build`, :command:`build_ext`, "
":command:`build_clib`)."
msgstr ""
"사용 가능한 컴파일러 리스트를 인쇄합니다 (:command:`build`, :command:`build_ext`, "
":command:`build_clib`\\에 대한 :option:`!--help-compiler` 옵션에서 사용됩니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:388
msgid ""
"The abstract base class :class:`CCompiler` defines the interface that  "
"must be implemented by real compiler classes.  The class also has  some "
"utility methods used by several compiler classes."
msgstr ""
"추상 베이스 클래스 :class:`CCompiler`\\는 실제 컴파일러 클래스에서 구현해야 하는 인터페이스를 정의합니다. 이 "
"클래스에는 여러 컴파일러 클래스에서 사용하는 유틸리티 메서드도 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:392
msgid ""
"The basic idea behind a compiler abstraction class is that each instance "
"can be used for all the compile/link steps in building a single project."
"  Thus, attributes common to all of those compile and link steps --- "
"include directories, macros to define, libraries to link against, etc. "
"--- are attributes of the compiler instance.  To allow for variability in"
" how individual files are treated, most of those attributes may be varied"
" on a per-compilation or per-link basis."
msgstr ""
"컴파일러 추상화 클래스의 기본 개념은 단일 프로젝트를 빌드하는 모든 컴파일/링크 단계에 각 인스턴스를 사용할 수 있다는 것입니다. "
"따라서, 모든 컴파일과 링크 단계에 공통적인 어트리뷰트는 컴파일러 인스턴스의 어트리뷰트입니다 --- 인클루드 디렉터리, 정의할 "
"매크로, 링크할 라이브러리 등. 개별 파일이 처리되는 방식의 가변성을 허용하기 위해, 이러한 어트리뷰트의 대부분은 컴파일 별 또는 "
"링크 별로 달라질 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:400
msgid ""
"The constructor for each subclass creates an instance of the Compiler "
"object. Flags are *verbose* (show verbose output), *dry_run* (don't "
"actually execute the steps) and *force* (rebuild everything, regardless "
"of dependencies). All of these flags default to ``0`` (off). Note that "
"you probably don't want to instantiate :class:`CCompiler` or one of its "
"subclasses directly - use the :func:`distutils.CCompiler.new_compiler` "
"factory function instead."
msgstr ""
"각 서브 클래스의 생성자는 Compiler 객체의 인스턴스를 만듭니다. 플래그는 *verbose* (상세한 출력을 표시합니다), "
"*dry_run* (실제로 단계를 실행하지 않습니다) 및 *force*\\(종속성과 관계없이, 모든 것을 다시 빌드합니다)입니다. "
"이러한 모든 플래그의 기본값은 ``0``\\(꺼짐)입니다. :class:`CCompiler`\\나 서브 클래스 중 하나를 직접 "
"인스턴스 화하고 싶지는 않을 것임에 유의하십시오 - 대신 :func:`distutils.CCompiler.new_compiler` "
"팩토리 함수를 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:407
msgid ""
"The following methods allow you to manually alter compiler options for  "
"the instance of the Compiler class."
msgstr "다음 메서드를 사용하면 Compiler 클래스의 인스턴스에 대한 컴파일러 옵션을 수동으로 변경할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:413
msgid ""
"Add *dir* to the list of directories that will be searched for header "
"files. The compiler is instructed to search directories in the order in "
"which they are supplied by successive calls to :meth:`add_include_dir`."
msgstr ""
"헤더 파일을 검색할 디렉터리 리스트에 *dir*\\을 추가합니다. 컴파일러는 :meth:`add_include_dir`\\에 대한 "
"연속적인 호출에 의해 제공되는 순서대로 디렉터리를 검색하도록 지시받습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:420
msgid ""
"Set the list of directories that will be searched to *dirs* (a list of "
"strings). Overrides any preceding calls to :meth:`add_include_dir`; "
"subsequent calls to :meth:`add_include_dir` add to the list passed to "
":meth:`set_include_dirs`. This does not affect any list of standard "
"include directories that the compiler may search by default."
msgstr ""
"검색할 디렉터리 리스트를 *dirs*\\(문자열 리스트)로 설정합니다. :meth:`add_include_dir`\\에 대한 이전 "
"호출을 무시합니다; :meth:`add_include_dir`\\에 대한 후속 호출은 "
":meth:`set_include_dirs`\\에 전달된 리스트에 추가됩니다. 이는 컴파일러가 기본적으로 검색할 수 있는 표준 "
"인클루드 디렉터리 리스트에 영향을 주지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:429
msgid ""
"Add *libname* to the list of libraries that will be included in all links"
" driven by this compiler object.  Note that *libname* should \\*not\\* be"
" the name of a file containing a library, but the name of the library "
"itself: the actual filename will be inferred by the linker, the compiler,"
" or the compiler class (depending on the platform)."
msgstr ""
"이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 라이브러리 리스트에 *libname*\\을 추가합니다. *libname*\\은"
" 라이브러리를 포함하는 파일의 이름이 \\*아니라\\*, 라이브러리 자체의 이름이어야 합니다: 실제 파일명은 링커, 컴파일러 또는 "
"컴파일러 클래스(플랫폼에 따라 다릅니다)에 의해 유추됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:435
msgid ""
"The linker will be instructed to link against libraries in the order they"
" were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It "
"is perfectly valid to duplicate library names; the linker will be "
"instructed to link against libraries as many times as they are mentioned."
msgstr ""
"링커는 :meth:`add_library` 및/또는 :meth:`set_libraries`\\에 제공된 순서대로 라이브러리에 "
"링크하도록 지시받습니다. 라이브러리 이름을 중복하는 것은 완벽하게 유효합니다; 링커는 언급된 횟수만큼 라이브러리에 링크하도록 "
"지시받습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:443
msgid ""
"Set the list of libraries to be included in all links driven by this "
"compiler object to *libnames* (a list of strings).  This does not affect "
"any standard system libraries that the linker may include by default."
msgstr ""
"이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 라이브러리 리스트를 *libnames*\\(문자열 리스트)로 설정합니다. "
"이것은 링커가 기본적으로 포함할 수 있는 표준 시스템 라이브러리에 영향을 주지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:450
msgid ""
"Add *dir* to the list of directories that will be searched for libraries "
"specified to :meth:`add_library` and :meth:`set_libraries`.  The linker "
"will be instructed to search for libraries in the order they are supplied"
" to :meth:`add_library_dir` and/or :meth:`set_library_dirs`."
msgstr ""
":meth:`add_library`\\와 :meth:`set_libraries`\\에 지정된 라이브러리를 검색할 디렉터리 리스트에 "
"*dir*\\을 추가합니다. 링커는 :meth:`add_library_dir` 및/또는 "
":meth:`set_library_dirs`\\에 제공된 순서대로 라이브러리를 검색하도록 지시받습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:458
msgid ""
"Set the list of library search directories to *dirs* (a list of strings)."
"  This does not affect any standard library search path that the linker "
"may search by default."
msgstr ""
"라이브러리 검색 디렉터리 리스트를 *dirs*\\(문자열 리스트)로 설정합니다. 이것은 링커가 기본적으로 검색할 수 있는 표준 "
"라이브러리 검색 경로에 영향을 주지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:465
msgid ""
"Add *dir* to the list of directories that will be searched for shared "
"libraries at runtime."
msgstr "실행 시간에 공유 라이브러리를 검색할 디렉터리 리스트에 *dir*\\을 추가합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:471
msgid ""
"Set the list of directories to search for shared libraries at runtime to "
"*dirs* (a list of strings).  This does not affect any standard search "
"path that the runtime linker may search by default."
msgstr ""
"실행 시간에 공유 라이브러리를 검색할 디렉터리 리스트를 *dirs*\\(문자열 리스트)로 설정합니다. 이는 실행 시간 링커가 "
"기본적으로 검색할 수 있는 표준 검색 경로에 영향을 주지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:478
msgid ""
"Define a preprocessor macro for all compilations driven by this compiler "
"object. The optional parameter *value* should be a string; if it is not "
"supplied, then the macro will be defined without an explicit value and "
"the exact outcome depends on the compiler used."
msgstr ""
"이 컴파일러 객체에 의해 구동되는 모든 컴파일에 대한 전처리기 매크로를 정의합니다. 선택적 매개 변수 *value*\\는 "
"문자열이어야 합니다; 제공되지 않으면, 매크로는 명시적 값없이 정의되며 정확한 결과는 사용된 컴파일러에 따라 다릅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:488
msgid ""
"Undefine a preprocessor macro for all compilations driven by this "
"compiler object.  If the same macro is defined by :meth:`define_macro` "
"and undefined by :meth:`undefine_macro` the last call takes precedence "
"(including multiple redefinitions or undefinitions).  If the macro is "
"redefined/undefined on a per-compilation basis (ie. in the call to "
":meth:`compile`), then that takes precedence."
msgstr ""
"이 컴파일러 객체에 의해 구동되는 모든 컴파일에 대한 전처리기 매크로를 정의 해제합니다. 같은 매크로가 "
":meth:`define_macro`\\에 의해 정의되고 :meth:`undefine_macro`\\에 의해 정의 해제되면 마지막 "
"호출이 우선합니다 (여러 재정의나 정의 해제를 포함합니다). 매크로가 컴파일 별로 (즉, :meth:`compile` 호출에서) "
"재정의/정의 해제되면, 이것이 우선합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:498
msgid ""
"Add *object* to the list of object files (or analogues, such as "
"explicitly named library files or the output of \"resource compilers\") "
"to be included in every link driven by this compiler object."
msgstr ""
"이 컴파일러 객체에 의해 구동되는 모든 링크에 포함될 오브젝트 파일(또는 유사물들, 가령 명시적으로 명명된 라이브러리 파일이나 "
"\"리소스 컴파일러\"의 출력) 리스트에 *object*\\를 추가합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:505
msgid ""
"Set the list of object files (or analogues) to be included in every link "
"to *objects*.  This does not affect any standard object files that the "
"linker may include by default (such as system libraries)."
msgstr ""
"*objects*\\에 대한 모든 링크에 포함될 오브젝트 파일(또는 유사물들) 리스트를 설정합니다. 이는 링커가 기본적으로 포함할 "
"수 있는 표준 오브젝트 파일에는 영향을 주지 않습니다 (가령 시스템 라이브러리)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:509
msgid ""
"The following methods implement methods for autodetection of compiler  "
"options, providing some functionality similar to GNU :program:`autoconf`."
msgstr ""
"다음 메서드는 GNU :program:`autoconf`\\와 유사한 일부 기능을 제공하는 컴파일러 옵션의 자동 감지 방법을 "
"구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:515
msgid ""
"Detect the language of a given file, or list of files. Uses the  instance"
" attributes :attr:`language_map` (a dictionary), and  "
":attr:`language_order` (a list) to do the job."
msgstr ""
"주어진 파일이나 파일 리스트의 언어를 감지합니다. 인스턴스 어트리뷰트 :attr:`language_map`\\(딕셔너리)과 "
":attr:`language_order`\\(리스트)를 사용하여 작업을 수행합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:522
msgid ""
"Search the specified list of directories for a static or shared library "
"file *lib* and return the full path to that file.  If *debug* is true, "
"look for a debugging version (if that makes sense on the current "
"platform).  Return ``None`` if *lib* wasn't found in any of the specified"
" directories."
msgstr ""
"지정된 디렉터리 리스트에서 정적 또는 공유 라이브러리 파일 *lib*\\를 검색하고 해당 파일의 전체 경로를 반환합니다. "
"*debug*\\가 참이면, 디버깅 버전을 찾습니다 (현재 플랫폼에서 의미가 있다면). 지정된 디렉터리 어디에서도 *lib*\\를 "
"찾을 수 없으면 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:530
msgid ""
"Return a boolean indicating whether *funcname* is supported on the "
"current platform.  The optional arguments can be used to augment the "
"compilation environment by providing additional include files and paths "
"and libraries and paths."
msgstr ""
"현재 플랫폼에서 *funcname*\\이 지원되는지를 나타내는 불리언을 반환합니다. 선택적 인자는 추가 인클루드 파일과 경로 및 "
"라이브러리와 경로를 제공하여 컴파일 환경을 보강하는 데 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:538
msgid ""
"Return the compiler option to add *dir* to the list of directories "
"searched for libraries."
msgstr "라이브러리 검색 디렉터리 리스트에 *dir*\\을 추가하는 컴파일러 옵션을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:544
msgid ""
"Return the compiler option to add *lib* to the list of libraries linked "
"into the shared library or executable."
msgstr "공유 라이브러리나 실행 파일에 링크되는 라이브러리 리스트에 *lib*\\를 추가하는 컴파일러 옵션을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:550
msgid ""
"Return the compiler option to add *dir* to the list of directories "
"searched for runtime libraries."
msgstr "실행 시간 라이브러리 검색 디렉터리 리스트에 *dir*\\을 추가하는 컴파일러 옵션을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:556
msgid ""
"Define the executables (and options for them) that will be run to perform"
" the various stages of compilation.  The exact set of executables that "
"may be specified here depends on the compiler class (via the "
"'executables' class attribute), but most will have:"
msgstr ""
"다양한 컴파일 단계를 수행하기 위해 실행할 실행 파일(및 옵션)을 정의합니다. 여기에 지정할 수 있는 정확한 실행 파일 집합은 "
"컴파일러 클래스('executables' 클래스 어트리뷰트를 통해)에 따라 다르지만, 대부분은 다음을 갖습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:562
msgid "attribute"
msgstr "어트리뷰트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:564
msgid "*compiler*"
msgstr "*compiler*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:564
msgid "the C/C++ compiler"
msgstr "C/C++ 컴파일러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:566
msgid "*linker_so*"
msgstr "*linker_so*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:566
msgid "linker used to create shared objects and libraries"
msgstr "공유 오브젝트와 라이브러리를 만드는 데 사용되는 링커"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:569
msgid "*linker_exe*"
msgstr "*linker_exe*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:569
msgid "linker used to create binary executables"
msgstr "바이너리 실행 파일을 만드는 데 사용되는 링커"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:571
msgid "*archiver*"
msgstr "*archiver*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:571
msgid "static library creator"
msgstr "정적 라이브러리 생성기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:574
msgid ""
"On platforms with a command-line (Unix, DOS/Windows), each of these is a "
"string that will be split into executable name and (optional) list of "
"arguments. (Splitting the string is done similarly to how Unix shells "
"operate: words are delimited by spaces, but quotes and backslashes can "
"override this.  See :func:`distutils.util.split_quoted`.)"
msgstr ""
"명령 줄이 있는 플랫폼(유닉스, DOS/윈도우)에서, 이들 각각은 실행 파일 이름과 (선택적인) 인자 리스트로 분할될 문자열입니다."
" (문자열 분할은 유닉스 셸이 작동하는 방식과 유사하게 수행됩니다: 단어는 스페이스로 구분되지만, 따옴표와 역 슬래시는 이를 무시할"
" 수 있습니다. :func:`distutils.util.split_quoted`\\를 참조하십시오.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:580
msgid "The following methods invoke stages in the build process."
msgstr "다음 메서드는 빌드 프로세스의 단계를 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:585
msgid ""
"Compile one or more source files. Generates object files (e.g.  "
"transforms a :file:`.c` file to a :file:`.o` file.)"
msgstr ""
"하나 이상의 소스 파일을 컴파일합니다. 오브젝트 파일을 생성합니다 (예를 들어 :file:`.c` 파일을 :file:`.o` 파일로"
" 변환합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:588
msgid ""
"*sources* must be a list of filenames, most likely C/C++ files, but in "
"reality anything that can be handled by a particular compiler and "
"compiler class (eg. :class:`MSVCCompiler` can handle resource files in "
"*sources*).  Return a list of object filenames, one per source filename "
"in *sources*.  Depending on the implementation, not all source files will"
" necessarily be compiled, but all corresponding object filenames will be "
"returned."
msgstr ""
"*sources*\\는 C/C++ 파일과 같은 파일명 리스트이어야 하지만, 실제로는 특정 컴파일러와 컴파일러 클래스에서 처리할 수 "
"있는 모든 것입니다 (예를 들어 :class:`MSVCCompiler`\\는 *sources*\\에 있는 리소스 파일을 처리할 수 "
"있습니다). *sources*\\의 소스 파일명 당 하나씩 오브젝트 파일명 리스트를 반환합니다. 구현에 따라, 모든 소스 파일이 "
"반드시 컴파일되는 것은 아니지만, 해당하는 모든 오브젝트 파일명이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:595
msgid ""
"If *output_dir* is given, object files will be put under it, while "
"retaining their original path component.  That is, :file:`foo/bar.c` "
"normally compiles to :file:`foo/bar.o` (for a Unix implementation); if "
"*output_dir* is *build*, then it would compile to "
":file:`build/foo/bar.o`."
msgstr ""
"*output_dir*\\이 제공되면, 원래 경로 구성 요소를 유지하면서 오브젝트 파일이 그 아래에 배치됩니다. 즉, "
":file:`foo/bar.c`\\는 일반적으로 :file:`foo/bar.o`\\로 컴파일됩니다 (유닉스 구현의 경우); "
"*output_dir*\\이 *build*\\이면, :file:`build/foo/bar.o`\\로 컴파일됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:600
msgid ""
"*macros*, if given, must be a list of macro definitions.  A macro "
"definition is either a ``(name, value)`` 2-tuple or a ``(name,)`` "
"1-tuple. The former defines a macro; if the value is ``None``, the macro "
"is defined without an explicit value.  The 1-tuple case undefines a "
"macro.  Later definitions/redefinitions/undefinitions take precedence."
msgstr ""
"주어지면, *macros*\\는 매크로 정의 리스트이어야 합니다. 매크로 정의는 ``(name, value)`` 2-튜플이나 "
"``(name,)`` 1-튜플입니다. 전자는 매크로를 정의합니다; 값이 ``None``\\이면, 매크로는 명시적 값없이 정의됩니다."
" 1-튜플인 경우는 매크로 정의를 해제합니다. 나중에 오는 정의/재정의/정의 해제가 우선합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:606
msgid ""
"*include_dirs*, if given, must be a list of strings, the directories to "
"add to the default include file search path for this compilation only."
msgstr ""
"주어지면, *include_dirs*\\는 문자열 리스트이어야 하며, 이 컴파일에 대해서만 기본 인클루드 파일 검색 경로에 추가할 "
"디렉터리입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:609
msgid ""
"*debug* is a boolean; if true, the compiler will be instructed to output "
"debug symbols in (or alongside) the object file(s)."
msgstr "*debug*\\는 불리언입니다; 참이면 컴파일러는 오브젝트 파일 내에 (또는 함께) 디버그 심볼을 출력하도록 지시받습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:612
msgid ""
"*extra_preargs* and *extra_postargs* are implementation-dependent. On "
"platforms that have the notion of a command-line (e.g. Unix, "
"DOS/Windows), they are most likely lists of strings: extra command-line "
"arguments to prepend/append to the compiler command line.  On other "
"platforms, consult the implementation class documentation.  In any event,"
" they are intended as an escape hatch for those occasions when the "
"abstract compiler framework doesn't cut the mustard."
msgstr ""
"*extra_preargs*\\와 *extra_postargs*\\는 구현에 따라 다릅니다. 명령 줄 개념이 있는 플랫폼(예를 들어"
" 유닉스, DOS/윈도우)에서는, 대부분 문자열 리스트일 가능성이 높습니다: 컴파일러 명령 줄 앞에 추가하거나 뒤에 붙일 추가 명령"
" 줄 인자. 다른 플랫폼에서는, 구현 클래스 설명서를 참조하십시오. 어쨌든, 그것들은 추상 컴파일러 프레임워크가 바라는 대로 되지 "
"않는 경우를 위한 탈출용 비상구로 의도되었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:619
msgid ""
"*depends*, if given, is a list of filenames that all targets depend on.  "
"If a source file is older than any file in depends, then the source file "
"will be recompiled.  This supports dependency tracking, but only at a "
"coarse granularity."
msgstr ""
"주어지면, *depends*\\는 모든 대상이 의존하는 파일명 리스트입니다. 소스 파일이 의존하는 파일보다 오래되었으면, 소스 "
"파일이 다시 컴파일됩니다. 이는 종속성 추적을 지원하지만, 대략적인 세분성으로만 가능합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:624
msgid "Raises :exc:`CompileError` on failure."
msgstr "실패 시 :exc:`CompileError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:629
msgid ""
"Link a bunch of stuff together to create a static library file. The "
"\"bunch of stuff\" consists of the list of object files supplied as "
"*objects*, the extra object files supplied to :meth:`add_link_object` "
"and/or :meth:`set_link_objects`, the libraries supplied to "
":meth:`add_library` and/or :meth:`set_libraries`, and the libraries "
"supplied as *libraries* (if any)."
msgstr ""
"여러 가지를 함께 링크하여 정적 라이브러리 파일을 만듭니다. \"여러 가지\"는 *objects*\\로 제공되는 오브젝트 파일 "
"리스트, :meth:`add_link_object` 및/또는 :meth:`set_link_objects`\\에 제공되는 추가 "
"오브젝트 파일, :meth:`add_library` 및/또는 :meth:`set_libraries`\\에 제공되는 라이브러리, "
"*libraries*\\(있다면)로 제공되는 라이브러리로 구성됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:635
msgid ""
"*output_libname* should be a library name, not a filename; the filename "
"will be inferred from the library name.  *output_dir* is the directory "
"where the library file will be put."
msgstr ""
"*output_libname*\\은 파일명이 아닌 라이브러리 이름이어야 합니다; 파일명은 라이브러리 이름에서 유추됩니다. "
"*output_dir*\\은 라이브러리 파일이 저장될 디렉터리입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:641
msgid ""
"*debug* is a boolean; if true, debugging information will be included in "
"the library (note that on most platforms, it is the compile step where "
"this matters: the *debug* flag is included here just for consistency)."
msgstr ""
"*debug*\\는 불리언입니다; 참이면, 디버깅 정보가 라이브러리에 포함됩니다 (대부분의 플랫폼에서, 이것이 중요한 곳은 컴파일 "
"단계임에 유의하십시오: 단지 일관성을 위해 *debug* 플래그가 여기에 포함됩니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:645
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:687
msgid ""
"*target_lang* is the target language for which the given objects are "
"being compiled. This allows specific linkage time treatment of certain "
"languages."
msgstr "*target_lang*\\은 주어진 오브젝트가 컴파일된 대상 언어입니다. 이를 통해 특정 언어의 특정 링크 시간 처리가 가능합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:648
msgid "Raises :exc:`LibError` on failure."
msgstr "실패 시 :exc:`LibError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:653
msgid ""
"Link a bunch of stuff together to create an executable or shared library "
"file."
msgstr "여러 가지를 함께 링크하여 실행 파일이나 공유 라이브러리 파일을 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:655
msgid ""
"The \"bunch of stuff\" consists of the list of object files supplied as "
"*objects*. *output_filename* should be a filename.  If *output_dir* is "
"supplied, *output_filename* is relative to it (i.e. *output_filename* can"
" provide directory components if needed)."
msgstr ""
"\"여러 가지\"는 *objects*\\로 제공되는 오브젝트 파일 리스트로 구성됩니다. *output_filename*\\은 "
"파일명이어야 합니다. *output_dir*\\이 제공되면, *output_filename*\\은 이에 상대적입니다 (즉 "
"*output_filename*\\은 필요하면 디렉터리 구성 요소를 제공할 수 있습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:660
msgid ""
"*libraries* is a list of libraries to link against.  These are library "
"names, not filenames, since they're translated into filenames in a "
"platform-specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and "
":file:`foo.lib` on DOS/Windows).  However, they can include a directory "
"component, which means the linker will look in that specific directory "
"rather than searching all the normal locations."
msgstr ""
"*libraries*\\는 링크할 라이브러리 리스트입니다. 이는 파일명이 아니라 라이브러리 이름입니다. 플랫폼에 특정한 방식으로 "
"파일명으로 변환되기 때문입니다 (예를 들어 *foo*\\는 유닉스에서는 :file:`libfoo.a`\\가 되고 DOS/윈도우에서는"
" :file:`foo.lib`\\가 됩니다). 그러나, 이들은 디렉터리 구성 요소를 포함할 수 있습니다. 이는 링커가 모든 정상적인"
" 위치를 검색하지 않고 특정 디렉터리를 찾는다는 의미입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:667
msgid ""
"*library_dirs*, if supplied, should be a list of directories to search "
"for libraries that were specified as bare library names (ie. no directory"
" component).  These are on top of the system default and those supplied "
"to :meth:`add_library_dir` and/or :meth:`set_library_dirs`.  "
"*runtime_library_dirs* is a list of directories that will be embedded "
"into the shared library and used to search for other shared libraries "
"that \\*it\\* depends on at run-time.  (This may only be relevant on "
"Unix.)"
msgstr ""
"제공되면, *library_dirs*\\는 맨 라이브러리 이름으로 지정된 라이브러리를 검색하기 위한 디렉터리 리스트이어야 합니다 "
"(즉, 디렉터리 구성 요소가 없습니다). 이는 시스템 기본값과 :meth:`add_library_dir` 및/또는 "
":meth:`set_library_dirs`\\에 제공된 것 위에 있습니다. *runtime_library_dirs*\\는 공유 "
"라이브러리에 내장되고, \\*그것\\*이 실행 시간에 의존하는 다른 공유 라이브러리를 검색하는 데 사용되는 디렉터리 리스트입니다. "
"(이것은 유닉스에서만 의미 있을 수 있습니다.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:675
msgid ""
"*export_symbols* is a list of symbols that the shared library will "
"export. (This appears to be relevant only on Windows.)"
msgstr "*export_symbols*\\는 공유 라이브러리가 내보낼 심볼 리스트입니다. (이것은 윈도우에서만 의미 있는 것으로 보입니다.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:678
msgid ""
"*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with "
"the slight distinction that it actually matters on most platforms (as "
"opposed to :meth:`create_static_lib`, which includes a *debug* flag "
"mostly for form's sake)."
msgstr ""
"*debug*\\는 :meth:`compile`\\과 :meth:`create_static_lib`\\와 같지만, 대부분의 "
"플랫폼에서 실제로 중요하다는 약간의 차이가 있습니다 (대부분 형식을 위해 *debug* 플래그를 포함하는 "
":meth:`create_static_lib`\\와 대조적입니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:683
msgid ""
"*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except "
"of course that they supply command-line arguments for the particular "
"linker being used)."
msgstr ""
"*extra_preargs*\\와 *extra_postargs*\\는 :meth:`compile`\\와 같습니다 (물론 사용 중인 "
"특정 링커에 대한 명령 줄 인자를 제공한다는 점은 제외합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:690
msgid "Raises :exc:`LinkError` on failure."
msgstr "실패 시 :exc:`LinkError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:695
msgid ""
"Link an executable.  *output_progname* is the name of the file "
"executable, while *objects* are a list of object filenames to link in. "
"Other arguments  are as for the :meth:`link` method."
msgstr ""
"실행 파일을 링크합니다. *output_progname*\\은 실행 파일의 이름이고, *objects*\\는 링크할 오브젝트 파일명"
" 리스트입니다. 다른 인자는 :meth:`link` 메서드와 같습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:702
msgid ""
"Link a shared library. *output_libname* is the name of the output  "
"library, while *objects* is a list of object filenames to link in.  Other"
" arguments are as for the :meth:`link` method."
msgstr ""
"공유 라이브러리를 링크합니다. *output_libname*\\은 출력 라이브러리의 이름이고, *objects*\\는 링크할 "
"오브젝트 파일명 리스트입니다. 다른 인자는 :meth:`link` 메서드와 같습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:709
msgid ""
"Link a shared object. *output_filename* is the name of the shared object "
"that will be created, while *objects* is a list of object filenames  to "
"link in. Other arguments are as for the :meth:`link` method."
msgstr ""
"공유 오브젝트를 링크합니다. *output_filename*\\은 생성될 공유 오브젝트의 이름이고, *objects*\\는 링크할 "
"오브젝트 파일명 리스트입니다. 다른 인자는 :meth:`link` 메서드와 같습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:716
msgid ""
"Preprocess a single C/C++ source file, named in *source*. Output will be "
"written to file named *output_file*, or *stdout* if *output_file* not "
"supplied. *macros* is a list of macro definitions as for :meth:`compile`,"
" which will augment the macros set with :meth:`define_macro` and "
":meth:`undefine_macro`. *include_dirs* is a list of directory names that "
"will be added to the  default list, in the same way as "
":meth:`add_include_dir`."
msgstr ""
"*source*\\로 명명된 단일 C/C++ 소스 파일을 전처리합니다. 출력은 *output_file*\\이나, 또는 "
"*output_file*\\이 제공되지 않으면 *stdout*\\으로 기록됩니다. *macros*\\는 "
":meth:`compile`\\에서와 같은 매크로 정의 리스트로, :meth:`define_macro`\\와 "
":meth:`undefine_macro`\\로 설정된 매크로 집합을 확장합니다. *include_dirs*\\는 "
":meth:`add_include_dir`\\과 같은 방식으로 기본 리스트에 추가될 디렉터리 이름 리스트입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:723
msgid "Raises :exc:`PreprocessError` on failure."
msgstr "실패 시 :exc:`PreprocessError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:725
msgid ""
"The following utility methods are defined by the :class:`CCompiler` "
"class, for use by the various concrete subclasses."
msgstr "다음 유틸리티 메서드는 다양한 구상 서브 클래스에서 사용하기 위해 :class:`CCompiler` 클래스에 의해 정의됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:731
msgid ""
"Returns the filename of the executable for the given *basename*.  "
"Typically for non-Windows platforms this is the same as the basename,  "
"while Windows will get a :file:`.exe` added."
msgstr ""
"주어진 *basename*\\에 대한 실행 파일의 파일명을 반환합니다. 일반적으로 윈도우가 아닌 플랫폼의 경우 basename과 "
"같지만, 윈도우에서는 :file:`.exe`\\가 추가됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:738
msgid ""
"Returns the filename for the given library name on the current platform. "
"On Unix a library with *lib_type* of ``'static'`` will typically  be of "
"the form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will "
"be of the form :file:`liblibname.so`."
msgstr ""
"현재 플랫폼에서 주어진 라이브러리 이름에 대한 파일명을 반환합니다. 유닉스에서 *lib_type*\\이 ``'static'``\\인"
" 라이브러리는 일반적으로 :file:`liblibname.a` 형식이고, *lib_type*\\이 ``'dynamic'`` 인 "
"라이브러리는 :file:`liblibname.so` 형식입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:746
msgid ""
"Returns the name of the object files for the given source files. "
"*source_filenames* should be a list of filenames."
msgstr "주어진 소스 파일에 대한 오브젝트 파일의 이름을 반환합니다. *source_filenames*\\는 파일명 리스트이어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:752
msgid ""
"Returns the name of a shared object file for the given file name "
"*basename*."
msgstr "주어진 파일 이름 *basename*\\에 대한 공유 오브젝트 파일의 이름을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:757
msgid ""
"Invokes :func:`distutils.util.execute`. This method invokes a  Python "
"function *func* with the given arguments *args*, after  logging and "
"taking into account the *dry_run* flag."
msgstr ""
":func:`distutils.util.execute`\\를 호출합니다. 이 메서드는 *dry_run* 플래그를 로깅하고 고려한 "
"후, 주어진 인자 *args*\\로 파이썬 함수 *func*\\를 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:764
msgid ""
"Invokes :func:`distutils.util.spawn`. This invokes an external  process "
"to run the given command."
msgstr ":func:`distutils.util.spawn`\\을 호출합니다. 이것은 주어진 명령을 실행하기 위해 외부 프로세스를 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:770
msgid ""
"Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and "
"any missing ancestor directories."
msgstr ":func:`distutils.dir_util.mkpath`\\를 호출합니다. 그러면 디렉터리와 누락된 조상 디렉터리를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:776
msgid "Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*."
msgstr ""
":meth:`distutils.file_util.move_file`\\을 호출합니다. *src*\\를 *dst*\\로 이름을 "
"바꿉니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:781
msgid "Write a message using :func:`distutils.log.debug`."
msgstr ":func:`distutils.log.debug`\\를 사용하여 메시지를 작성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:786
msgid "Write a warning message *msg* to standard error."
msgstr "표준 에러에 경고 메시지 *msg*\\를 씁니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:791
msgid ""
"If the *debug* flag is set on this :class:`CCompiler` instance, print  "
"*msg* to standard output, otherwise do nothing."
msgstr ""
"이 :class:`CCompiler` 인스턴스에 *debug* 플래그가 설정되어 있으면, *msg*\\를 표준 출력으로 인쇄하고, "
"그렇지 않으면 아무 작업도 수행하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:803
msgid ":mod:`distutils.unixccompiler` --- Unix C Compiler"
msgstr ":mod:`distutils.unixccompiler` --- 유닉스 C 컴파일러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:809
msgid ""
"This module provides the :class:`UnixCCompiler` class, a subclass of "
":class:`CCompiler` that handles the typical Unix-style command-line  C "
"compiler:"
msgstr ""
"이 모듈은 일반적인 유닉스 스타일 명령 줄 C 컴파일러를 다루는 :class:`CCompiler`\\의 서브 클래스인 "
":class:`UnixCCompiler` 클래스를 제공합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:812
msgid "macros defined with :option:`!-Dname[=value]`"
msgstr ":option:`!-Dname[=value]`\\로 정의된 매크로"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:814
msgid "macros undefined with :option:`!-Uname`"
msgstr ":option:`!-Uname`\\으로 정의 해제된 매크로"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:816
msgid "include search directories specified with :option:`!-Idir`"
msgstr ":option:`!-Idir`\\로 지정된 인클루드 검색 디렉터리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:818
msgid "libraries specified with :option:`!-llib`"
msgstr ":option:`!-llib`\\로 지정된 라이브러리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:820
msgid "library search directories specified with :option:`!-Ldir`"
msgstr ":option:`!-Ldir`\\로 지정된 라이브러리 검색 디렉터리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:822
msgid ""
"compile handled by :program:`cc` (or similar) executable with "
":option:`!-c` option: compiles :file:`.c` to :file:`.o`"
msgstr ""
":option:`!-c` 옵션을 사용하여 :program:`cc` (또는 이와 유사한) 실행 파일로 처리되는 컴파일: "
":file:`.c`\\를 :file:`.o`\\로 컴파일합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:825
msgid ""
"link static library handled by :program:`ar` command (possibly with "
":program:`ranlib`)"
msgstr ":program:`ar` 명령으로 처리되는 정적 라이브러리 링크 (:program:`ranlib` 사용 가능)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:828
msgid "link shared library handled by :program:`cc` :option:`!-shared`"
msgstr ":program:`cc` :option:`!-shared`\\로 처리되는 공유 라이브러리 링크"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:832
msgid ":mod:`distutils.msvccompiler` --- Microsoft Compiler"
msgstr ":mod:`distutils.msvccompiler` --- Microsoft 컴파일러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:839
msgid ""
"This module provides :class:`MSVCCompiler`, an implementation of the "
"abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically,"
" extension modules need to be compiled with the same compiler that was "
"used to compile Python. For Python 2.3 and earlier, the compiler was "
"Visual Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio "
".NET 2003."
msgstr ""
"이 모듈은 Microsoft Visual Studio 용 추상 :class:`CCompiler` 클래스의 구현인, "
":class:`MSVCCompiler`\\를 제공합니다. 일반적으로, 확장 모듈은 파이썬을 컴파일하는 데 사용된 것과 같은 "
"컴파일러로 컴파일해야 합니다. 파이썬 2.3과 이전 버전의 경우, 컴파일러는 Visual Studio 6이었습니다. 파이썬 2.4와"
" 2.5의 경우, 컴파일러는 Visual Studio .NET 2003입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:845
msgid ""
":class:`MSVCCompiler` will normally choose the right compiler, linker "
"etc. on its own. To override this choice, the environment variables "
"*DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that "
"the current environment has been setup by the SDK's ``SetEnv.Cmd`` "
"script, or that the environment variables had been registered when the "
"SDK was installed; *DISTUTILS_USE_SDK* indicates that the distutils user "
"has made an explicit choice to override the compiler selection by "
":class:`MSVCCompiler`."
msgstr ""
":class:`MSVCCompiler`\\는 일반적으로 자체적으로 올바른 컴파일러, 링커 등을 선택합니다. 이 선택을 재정의하려면,"
" 환경 변수 *DISTUTILS_USE_SDK*\\와 *MSSdk*\\를 모두 설정해야 합니다. *MSSdk*\\는 현재 환경이 "
"SDK의 ``SetEnv.Cmd`` 스크립트에 의해 설정되었거나, SDK가 설치될 때 환경 변수가 등록되었음을 나타냅니다. "
"*DISTUTILS_USE_SDK*\\는 distutils 사용자가 :class:`MSVCCompiler`\\의 컴파일러 선택을 "
"재정의하도록 명시적으로 선택했음을 나타냅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:855
msgid ":mod:`distutils.bcppcompiler` --- Borland Compiler"
msgstr ":mod:`distutils.bcppcompiler` --- Borland 컴파일러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:860
msgid ""
"This module provides :class:`BorlandCCompiler`, a subclass of the "
"abstract :class:`CCompiler` class for the Borland C++ compiler."
msgstr ""
"이 모듈은 Borland C++ 컴파일러용 추상 :class:`CCompiler` 클래스의 서브 클래스인 "
":class:`BorlandCCompiler`\\를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:865
msgid ":mod:`distutils.cygwincompiler` --- Cygwin Compiler"
msgstr ":mod:`distutils.cygwincompiler` --- Cygwin 컴파일러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:870
msgid ""
"This module provides the :class:`CygwinCCompiler` class, a subclass of "
":class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler"
" to Windows.  It also contains the Mingw32CCompiler class which handles "
"the mingw32 port of GCC (same as cygwin in no-cygwin mode)."
msgstr ""
"이 모듈은 윈도우로의 GNU C 컴파일러의 Cygwin 이식을 다루는 :class:`UnixCCompiler`\\의 서브 클래스인 "
":class:`CygwinCCompiler` 클래스를 제공합니다. 또한 GCC의 mingw32 이식을 다루는 "
"Mingw32CCompiler 클래스도 포함합니다 (no-cygwin 모드의 cygwin과 같습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:877
msgid ":mod:`distutils.archive_util` ---  Archiving utilities"
msgstr ":mod:`distutils.archive_util` --- 아카이브 유틸리티"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:883
msgid ""
"This module provides a few functions for creating archive files, such as "
"tarballs or zipfiles."
msgstr "이 모듈은 tar나 zip 파일과 같은 아카이브 파일을 만들기 위한 몇 가지 함수를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:889
msgid ""
"Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the "
"name of the file to create, minus any format-specific extension;  "
"*format* is the archive format: one of ``zip``, ``tar``, ``gztar``, "
"``bztar``, ``xztar``, or ``ztar``. *root_dir* is a directory that will be"
" the root directory of the archive; ie. we typically ``chdir`` into "
"*root_dir* before  creating the archive.  *base_dir* is the directory "
"where we start  archiving from; ie. *base_dir* will be the common prefix "
"of all files and directories in the archive.  *root_dir* and *base_dir* "
"both default to the current directory. Returns the name of the archive "
"file."
msgstr ""
"아카이브 파일(예를 들어 ``zip``\\이나 ``tar``)을 만듭니다. *base_name*\\은 만들 파일의 이름에서 형식별 "
"확장자를 뺀 것입니다; *format*\\은 아카이브 형식입니다: ``zip``, ``tar``, ``gztar``, "
"``bztar``, ``xztar`` 또는 ``ztar`` 중 하나입니다. *root_dir*\\은 아카이브의 루트 디렉터리가 될 "
"디렉터리입니다; 즉, 일반적으로 아카이브를 만들기 전에 *root_dir*\\로 ``chdir`` 합니다. *base_dir*\\은"
" 아카이빙을 시작하는 디렉터리입니다; 즉. *base_dir*\\은 아카이브에 있는 모든 파일과 디렉터리의 공통 접두사입니다. "
"*root_dir*\\과 *base_dir* 모두 기본값은 현재 디렉터리입니다. 아카이브 파일의 이름을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:899
msgid "Added support for the ``xztar`` format."
msgstr "``xztar`` 형식에 대한 지원이 추가되었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:905
msgid ""
"'Create an (optional compressed) archive as a tar file from all files in "
"and under *base_dir*. *compress* must be ``'gzip'`` (the default), "
"``'bzip2'``, ``'xz'``, ``'compress'``, or ``None``.  For the "
"``'compress'`` method the compression utility named by "
":program:`compress` must be on the default program search path, so this "
"is probably Unix-specific.  The output tar file will be named "
":file:`base_dir.tar`, possibly plus the appropriate compression extension"
" (``.gz``, ``.bz2``, ``.xz`` or ``.Z``).  Return the output filename."
msgstr ""
"'*base_dir*\\과 그 밑의 모든 파일로 구성된 tar 파일로 (선택적으로 압축된) 아카이브를 만듭니다. "
"*compress*\\는 ``'gzip'`` (기본값), ``'bzip2'``, ``'xz'``, ``'compress'`` 또는 "
"``None``\\이어야 합니다. ``'compress'`` 방법의 경우 :program:`compress`\\라는 이름의 압축 "
"유틸리티가 기본 프로그램 검색 경로에 있어야 하므로, 이는 유닉스에 한정된 것일 수 있습니다. 출력 tar 파일의 이름은 "
":file:`base_dir.tar`\\이며, 적절한 압축 확장자 (``.gz``, ``.bz2``, ``.xz`` 또는 "
"``.Z``)가 추가될 수 있습니다. 출력 파일명을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:914
msgid "Added support for the ``xz`` compression."
msgstr "``xz`` 압축에 대한 지원이 추가되었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:920
msgid ""
"Create a zip file from all files in and under *base_dir*.  The output zip"
" file will be named *base_name* + :file:`.zip`.  Uses either the  "
":mod:`zipfile` Python module (if available) or the InfoZIP :file:`zip`  "
"utility (if installed and found on the default search path).  If neither"
"  tool is available, raises :exc:`DistutilsExecError`.   Returns the name"
" of the output zip file."
msgstr ""
"*base_dir*\\과 그 밑의 모든 파일로 zip 파일을 만듭니다. 출력 zip 파일의 이름은 *base_name* + "
":file:`.zip`\\입니다. (사용할 수 있으면) :mod:`zipfile` 파이썬 모듈이나 (설치되어 기본 검색 경로에 "
"있으면) InfoZIP :file:`zip` 유틸리티를 사용합니다. 두 도구를 모두 사용할 수 없으면, "
":exc:`DistutilsExecError`\\를 발생시킵니다. 출력 zip 파일의 이름을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:928
msgid ":mod:`distutils.dep_util` --- Dependency checking"
msgstr ":mod:`distutils.dep_util` --- 종속성 검사"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:934
msgid ""
"This module provides functions for performing simple, timestamp-based "
"dependency of files and groups of files; also, functions based entirely  "
"on such timestamp dependency analysis."
msgstr ""
"이 모듈은 파일과 파일 그룹의 간단한 타임 스탬프 기반 종속성을 수행하는 함수를 제공합니다; 또한, 이러한 타임 스탬프 종속성 "
"분석에 전적으로 기반하는 함수를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:941
msgid ""
"Return true if *source* exists and is more recently modified than "
"*target*, or if *source* exists and *target* doesn't. Return false if "
"both exist and *target* is the same age or newer  than *source*. Raise "
":exc:`DistutilsFileError` if *source* does not exist."
msgstr ""
"*source*\\가 존재하고 *target*\\보다 최근에 수정되었거나, *source*\\가 존재하고 *target*\\이 "
"존재하지 않으면 참을 반환합니다. 둘 다 존재하고 *target*\\이 같은 연령이거나 *source*\\보다 새로우면 거짓을 "
"반환합니다. *source*\\가 없으면 :exc:`DistutilsFileError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:949
msgid ""
"Walk two filename lists in parallel, testing if each source is newer than"
" its corresponding target.  Return a pair of lists (*sources*, *targets*)"
" where source is newer than target, according to the semantics of "
":func:`newer`."
msgstr ""
"두 개의 파일명 리스트를 병렬로 탐색하여, 각 소스가 해당 대상보다 최신인지 테스트합니다. :func:`newer`\\의 의미에 "
"따라 소스가 대상보다 최신인 리스트 쌍 (*sources*, *targets*)를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:958
msgid ""
"Return true if *target* is out-of-date with respect to any file listed in"
" *sources*.  In other words, if *target* exists and is newer than every "
"file in *sources*, return false; otherwise return true. *missing* "
"controls what we do when a source file is missing; the default "
"(``'error'``) is to blow up with an :exc:`OSError` from  inside "
":func:`os.stat`; if it is ``'ignore'``, we silently drop any missing "
"source files; if it is ``'newer'``, any missing source files make us "
"assume that *target* is out-of-date (this is handy in \"dry-run\" mode: "
"it'll make you pretend to carry out commands that wouldn't work because "
"inputs are missing, but that doesn't matter because you're not actually "
"going to run the commands)."
msgstr ""
"*sources*\\에 나열된 파일과 관련하여 *target*\\이 오래되었으면 참을 반환합니다. 즉, *target*\\이 "
"존재하고 *sources*\\의 모든 파일보다 최신이면 거짓을 반환합니다; 그렇지 않으면 참을 반환합니다. *missing*\\은 "
"소스 파일이 누락되었을 때 수행하는 작업을 제어합니다; 기본값(``'error'``)은 :func:`os.stat` 내부에서 오는 "
":exc:`OSError`\\로 터뜨리는 것입니다; ``'ignore'``\\이면, 누락된 소스 파일을 조용히 무시합니다; "
"``'newer'``\\이면, 누락된 소스 파일은 *target*\\이 최신이 아니라고 가정하도록 합니다 (\"dry_run\" "
"모드에서 편리합니다: 입력이 누락되어 작동하지 않는 명령을 수행하는 척합니다만, 실제로 명령을 실행하지 않기 때문에 중요하지 "
"않습니다.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:971
msgid ":mod:`distutils.dir_util` --- Directory tree operations"
msgstr ":mod:`distutils.dir_util` --- 디렉터리 트리 연산"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:977
msgid ""
"This module provides functions for operating on directories and trees of "
"directories."
msgstr "이 모듈은 디렉터리와 디렉터리 트리에서 작동하는 함수를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:983
msgid ""
"Create a directory and any missing ancestor directories.  If the "
"directory already exists (or if *name* is the empty string, which means "
"the current directory, which of course exists), then do nothing.  Raise "
":exc:`DistutilsFileError` if unable to create some directory along the "
"way (eg. some sub-path exists, but is a file rather than a directory).  "
"If *verbose* is true, print a one-line summary of each mkdir to stdout.  "
"Return the list of directories actually created."
msgstr ""
"디렉터리와 누락된 모든 조상 디렉터리를 만듭니다. 디렉터리가 이미 존재하면 (또는 *name*\\이 현재 디렉터리를 의미하는 빈 "
"문자열이면, 물론 당연히 존재합니다), 아무 작업도 수행하지 않습니다. 도중에 일부 디렉터리를 만들 수 없으면 "
":exc:`DistutilsFileError`\\를 발생시킵니다 (예를 들어 일부 하위 경로가 있지만, 디렉터리가 아니라 "
"파일이면). *verbose*\\가 참이면, 각 mkdir의 한 줄 요약을 stdout에 인쇄합니다. 실제로 만들어진 디렉터리 "
"리스트를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:994
msgid ""
"Create all the empty directories under *base_dir* needed to put *files* "
"there. *base_dir* is just the name of a directory which doesn't "
"necessarily exist yet; *files* is a list of filenames to be interpreted "
"relative to *base_dir*. *base_dir* + the directory portion of every file "
"in *files* will be created if it doesn't already exist.  *mode*, "
"*verbose* and *dry_run* flags  are as for :func:`mkpath`."
msgstr ""
"*base_dir* 아래에 *files*\\를 넣는 데 필요한 모든 빈 디렉터리를 만듭니다. *base_dir*\\은 아직 존재할 "
"필요는 없는 디렉터리의 이름일 뿐입니다; *files*\\는 *base_dir*\\에 상대적으로 해석할 파일명 리스트입니다. "
"*base_dir* + *files*\\에 있는 모든 파일의 디렉터리 부분이 아직 존재하지 않는다면 만들어집니다. *mode*, "
"*verbose* 및 *dry_run* 플래그는 :func:`mkpath`\\와 같습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1004
msgid ""
"Copy an entire directory tree *src* to a new location *dst*.  Both *src* "
"and *dst* must be directory names.  If *src* is not a directory, raise "
":exc:`DistutilsFileError`.  If *dst* does  not exist, it is created with "
":func:`mkpath`.  The end result of the  copy is that every file in *src* "
"is copied to *dst*, and  directories under *src* are recursively copied "
"to *dst*. Return the list of files that were copied or might have been "
"copied, using their output name. The return value is unaffected by "
"*update* or *dry_run*: it is simply the list of all files under *src*, "
"with the names changed to be under *dst*."
msgstr ""
"전체 디렉터리 트리 *src*\\를 새 위치 *dst*\\로 복사합니다. *src*\\와 *dst*\\는 모두 디렉터리 이름이어야 "
"합니다. *src*\\가 디렉터리가 아니면, :exc:`DistutilsFileError`\\를 발생시킵니다. *dst*\\가 "
"없으면, :func:`mkpath`\\로 만들어집니다. 복사의 최종 결과는 *src*\\의 모든 파일이 *dst*\\로 복사되고, "
"*src* 아래의 디렉터리가 재귀적으로 *dst*\\로 복사된다는 것입니다. 출력 이름을 사용하여, 복사되었거나 복사되었어야 할 "
"파일 리스트를 반환합니다. 반환 값은 *update*\\나 *dry_run*\\의 영향을 받지 않습니다: 단순히 *src* 아래의 "
"모든 파일 리스트이며, 이름이 *dst* 아래로 변경된 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1014
msgid ""
"*preserve_mode* and *preserve_times* are the same as for "
":func:`distutils.file_util.copy_file`; note that they only apply to "
"regular files, not to directories.  If *preserve_symlinks* is true, "
"symlinks will be copied as symlinks (on platforms that support them!); "
"otherwise (the default), the destination of the symlink will be copied.  "
"*update* and *verbose* are the same as for :func:`copy_file`."
msgstr ""
"*preserve_mode*\\와 *preserve_times*\\는 "
":func:`distutils.file_util.copy_file`\\과 같습니다; 디렉터리가 아닌 일반 파일에만 적용됨에 "
"유의하십시오. *preserve_symlinks*\\가 참이면, 심볼릭 링크가 심볼릭 링크로 복사됩니다 (지원하는 플랫폼에서!); "
"그렇지 않으면 (기본값), 심볼릭 링크의 대상이 복사됩니다. *update*\\와 *verbose*\\는 "
":func:`copy_file`\\과 같습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1022
msgid ""
"Files in *src* that begin with :file:`.nfs` are skipped (more information"
" on these files is available in answer D2 of the `NFS FAQ page "
"<http://nfs.sourceforge.net/#section_d>`_)."
msgstr ""
":file:`.nfs`\\로 시작하는 *src*\\의 파일은 건너뜁니다 (이러한 파일에 대한 자세한 내용은 `NFS FAQ page"
" <http://nfs.sourceforge.net/#section_d>`_\\의 답변 D2에서 볼 수 있습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1026
msgid "NFS files are ignored."
msgstr "NFS 파일은 무시됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1031
msgid ""
"Recursively remove *directory* and all files and directories underneath "
"it. Any errors are ignored (apart from being reported to ``sys.stdout`` "
"if *verbose* is true)."
msgstr ""
"*directory*\\와 그 아래의 모든 파일과 디렉터리를 재귀적으로 제거합니다. 모든 에러는 무시됩니다 (*verbose*\\가"
" 참이면 ``sys.stdout``\\에 보고되는 것은 제외하고)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1037
msgid ":mod:`distutils.file_util` --- Single file operations"
msgstr ":mod:`distutils.file_util` --- 단일 파일 연산"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1043
msgid ""
"This module contains some utility functions for operating on individual "
"files."
msgstr "이 모듈에는 개별 파일에서 작동하는 몇 가지 유틸리티 함수가 포함되어 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1048
msgid ""
"Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied "
"there with the same name; otherwise, it must be a filename. (If the file "
"exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the"
" default), the file's mode (type and permission bits, or whatever is "
"analogous on the current platform) is copied. If *preserve_times* is true"
" (the default), the last-modified and last-access times are copied as "
"well. If *update* is true, *src* will only be copied if *dst* does not "
"exist, or if *dst* does exist but is older than *src*."
msgstr ""
"*src* 파일을 *dst*\\로 복사합니다. *dst*\\가 디렉터리이면, *src*\\는 같은 이름으로 거기에 복사됩니다; "
"그렇지 않으면, 파일명이어야 합니다. (파일이 존재하면, 무자비하게 파괴될 것입니다.) *preserve_mode*\\가 "
"참(기본값)이면, 파일의 모드(유형과 권한 비트, 또는 현재 플랫폼에서 유사한 무엇이건)가 복사됩니다. "
"*preserve_times*\\가 참(기본값)이면, 마지막 수정과 마지막 액세스 시간도 복사됩니다. *update*\\가 참이면,"
" *dst*\\가 존재하지 않거나, *dst*\\가 존재하지만 *src*\\보다 오래된 경우에만 *src*\\가 복사됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1057
msgid ""
"*link* allows you to make hard links (using :func:`os.link`) or symbolic "
"links (using :func:`os.symlink`) instead of copying: set it to ``'hard'``"
" or ``'sym'``; if it is ``None`` (the default), files are copied. Don't "
"set *link* on systems that don't support it: :func:`copy_file` doesn't "
"check if hard or symbolic linking is available.  It uses "
":func:`_copy_file_contents` to copy file contents."
msgstr ""
"*link*\\를 사용하면 복사하는 대신 하드 링크(:func:`os.link` 사용)나 심볼릭 "
"링크(:func:`os.symlink` 사용)를 만들 수 있습니다: ``'hard'``\\나 ``'sym'``\\으로 설정하십시오;"
" ``None``\\(기본값)이면, 파일이 복사됩니다. 지원하지 않는 시스템에서는 *link*\\를 설정하지 마십시오: "
":func:`copy_file`\\은 하드나 심볼릭 링크를 사용할 수 있는지 확인하지 않습니다. "
":func:`_copy_file_contents`\\를 사용하여 파일 내용을 복사합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1064
msgid ""
"Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name "
"of the output file, and *copied* is true if the file was copied  (or "
"would have been copied, if *dry_run* true)."
msgstr ""
"튜플 ``(dest_name, copied)``\\를 반환합니다: *dest_name*\\은 출력 파일의 실제 이름이고, 파일이 "
"복사되었으면 (또는 *dry_run*\\이 참이면, 복사했어야 할 것이면) *copied*\\는 참입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1078
msgid ""
"Move file *src* to *dst*. If *dst* is a directory, the file will be moved"
" into it with the same name; otherwise, *src* is just renamed to *dst*.  "
"Returns the new full name of the file."
msgstr ""
"*src* 파일을 *dst*\\로 이동합니다. *dst*\\가 디렉터리이면, 파일은 같은 이름으로 거기에 이동됩니다; 그렇지 "
"않으면, *src*\\는 단지 *dst*\\로 이름이 바뀝니다. 파일의 새로운 전체 이름을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1084
msgid ""
"Handles cross-device moves on Unix using :func:`copy_file`.  What about "
"other systems?"
msgstr ":func:`copy_file`\\을 사용하여 유닉스에서 장치 간 이동을 처리합니다. 다른 시스템은 어떻습니까?"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1090
msgid ""
"Create a file called *filename* and write *contents* (a sequence of "
"strings without line terminators) to it."
msgstr "*filename*\\이라는 파일을 만들고 그곳에 *contents*\\(줄 종결자가 없는 문자열 시퀀스)를 씁니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1095
msgid ":mod:`distutils.util` --- Miscellaneous other utility functions"
msgstr ":mod:`distutils.util` --- 기타 유틸리티 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1101
msgid ""
"This module contains other assorted bits and pieces that don't fit into  "
"any other utility module."
msgstr "이 모듈에는 다른 유틸리티 모듈에 맞지 않는 잡동사니가 포함되어 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1107
msgid ""
"Return a string that identifies the current platform.  This is used "
"mainly to distinguish platform-specific build directories and platform-"
"specific built distributions.  Typically includes the OS name and version"
" and the architecture (as supplied by 'os.uname()'), although the exact "
"information included depends on the OS; e.g., on Linux, the kernel "
"version isn't particularly important."
msgstr ""
"현재 플랫폼을 식별하는 문자열을 반환합니다. 주로 플랫폼별 빌드 디렉터리와 플랫폼별 빌드 배포판을 구분하는 데 사용됩니다. 포함된 "
"정확한 정보는 OS에 따라 다르지만, 일반적으로 OS 이름과 버전 및 아키텍처를 포함합니다 ('os.uname()'에서 제공되는);"
" 예를 들어, 리눅스에서는 커널 버전이 특별히 중요하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1114
msgid "Examples of returned values:"
msgstr "반환된 값의 예:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1116
msgid "``linux-i586``"
msgstr "``linux-i586``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1117
msgid "``linux-alpha``"
msgstr "``linux-alpha``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1118
msgid "``solaris-2.6-sun4u``"
msgstr "``solaris-2.6-sun4u``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1120
msgid "For non-POSIX platforms, currently just returns ``sys.platform``."
msgstr "POSIX가 아닌 플랫폼의 경우, 현재는 ``sys.platform`` 만 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1122
msgid ""
"For Mac OS X systems the OS version reflects the minimal version on which"
" binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` "
"during the build of Python), not the OS version of the current system."
msgstr ""
"Mac OS X 시스템의 경우 OS 버전은 현재 시스템의 OS 버전이 아니라, 바이너리가 실행될 최소 버전(즉, 파이썬 빌드 중 "
"``MACOSX_DEPLOYMENT_TARGET``\\의 값)을 반영합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1126
msgid ""
"For universal binary builds on Mac OS X the architecture value reflects "
"the universal binary status instead of the architecture of the current "
"processor. For 32-bit universal binaries the architecture is ``fat``, for"
" 64-bit universal binaries the architecture is ``fat64``, and for 4-way "
"universal binaries the architecture is ``universal``. Starting from "
"Python 2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way "
"universal build (ppc, i386, x86_64) and ``intel`` is used for a universal"
" build with the i386 and x86_64 architectures"
msgstr ""
"Mac OS X의 유니버설 바이너리 빌드의 경우 아키텍처값은 현재 프로세서의 아키텍처 대신 유니버설 바이너리 상태를 반영합니다. "
"32비트 유니버설 바이너리의 경우 아키텍처는 ``fat``, 64비트 유니버설 바이너리의 경우 아키텍처는 ``fat64``, 4방향"
" 유니버설 바이너리(4-way universal binaries)의 경우 아키텍처는 ``universal``\\입니다. 파이썬 "
"2.7과 파이썬 3.2부터 아키텍처 ``fat3``\\은 3방향 유니버설 빌드 (ppc, i386, x86_64)에 사용되고 "
"``intel``\\은 i386과 x86_64 아키텍처의 유니버설 빌드에 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1135
msgid "Examples of returned values on Mac OS X:"
msgstr "Mac OS X에서 반환되는 값의 예:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1137
msgid "``macosx-10.3-ppc``"
msgstr "``macosx-10.3-ppc``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1139
msgid "``macosx-10.3-fat``"
msgstr "``macosx-10.3-fat``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1141
msgid "``macosx-10.5-universal``"
msgstr "``macosx-10.5-universal``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1143
msgid "``macosx-10.6-intel``"
msgstr "``macosx-10.6-intel``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1145
msgid ""
"For AIX, Python 3.9 and later return a string starting with \"aix\", "
"followed by additional fields (separated by ``'-'``) that represent the "
"combined values of AIX Version, Release and Technology Level (first "
"field), Build Date (second field), and bit-size (third field). Python 3.8"
" and earlier returned only a single additional field with the AIX Version"
" and Release."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1151
#, fuzzy
msgid "Examples of returned values on AIX:"
msgstr "반환된 값의 예:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1153
msgid "``aix-5307-0747-32`` # 32-bit build on AIX ``oslevel -s``: 5300-07-00-0000"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1155
msgid "``aix-7105-1731-64`` # 64-bit build on AIX ``oslevel -s``: 7100-05-01-1731"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1157
msgid "``aix-7.2``          # Legacy form reported in Python 3.8 and earlier"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1159
msgid ""
"The AIX platform string format now also includes the technology level, "
"build date, and ABI bit-size."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1166
msgid ""
"Return 'pathname' as a name that will work on the native filesystem, i.e."
" split it on '/' and put it back together again using the current "
"directory separator. Needed because filenames in the setup script are "
"always supplied in Unix style, and have to be converted to the local "
"convention before we can actually use them in the filesystem.  Raises "
":exc:`ValueError` on non-Unix-ish systems if *pathname* either  starts or"
" ends with a slash."
msgstr ""
"'pathname'을 네이티브 파일 시스템에서 작동할 이름으로 반환합니다, 즉 '/'로 분할하고 현재 디렉터리 구분자를 사용하여 "
"다시 합칩니다. 설정 스크립트의 파일명은 항상 유닉스 스타일로 제공되고, 파일 시스템에서 실제로 사용하기 전에 로컬 규칙으로 "
"변환해야 해서 필요합니다. *pathname*\\이 슬래시로 시작하거나 끝나면 유닉스가 아닌 시스템에서 "
":exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1176
msgid ""
"Return *pathname* with *new_root* prepended.  If *pathname* is relative, "
"this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it "
"requires making *pathname* relative and then joining the two, which is "
"tricky on DOS/Windows."
msgstr ""
"*new_root*\\가 앞에 추가된 *pathname*\\을 반환합니다. *pathname*\\이 상대적이면, "
"``os.path.join(new_root,pathname)``\\과 동등합니다. 그렇지 않으면, *pathname*\\을 "
"상대적으로 만든 다음 두 개를 결합해야 하는데, 이는 DOS/윈도우에서는 까다롭습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1183
msgid ""
"Ensure that 'os.environ' has all the environment variables we guarantee "
"that users can use in config files, command-line options, etc.  Currently"
" this includes:"
msgstr ""
"사용자가 구성 파일, 명령 줄 옵션 등에서 사용할 수 있도록 보장하는 모든 환경 변수가 'os.environ'에 있도록 합니다. "
"현재 여기에는 다음이 포함됩니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1187
msgid ":envvar:`HOME` - user's home directory (Unix only)"
msgstr ":envvar:`HOME` - 사용자의 홈 디렉터리 (유닉스 전용)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1188
msgid ""
":envvar:`PLAT` - description of the current platform, including hardware "
"and OS (see :func:`get_platform`)"
msgstr ""
":envvar:`PLAT` - 하드웨어와 OS를 포함한, 현재 플랫폼에 대한 설명 (:func:`get_platform`\\을 "
"참조하십시오)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1194
msgid ""
"Perform shell/Perl-style variable substitution on *s*.  Every occurrence "
"of ``$`` followed by a name is considered a variable, and variable is "
"substituted by the value found in the *local_vars* dictionary, or in "
"``os.environ`` if it's not in *local_vars*. *os.environ* is first "
"checked/augmented to guarantee that it contains certain values: see "
":func:`check_environ`.  Raise :exc:`ValueError` for any variables not "
"found in either *local_vars* or ``os.environ``."
msgstr ""
"*s*\\에서 셸/Perl 스타일 변수 치환을 수행합니다. ``$`` 다음에 이름이 오는 모든 항목은 변수로 간주하며, 변수는 "
"*local_vars* 딕셔너리에 있는 값으로 치환되거나, *local_vars*\\에 없으면 ``os.environ``\\에 있는"
" 값으로 치환됩니다. *os.environ*\\은 특정 값들이 포함되어 있도록 보장하기 위해 먼저 확인/보강됩니다: "
":func:`check_environ`\\을 참조하십시오. *local_vars*\\나 ``os.environ``\\에서 찾을 수 "
"없는 변수에 대해 :exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1201
msgid ""
"Note that this is not a fully-fledged string interpolation function. A "
"valid ``$variable`` can consist only of upper and lower case letters, "
"numbers and an underscore. No { } or ( ) style quoting is available."
msgstr ""
"이것은 완전한 문자열 보간 함수가 아님에 유의하십시오. 유효한 ``$variable``\\은 대문자와 소문자, 숫자와 밑줄로만 "
"구성될 수 있습니다. { } 또는 ( ) 스타일 인용을 사용할 수 없습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1208
msgid ""
"Split a string up according to Unix shell-like rules for quotes and "
"backslashes. In short: words are delimited by spaces, as long as those "
"spaces are not escaped by a backslash, or inside a quoted string. Single "
"and double quotes are equivalent, and the quote characters can be "
"backslash-escaped.  The backslash is stripped from any two-character "
"escape sequence, leaving only the escaped character.  The quote "
"characters are stripped from any quoted string.  Returns a list of words."
msgstr ""
"따옴표와 역 슬래시에 대한 유닉스 셸과 유사한 규칙에 따라 문자열을 분할합니다. 간단히 말해서: 단어는 스페이스가 역 슬래시로 "
"이스케이프 되거나 따옴표로 묶인 문자열 안에 있지 않은 한 스페이스로 구분됩니다. 작은따옴표와 큰따옴표는 동등하며, 따옴표 문자는 "
"역 슬래시 이스케이프 될 수 있습니다. 역 슬래시는 두 문자 이스케이프 시퀀스에서 제거되어, 이스케이프 된 문자만 남깁니다. 따옴표"
" 문자는 따옴표로 묶인 문자열에서 제거됩니다. 단어 리스트를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1221
msgid ""
"Perform some action that affects the outside world (for instance, writing"
" to the filesystem).  Such actions are special because they are disabled "
"by the *dry_run* flag.  This method takes  care of all that bureaucracy "
"for you; all you have to do is supply the function to call and an "
"argument tuple for it (to embody the \"external action\" being "
"performed), and an optional message to print."
msgstr ""
"외부 세계에 영향을 미치는 어떤 작업을 수행합니다 (예를 들어, 파일 시스템에 쓰기). 이러한 작업은 *dry_run* 플래그에 "
"의해 비활성화되기 때문에 특별합니다. 이 메서드는 당신을 위해 모든 관료적 절차를 관리합니다; 여러분은 호출할 함수와 이를 위한 "
"인자 튜플(수행되는 \"외부 작업\"을 내재하기 위해) 및 인쇄할 선택적 메시지를 제공하기만 하면 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1230
msgid "Convert a string representation of truth to true (1) or false (0)."
msgstr "논릿값의 문자열 표현을 true (1) 또는 false (0) 로 변환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1232
msgid ""
"True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false"
" values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises "
":exc:`ValueError` if *val*  is anything else."
msgstr ""
"참값은 ``y``, ``yes``, ``t``, ``true``, ``on`` 및 ``1``\\입니다; 거짓 값은 ``n``, "
"``no``, ``f``, ``false``, ``off`` 및 ``0``\\입니다. *val*\\이 다른 값이면 "
":exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1239
msgid ""
"Byte-compile a collection of Python source files to :file:`.pyc` files in"
" a :file:`__pycache__` subdirectory (see :pep:`3147` and :pep:`488`). "
"*py_files* is a list of files to compile; any files that don't end in "
":file:`.py` are silently skipped.  *optimize* must be one of the "
"following:"
msgstr ""
"파이썬 소스 파일 모음을 :file:`__pycache__` 하위 디렉터리의 :file:`.pyc` 파일로 바이트 컴파일합니다 "
"(:pep:`3147`\\과 :pep:`488`\\을 참조하십시오). *py_files*\\는 컴파일할 파일 리스트입니다; "
":file:`.py`\\로 끝나지 않는 모든 파일은 조용히 건너뜁니다. *optimize*\\는 다음 중 하나여야 합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1244
msgid "``0`` - don't optimize"
msgstr "``0`` - 최적화하지 않습니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1245
msgid "``1`` - normal optimization (like ``python -O``)"
msgstr "``1`` - 일반 최적화 (``python -O``\\처럼)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1246
msgid "``2`` - extra optimization (like ``python -OO``)"
msgstr "``2`` - 추가 최적화 (``python -OO``\\처럼)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1248
msgid "If *force* is true, all files are recompiled regardless of timestamps."
msgstr "*force*\\가 참이면, 타임 스탬프와 관계없이 모든 파일이 다시 컴파일됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1250
msgid ""
"The source filename encoded in each :term:`bytecode` file defaults to the"
" filenames listed in *py_files*; you can modify these with *prefix* and "
"*basedir*. *prefix* is a string that will be stripped off of each source "
"filename, and *base_dir* is a directory name that will be prepended "
"(after *prefix* is stripped).  You can supply either or both (or neither)"
" of *prefix* and *base_dir*, as you wish."
msgstr ""
"각 :term:`바이트 코드 <bytecode>` 파일에 인코딩된 소스 파일명은 기본적으로 *py_files*\\에 나열된 "
"파일명입니다; *prefix*\\와 *basedir*\\로 수정할 수 있습니다. *prefix*\\는 각 소스 파일명에서 제거되는 "
"문자열이고, *base_dir*\\은 (*prefix*\\가 제거된 후) 앞에 추가되는 디렉터리 이름입니다. 원하는 대로, "
"*prefix*\\와 *base_dir* 중 하나나 둘 다 제공 할 수 있습니다 (또는 아무것도 제공하지 않아도 됩니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1257
msgid ""
"If *dry_run* is true, doesn't actually do anything that would affect the "
"filesystem."
msgstr "*dry_run*\\이 참이면, 파일 시스템에 영향을 미치는 작업을 실제로 수행하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1260
msgid ""
"Byte-compilation is either done directly in this interpreter process with"
" the standard :mod:`py_compile` module, or indirectly by writing a "
"temporary script and executing it.  Normally, you should let "
":func:`byte_compile` figure out to use direct compilation or not (see the"
" source for details).  The *direct* flag is used by the script generated "
"in indirect mode; unless you know what you're doing, leave it set to "
"``None``."
msgstr ""
"바이트 컴파일은 표준 :mod:`py_compile` 모듈을 사용하여 이 인터프리터 프로세스에서 직접 수행되거나, 임시 스크립트를 "
"작성하고 실행하여 간접적으로 수행됩니다. 일반적으로, :func:`byte_compile`\\이 직접 컴파일을 사용할지를 파악하도록"
" 해야 합니다 (자세한 내용은 소스를 참조하십시오). *direct* 플래그는 간접 모드에서 생성된 스크립트에서 사용됩니다; 무엇을"
" 하고 있는지 모른다면, ``None``\\으로 그냥 두십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1267
msgid ""
"Create ``.pyc`` files with an :func:`import magic tag <imp.get_tag>` in "
"their name, in a :file:`__pycache__` subdirectory instead of files "
"without tag in the current directory."
msgstr ""
"현재 디렉터리에 태그가 없는 파일 대신 :file:`__pycache__` 하위 디렉터리에, 이름에 :func:`임포트 매직 태그 "
"<imp.get_tag>`\\가 있는 ``.pyc`` 파일을 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1272
msgid "Create ``.pyc`` files according to :pep:`488`."
msgstr ":pep:`488`\\에 따라 ``.pyc`` 파일을 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1278
msgid ""
"Return a version of *header* escaped for inclusion in an :rfc:`822` "
"header, by ensuring there are 8 spaces space after each newline. Note "
"that it does no other modification of the string."
msgstr ""
"각 줄 바꿈 뒤에 8개의 스페이스가 있도록 하여, :rfc:`822` 헤더에 포함하기 위한 이스케이프 된 *header* 버전을 "
"반환합니다. 문자열의 다른 수정은 하지 않음에 유의하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1288
msgid ":mod:`distutils.dist` --- The Distribution class"
msgstr ":mod:`distutils.dist` --- Distribution 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1295
msgid ""
"This module provides the :class:`~distutils.core.Distribution` class, "
"which represents the module distribution being "
"built/installed/distributed."
msgstr ""
"이 모듈은 빌드/설치/배포 중인 모듈 배포를 나타내는 :class:`~distutils.core.Distribution` 클래스를 "
"제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1300
msgid ":mod:`distutils.extension` --- The Extension class"
msgstr ":mod:`distutils.extension` --- Extension 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1307
msgid ""
"This module provides the :class:`Extension` class, used to describe C/C++"
" extension modules in setup scripts."
msgstr "이 모듈은 설정 스크립트에서 C/C++ 확장 모듈을 기술하는 데 사용되는 :class:`Extension` 클래스를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1315
msgid ":mod:`distutils.debug` --- Distutils debug mode"
msgstr ":mod:`distutils.debug` --- Distutils 디버그 모드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1321
msgid "This module provides the DEBUG flag."
msgstr "이 모듈은 DEBUG 플래그를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1325
msgid ":mod:`distutils.errors` --- Distutils exceptions"
msgstr ":mod:`distutils.errors` --- Distutils 예외"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1331
msgid ""
"Provides exceptions used by the Distutils modules.  Note that Distutils "
"modules may raise standard exceptions; in particular, SystemExit is "
"usually raised for errors that are obviously the end-user's fault (eg. "
"bad command-line arguments)."
msgstr ""
"Distutils 모듈에서 사용하는 예외를 제공합니다. Distutils 모듈은 표준 예외를 발생시킬 수 있음에 유의하십시오; 특히"
" 명백히 최종 사용자의 잘못인 에러(예를 들어 잘못된 명령 줄 인자)에 대해 일반적으로 SystemExit가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1335
msgid ""
"This module is safe to use in ``from ... import *`` mode; it only exports"
" symbols whose names start with ``Distutils`` and end with ``Error``."
msgstr ""
"이 모듈은 ``from ... import *`` 모드에서 사용하기에 안전합니다; 이름이 ``Distutils``\\로 시작하고 "
"``Error``\\로 끝나는 심볼만 내보냅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1340
msgid ""
":mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt "
"module"
msgstr ":mod:`distutils.fancy_getopt` --- 표준 getopt 모듈을 감싸는 래퍼"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1346
msgid ""
"This module provides a wrapper around the standard :mod:`getopt`  module "
"that provides the following additional features:"
msgstr "이 모듈은 다음과 같은 추가 기능을 제공하는 표준 :mod:`getopt` 모듈에 대한 래퍼를 제공합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1349
msgid "short and long options are tied together"
msgstr "짧고 긴 옵션이 함께 묶입니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1351
msgid ""
"options have help strings, so :func:`fancy_getopt` could potentially  "
"create a complete usage summary"
msgstr "옵션에는 도움말 문자열이 있어서, :func:`fancy_getopt`\\는 잠재적으로 완전한 사용법 요약을 만들 수 있습니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1354
msgid "options set attributes of a passed-in object"
msgstr "옵션은 전달된 객체의 어트리뷰트를 설정합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1356
msgid ""
"boolean options can have \"negative aliases\" --- eg. if :option:`!--"
"quiet` is the \"negative alias\" of :option:`!--verbose`, then :option:`!"
"--quiet` on the command line sets *verbose* to false."
msgstr ""
"불리언 옵션은 \"부의 별칭\"을 가질 수 있습니다 --- 예를 들어 :option:`!--quiet`\\가 :option:`!--"
"verbose`\\의 \"부의 별칭\"이면, 명령 줄의 :option:`!--quiet`\\는 *verbose*\\를 거짓으로 "
"설정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1362
msgid ""
"Wrapper function. *options* is a list of ``(long_option, short_option, "
"help_string)`` 3-tuples as described in the constructor for "
":class:`FancyGetopt`. *negative_opt* should be a dictionary mapping "
"option names to option names, both the key and value should be in the "
"*options* list. *object* is an object which will be used to store values "
"(see the :meth:`getopt` method of the :class:`FancyGetopt` class). *args*"
" is the argument list. Will use ``sys.argv[1:]`` if you  pass ``None`` as"
" *args*."
msgstr ""
"래퍼 함수. *options*\\는 :class:`FancyGetopt`\\의 생성자에 설명된 대로 ``(long_option, "
"short_option, help_string)`` 3-튜플의 리스트입니다. *negative_opt*\\는 옵션 이름을 옵션 "
"이름에 매핑하는 딕셔너리이어야 하며, 키와 값은 모두 *options* 리스트에 있어야 합니다. *object*\\는 값을 저장하는"
" 데 사용되는 객체입니다 (:class:`FancyGetopt` 클래스의 :meth:`getopt` 메서드를 참조하십시오). "
"*args*\\는 인자 리스트입니다. ``None``\\을 *args*\\로 전달하면 ``sys.argv[1:]``\\을 "
"사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1373
msgid "Wraps *text* to less than *width* wide."
msgstr "*text*\\를 *width* 너비 미만으로 래핑합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1378
msgid ""
"The option_table is a list of 3-tuples: ``(long_option, short_option, "
"help_string)``"
msgstr "option_table은 3-튜플 리스트입니다: ``(long_option, short_option, help_string)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1381
msgid ""
"If an option takes an argument, its *long_option* should have ``'='`` "
"appended; *short_option* should just be a single character, no ``':'`` in"
" any case. *short_option* should be ``None`` if a *long_option*  doesn't "
"have a corresponding *short_option*. All option tuples must have long "
"options."
msgstr ""
"옵션이 인자를 취하면, *long_option*\\에 ``'='``\\가 추가되어야 합니다; *short_option*\\은 단일 "
"문자여야 하며, 어떤 경우에도 ``':'``\\이 아니어야 합니다. *long_option*\\에 대응하는 "
"*short_option*\\이 없으면 *short_option*\\은 ``None``\\이어야 합니다. 모든 옵션 튜플에는 긴 "
"옵션이 있어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1386
msgid "The :class:`FancyGetopt` class provides the following methods:"
msgstr ":class:`FancyGetopt` 클래스는 다음 메서드를 제공합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1391
msgid "Parse command-line options in args. Store as attributes on *object*."
msgstr "args에서 명령 줄 옵션을 구문 분석합니다. *object*\\에 어트리뷰트로 저장합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1393
msgid ""
"If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If "
"*object* is ``None`` or not supplied, creates a new :class:`OptionDummy` "
"instance, stores option values there, and returns a tuple ``(args, "
"object)``.  If *object* is supplied, it is modified in place and "
":func:`getopt` just returns *args*; in both cases, the returned *args* is"
" a modified copy of the passed-in *args* list, which is left untouched."
msgstr ""
"*args*\\가 ``None``\\이거나 제공되지 않으면, ``sys.argv[1:]``\\을 사용합니다. *object*\\가 "
"``None``\\이거나 제공되지 않으면, 새 :class:`OptionDummy` 인스턴스를 만들고, 여기에 옵션값을 저장하고, "
"튜플 ``(args, object)``\\를 반환합니다. *object*\\가 제공되면, 제자리에서 수정되고 "
":func:`getopt`\\는 *args* 만 반환합니다; 두 경우 모두, 반환된 *args*\\는 전달된 *args* 리스트의 "
"수정된 복사본이며, 전달된 *args*\\는 그대로 유지됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1405
msgid ""
"Returns the list of ``(option, value)`` tuples processed by the previous "
"run of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` "
"hasn't been called yet."
msgstr ""
":meth:`getopt`\\의 이전 실행에서 처리한 ``(option, value)`` 튜플 리스트를 반환합니다. "
":meth:`getopt`\\가 아직 호출되지 않았으면 :exc:`RuntimeError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1412
msgid ""
"Generate help text (a list of strings, one per suggested line of output) "
"from the option table for this :class:`FancyGetopt` object."
msgstr ""
"이 :class:`FancyGetopt` 객체에 대한 옵션 테이블에서 도움말 텍스트(문자열 리스트, 제안된 출력 줄 당 하나씩)를 "
"생성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1415
msgid "If supplied, prints the supplied *header* at the top of the help."
msgstr "제공되면, 도움말 맨 위에 제공된 *header*\\를 인쇄합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1419
msgid ":mod:`distutils.filelist` --- The FileList class"
msgstr ":mod:`distutils.filelist` --- FileList 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1426
msgid ""
"This module provides the :class:`FileList` class, used for poking about "
"the filesystem and building lists of files."
msgstr ""
"이 모듈은 :class:`FileList` 클래스를 제공하며, 파일 시스템에 대한 정보를 확인하고 파일 리스트를 구축하는 데 "
"사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1431
msgid ":mod:`distutils.log` --- Simple :pep:`282`-style logging"
msgstr ":mod:`distutils.log` --- 간단한 :pep:`282` 스타일 로깅"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1438
msgid ":mod:`distutils.spawn` --- Spawn a sub-process"
msgstr ":mod:`distutils.spawn` --- 서브 프로세스 스폰"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1444
msgid ""
"This module provides the :func:`spawn` function, a front-end to  various "
"platform-specific functions for launching another program in a  sub-"
"process. Also provides :func:`find_executable` to search the path for a "
"given executable name."
msgstr ""
"이 모듈은 서브 프로세스에서 다른 프로그램을 시작하기 위한 다양한 플랫폼별 함수의 프런트엔드인 :func:`spawn` 함수를 "
"제공합니다. 또한 주어진 실행 파일 이름을 경로에서 검색하는 :func:`find_executable`\\을 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1451
msgid ":mod:`distutils.sysconfig` --- System configuration information"
msgstr ":mod:`distutils.sysconfig` --- 시스템 구성 정보"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1460
msgid ""
"The :mod:`distutils.sysconfig` module provides access to Python's low-"
"level configuration information.  The specific configuration variables "
"available depend heavily on the platform and configuration. The specific "
"variables depend on the build process for the specific version of Python "
"being run; the variables are those found in the :file:`Makefile` and "
"configuration header that are installed with Python on Unix systems.  The"
" configuration header is called :file:`pyconfig.h` for Python versions "
"starting with 2.2, and :file:`config.h` for earlier versions of Python."
msgstr ""
":mod:`distutils.sysconfig` 모듈은 파이썬의 저수준 구성 정보에 대한 액세스를 제공합니다. 사용 가능한 특정 "
"구성 변수는 플랫폼과 구성에 따라 크게 달라집니다. 특정 변수는 실행 중인 파이썬의 특정 버전에 대한 빌드 프로세스에 따라 "
"다릅니다; 변수는 유닉스 시스템에서 파이썬과 함께 설치되는 :file:`Makefile`\\과 구성 헤더에 있는 변수입니다. 구성 "
"헤더는 파이썬 버전 2.2부터 :file:`pyconfig.h`\\이고, 이전 버전의 파이썬에서는 "
":file:`config.h`\\입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1469
msgid ""
"Some additional functions are provided which perform some useful "
"manipulations for other parts of the :mod:`distutils` package."
msgstr ":mod:`distutils` 패키지의 다른 부분에 대해 유용한 조작을 수행하는 몇 가지 추가 함수가 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1475
msgid "The result of ``os.path.normpath(sys.prefix)``."
msgstr "``os.path.normpath(sys.prefix)``\\의 결과."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1480
msgid "The result of ``os.path.normpath(sys.exec_prefix)``."
msgstr "``os.path.normpath(sys.exec_prefix)``\\의 결과."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1485
msgid ""
"Return the value of a single variable.  This is equivalent to "
"``get_config_vars().get(name)``."
msgstr "단일 변수의 값을 반환합니다. 이것은 ``get_config_vars().get(name)``\\과 동등합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1491
msgid ""
"Return a set of variable definitions.  If there are no arguments, this "
"returns a dictionary mapping names of configuration variables to values."
"  If arguments are provided, they should be strings, and the return value"
" will be a sequence giving the associated values. If a given name does "
"not have a corresponding value, ``None`` will be included for that "
"variable."
msgstr ""
"변수 정의 집합을 반환합니다. 인자가 없으면, 구성 변수의 이름을 값에 매핑하는 딕셔너리를 반환합니다. 인자가 제공되면, 해당 "
"인자는 문자열이어야 하며, 반환 값은 관련 값을 제공하는 시퀀스가 됩니다. 주어진 이름에 해당 값이 없으면, 해당 변수에 "
"``None``\\이 포함됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1500
msgid ""
"Return the full path name of the configuration header.  For Unix, this "
"will be the header generated by the :program:`configure` script; for "
"other platforms the header will have been supplied directly by the Python"
" source distribution.  The file is a platform-specific text file."
msgstr ""
"구성 헤더의 전체 경로 이름을 반환합니다. 유닉스의 경우, 이것은 :program:`configure` 스크립트에 의해 생성된 "
"헤더입니다; 다른 플랫폼의 경우 헤더는 파이썬 소스 배포에서 직접 제공됩니다. 이 파일은 플랫폼별 텍스트 파일입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1508
msgid ""
"Return the full path name of the :file:`Makefile` used to build Python.  "
"For Unix, this will be a file generated by the :program:`configure` "
"script; the meaning for other platforms will vary.  The file is a "
"platform-specific text file, if it exists. This function is only useful "
"on POSIX platforms."
msgstr ""
"파이썬을 빌드하는 데 사용된 :file:`Makefile`\\의 전체 경로 이름을 반환합니다. 유닉스의 경우, 이것은 "
":program:`configure` 스크립트에 의해 생성된 파일입니다; 다른 플랫폼의 경우 의미는 다양합니다. 존재한다면, 이 "
"파일은 플랫폼별 텍스트 파일입니다. 이 함수는 POSIX 플랫폼에서만 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1516
msgid ""
"Return the directory for either the general or platform-dependent C "
"include files.  If *plat_specific* is true, the platform-dependent "
"include directory is returned; if false or omitted, the platform-"
"independent directory is returned. If *prefix* is given, it is used as "
"either the prefix instead of :const:`PREFIX`, or as the exec-prefix "
"instead of :const:`EXEC_PREFIX` if *plat_specific* is true."
msgstr ""
"일반이나 플랫폼 종속 C 인클루드 파일에 대한 디렉터리를 반환합니다. *plat_specific*\\이 참이면, 플랫폼 종속 "
"인클루드 디렉터리가 반환됩니다; 거짓이거나 생략되면, 플랫폼 독립적인 디렉터리가 반환됩니다. *prefix*\\가 주어지면, "
":const:`PREFIX` 대신 prefix로 사용되거나, *plat_specific*\\이 참이면 "
":const:`EXEC_PREFIX` 대신 exec-prefix로 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1526
msgid ""
"Return the directory for either the general or platform-dependent library"
" installation.  If *plat_specific* is true, the platform-dependent "
"include directory is returned; if false or omitted, the platform-"
"independent directory is returned.  If *prefix* is given, it is used as "
"either the prefix instead of :const:`PREFIX`, or as the exec-prefix "
"instead of :const:`EXEC_PREFIX` if *plat_specific* is true.  If "
"*standard_lib* is true, the directory for the standard library is "
"returned rather than the directory for the installation of third-party "
"extensions."
msgstr ""
"일반이나 플랫폼 종속 라이브러리 설치를 위한 디렉터리를 반환합니다. *plat_specific*\\이 참이면, 플랫폼 종속 "
"라이브러리 디렉터리가 반환됩니다; 거짓이거나 생략되면, 플랫폼 독립적인 디렉터리가 반환됩니다. *prefix*\\가 주어지면, "
":const:`PREFIX` 대신 prefix로 사용되거나, *plat_specific*\\이 참이면 "
":const:`EXEC_PREFIX` 대신 exec-prefix로 사용됩니다. *standard_lib*\\가 참이면, 제삼자 "
"확장을 설치하기 위한 디렉터리가 아니라 표준 라이브러리의 디렉터리가 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1535
msgid ""
"The following function is only intended for use within the "
":mod:`distutils` package."
msgstr "다음 함수는 :mod:`distutils` 패키지 내에서만 사용하려는 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1541
msgid ""
"Do any platform-specific customization of a "
":class:`distutils.ccompiler.CCompiler` instance."
msgstr ":class:`distutils.ccompiler.CCompiler` 인스턴스의 모든 플랫폼별 사용자 정의를 수행합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1544
msgid ""
"This function is only needed on Unix at this time, but should be called "
"consistently to support forward-compatibility.  It inserts the "
"information that varies across Unix flavors and is stored in Python's "
":file:`Makefile`.  This information includes the selected compiler, "
"compiler and linker options, and the extension used by the linker for "
"shared objects."
msgstr ""
"이 함수는 현재 유닉스에서만 필요하지만, 미래 호환성을 지원하기 위해 일관되게 호출되어야 합니다. 유닉스 버전에 따라 다른 정보를 "
"삽입하고 파이썬의 :file:`Makefile`\\에 저장됩니다. 이 정보에는 선택한 컴파일러, 컴파일러와 링커 옵션, 링커에서 "
"공유 객체에 사용하는 확장이 포함됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1550
msgid ""
"This function is even more special-purpose, and should only be used from "
"Python's own build procedures."
msgstr "이 함수는 훨씬 더 특수한 용도이며, 파이썬 자체 빌드 절차에서만 사용해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1556
msgid ""
"Inform the :mod:`distutils.sysconfig` module that it is being used as "
"part of the build process for Python.  This changes a lot of relative "
"locations for files, allowing them to be located in the build area rather"
" than in an installed Python."
msgstr ""
"파이썬을 위한 빌드 프로세스의 일부로 사용되고 있음을 :mod:`distutils.sysconfig` 모듈에 알립니다. 이렇게 하면"
" 파일의 상대적 위치가 많이 변경되어, 설치된 파이썬이 아닌 빌드 영역에 위치 할 수 있도록 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1563
msgid ":mod:`distutils.text_file` --- The TextFile class"
msgstr ":mod:`distutils.text_file` --- TextFile 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1569
msgid ""
"This module provides the :class:`TextFile` class, which gives an "
"interface  to text files that (optionally) takes care of stripping "
"comments, ignoring  blank lines, and joining lines with backslashes."
msgstr ""
"이 모듈은 :class:`TextFile` 클래스를 제공합니다. 이 클래스는 (선택적으로) 주석 제거, 빈 줄 무시 및 역 슬래시 "
"된 줄의 결합을 처리하는 텍스트 파일에 대한 인터페이스를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1576
msgid ""
"This class provides a file-like object that takes care of all  the things"
" you commonly want to do when processing a text file  that has some line-"
"by-line syntax: strip comments (as long as ``#``  is your comment "
"character), skip blank lines, join adjacent lines by escaping the newline"
" (ie. backslash at end of line), strip leading and/or trailing "
"whitespace.  All of these are optional and independently controllable."
msgstr ""
"이 클래스는 줄 단위 문법을 갖는 텍스트 파일을 처리할 때 일반적으로 수행하려는 모든 작업을 처리하는 파일류 객체를 제공합니다: "
"주석 제거 (``#``\\가 주석 문자라면), 빈 줄 무시, 줄 바꿈을 이스케이프 한 인접 줄을 연결하기 (즉, 줄 끝의 역 "
"슬래시), 선행 및/또는 후행 공백 제거. 이들 모두는 선택적이고 독립적으로 제어할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1583
msgid ""
"The class provides a :meth:`warn` method so you can generate  warning "
"messages that report physical line number, even if the  logical line in "
"question spans multiple physical lines.  Also  provides "
":meth:`unreadline` for implementing line-at-a-time lookahead."
msgstr ""
"이 클래스는 :meth:`warn` 메서드를 제공해서 문제의 논리적 줄이 여러 물리적 줄에 걸쳐있는 경우에도 물리적 줄 번호를 "
"보고하는 경고 메시지를 생성할 수 있습니다. 또한 한 번에 한 줄씩 미리 보기를 구현하기 위한 "
":meth:`unreadline`\\을 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1588
msgid ""
":class:`TextFile` instances are create with either *filename*, *file*, or"
" both. :exc:`RuntimeError` is raised if both are ``None``. *filename* "
"should be a string, and *file* a file object (or something that provides "
":meth:`readline` and :meth:`close`  methods).  It is recommended that you"
" supply at least *filename*,  so that :class:`TextFile` can include it in"
" warning messages.  If *file* is not supplied, :class:`TextFile` creates "
"its own using the :func:`open` built-in function."
msgstr ""
":class:`TextFile` 인스턴스는 *filename*, *file* 또는 둘 모두로 만들어집니다. 둘 다 "
"``None``\\이면 :exc:`RuntimeError`\\가 발생합니다. *filename*\\은 문자열이어야 하며, "
"*file*\\은 파일 객체(또는 :meth:`readline`\\과 :meth:`close` 메서드를 제공하는 것)여야 합니다. "
":class:`TextFile`\\이 경고 메시지에 포함할 수 있도록, 최소한 *filename*\\을 제공하는 것이 좋습니다. "
"*file*\\이 제공되지 않으면, :class:`TextFile`\\은 :func:`open` 내장 함수를 사용하여 스스로 "
"만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1596
msgid ""
"The options are all boolean, and affect the values returned by "
":meth:`readline`"
msgstr "옵션은 모두 불리언이며, :meth:`readline`\\이 반환하는 값에 영향을 줍니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1601
msgid "option name"
msgstr "옵션 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1601
msgid "default"
msgstr "기본값"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1603
msgid "*strip_comments*"
msgstr "*strip_comments*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1603
msgid ""
"strip from ``'#'`` to end-of-line, as well as any whitespace leading up "
"to the ``'#'``\\ ---unless it is escaped by a backslash"
msgstr ""
"``'#'``\\에서 줄 끝까지 제거할 뿐만 아니라, ``'#'`` 앞까지 이어지는 모든 공백을 제거합니다 --- 역 슬래시로 "
"이스케이프 되지 않는 한"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1603
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1612
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1617
msgid "true"
msgstr "참"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1609
msgid "*lstrip_ws*"
msgstr "*lstrip_ws*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1609
msgid "strip leading whitespace from each line before returning it"
msgstr "반환하기 전에 각 줄에서 선행 공백을 제거합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1609
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1627
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1638
msgid "false"
msgstr "거짓"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1612
msgid "*rstrip_ws*"
msgstr "*rstrip_ws*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1612
msgid ""
"strip trailing whitespace (including line terminator!) from each line "
"before returning it."
msgstr "반환하기 전에 각 줄에서 후행 공백(줄 종결자 포함!)을 제거합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1617
msgid "*skip_blanks*"
msgstr "*skip_blanks*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1617
msgid ""
"skip lines that are empty \\*after\\* stripping comments and whitespace."
"  (If both lstrip_ws and rstrip_ws are false, then some lines may consist"
" of solely whitespace: these will \\*not\\* be skipped, even if "
"*skip_blanks* is true.)"
msgstr ""
"주석과 공백을 제거한 \\*후에\\* 빈 줄을 건너뜁니다. (lstrip_ws와 rstrip_ws가 모두 거짓이면, 일부 행은 "
"공백으로만 구성될 수 있습니다: 이것은 *skip_blanks*\\가 참인 경우에도 건너뛰지 \\*않습니다\\*.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1627
msgid "*join_lines*"
msgstr "*join_lines*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1627
msgid ""
"if a backslash is the last non-newline character on a line after "
"stripping comments and whitespace, join the following line to it to form "
"one logical line; if N consecutive lines end with a backslash, then N+1 "
"physical lines will be joined to form one logical line."
msgstr ""
"주석과 공백을 제거한 후 역 슬래시가 줄 넘김이 아닌 줄의 마지막 문자이면, 다음 줄을 결합하여 하나의 논리적 줄을 만듭니다; "
"N개의 연속된 줄이 역 슬래시로 끝나면, N+1개의 물리적 줄이 결합하여 하나의 논리적 줄을 형성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1638
msgid "*collapse_join*"
msgstr "*collapse_join*"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1638
msgid ""
"strip leading whitespace from lines that are joined to their predecessor;"
" only matters if ``(join_lines and not lstrip_ws)``"
msgstr "앞줄에 연결된 줄에서 선행 공백을 제거합니다; ``(join_lines and not lstrip_ws)``\\일 때만 중요합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1645
msgid ""
"Note that since *rstrip_ws* can strip the trailing newline, the semantics"
" of :meth:`readline` must differ from those of the built-in file object's"
" :meth:`readline` method!  In particular, :meth:`readline`  returns "
"``None`` for end-of-file: an empty string might just be a  blank line (or"
" an all-whitespace line), if *rstrip_ws* is true  but *skip_blanks* is "
"not."
msgstr ""
"*rstrip_ws*\\는 후행 줄 바꿈을 제거할 수 있어서, :meth:`readline`\\의 의미는 내장 파일 객체의 "
":meth:`readline` 메서드와 달라야 함에 유의하십시오! 특히, :meth:`readline`\\은 파일 끝에 대해 "
"``None``\\을 반환합니다: *rstrip_ws*\\가 참이지만 *skip_blanks*\\가 거짓이면, 빈 문자열은 단지 빈"
" 줄(또는 모두 공백인 줄)일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1654
msgid ""
"Open a new file *filename*.  This overrides any *file* or *filename* "
"constructor arguments."
msgstr "새 파일 *filename*\\을 엽니다. 이것은 *file*\\이나 *filename* 생성자 인자를 재정의합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1660
msgid ""
"Close the current file and forget everything we know about it (including "
"the filename and the current line number)."
msgstr "현재 파일을 닫고 (파일명과 현재 줄 번호를 포함하여) 그것에 대해 알고 있는 모든 것을 잊어버립니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1666
msgid ""
"Print (to stderr) a warning message tied to the current logical line in "
"the current file.  If the current logical line in the file spans multiple"
" physical lines, the warning refers to the whole range, such as ``\"lines"
" 3-5\"``.  If *line* is supplied,  it overrides the current line number; "
"it may be a list or tuple  to indicate a range of physical lines, or an "
"integer for a  single physical line."
msgstr ""
"현재 파일의 현재 논리적 줄에 연결된 경고 메시지를 (stderr로) 인쇄합니다. 파일의 현재 논리적 줄이 여러 물리적 줄에 "
"걸쳐있으면, 경고는 전체 범위를 나타냅니다, 가령 ``\"lines 3-5\"``. *line*\\이 제공되면, 현재 줄 번호를 "
"대체합니다; 물리적 줄의 범위를 나타내는 리스트나 튜플이거나, 단일 물리적 줄을 나타내는 정수일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1676
msgid ""
"Read and return a single logical line from the current file (or from an "
"internal buffer if lines have previously been \"unread\" with "
":meth:`unreadline`).  If the *join_lines* option  is true, this may "
"involve reading multiple physical lines concatenated into a single "
"string.  Updates the current line number,  so calling :meth:`warn` after "
":meth:`readline` emits a warning  about the physical line(s) just read.  "
"Returns ``None`` on end-of-file,  since the empty string can occur if "
"*rstrip_ws* is true but  *strip_blanks* is not."
msgstr ""
"현재 파일에서 단일 논리적 줄을 읽고 반환합니다 (또는 줄이 이전에 :meth:`unreadline`\\으로 \"되돌린\" 경우 "
"내부 버퍼에서). *join_lines* 옵션이 참이면, 여러 물리적 줄을 단일 문자열로 이어붙인 줄을 읽는 것이 수반될 수 "
"있습니다. 현재 줄 번호를 갱신해서, :meth:`readline` 후에 :meth:`warn`\\을 호출하면 방금 읽은 물리적 "
"줄에 대한 경고가 표시됩니다. *rstrip_ws*\\가 참이지만 *strip_blanks*\\가 거짓이면 빈 문자열이 발생할 수 "
"있어서, 파일 끝에서는 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1687
msgid ""
"Read and return the list of all logical lines remaining in the current "
"file. This updates the current line number to the last line of the file."
msgstr "현재 파일에 남아있는 모든 논리적 줄의 리스트를 읽고 반환합니다. 이렇게 하면 현재 줄 번호가 파일의 마지막 줄로 갱신됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1693
msgid ""
"Push *line* (a string) onto an internal buffer that will be checked by "
"future :meth:`readline` calls.  Handy for implementing a parser with "
"line-at-a-time lookahead. Note that lines that are \"unread\" with "
":meth:`unreadline` are not subsequently re-cleansed (whitespace  "
"stripped, or whatever) when read with :meth:`readline`. If multiple calls"
" are made to :meth:`unreadline` before a call to :meth:`readline`, the "
"lines will be returned most in most recent first order."
msgstr ""
"*line*\\(문자열)을 향후 :meth:`readline` 호출에서 확인할 내부 버퍼로 푸시합니다. 한 번에 한 줄씩 미리 "
"보기가 있는 구문 분석기를 구현하는 데 편리합니다. :meth:`unreadline`\\으로 \"되돌린\" 줄은 "
":meth:`readline`\\으로 읽을 때 이후에 다시 정리(공백 제거 등)되지 않음에 유의하십시오. "
":meth:`readline`\\을 호출하기 전에 :meth:`unreadline`\\을 여러 번 호출하면, 가장 최근의 것이 첫 "
"번째로 오는 순서로 줄이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1702
msgid ":mod:`distutils.version` --- Version number classes"
msgstr ":mod:`distutils.version` --- 버전 번호 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1717
msgid ":mod:`distutils.cmd` --- Abstract base class for Distutils commands"
msgstr ":mod:`distutils.cmd` --- Distutils 명령을 위한 추상 베이스 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1724
msgid "This module supplies the abstract base class :class:`Command`."
msgstr "이 모듈은 추상 베이스 클래스 :class:`Command`\\를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1729
msgid ""
"Abstract base class for defining command classes, the \"worker bees\" of "
"the Distutils.  A useful analogy for command classes is to think of them "
"as subroutines with local variables called *options*.  The options are "
"declared in :meth:`initialize_options` and defined (given their final "
"values) in :meth:`finalize_options`, both of which must be defined by "
"every command class.  The distinction between the two is necessary "
"because option values might come from the outside world (command line, "
"config file, ...), and any options dependent on other options must be "
"computed after these outside influences have been processed --- hence "
":meth:`finalize_options`.  The body of the subroutine, where it does all "
"its work based on the values of its options, is the :meth:`run` method, "
"which must also be implemented by every command class."
msgstr ""
"Distutils의 \"일벌\"인 명령 클래스를 정의하기 위한 추상 베이스 클래스. 명령 클래스에 대한 유용한 비유는 "
"*options*\\라는 로컬 변수가 있는 서브 루틴으로 생각하는 것입니다. 옵션은 "
":meth:`initialize_options`\\에서 선언되고 :meth:`finalize_options`\\에서 정의됩니다 "
"(최종값 제공). 두 메서드 모두 모든 명령 클래스에서 정의해야 합니다. 옵션값은 외부 세계(명령 줄, 구성 파일, ...)에서 올"
" 수 있고, 다른 옵션에 종속된 모든 옵션은 이러한 외부 영향이 처리된 후에 계산되어야 해서 --- 그래서 "
":meth:`finalize_options`, 둘 사이의 구분이 필요합니다. 옵션값을 기반으로 모든 작업을 수행하는 서브 루틴의 "
"본문은 :meth:`run` 메서드이며, 역시 모든 명령 클래스에서 구현해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1742
msgid ""
"The class constructor takes a single argument *dist*, a "
":class:`~distutils.core.Distribution` instance."
msgstr "클래스 생성자는 :class:`~distutils.core.Distribution` 인스턴스인 단일 인자 *dist*\\를 취합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1747
msgid "Creating a new Distutils command"
msgstr "새 Distutils 명령 만들기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1749
msgid "This section outlines the steps to create a new Distutils command."
msgstr "이 섹션에서는 새 Distutils 명령을 만드는 단계를 간략하게 설명합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1751
msgid ""
"A new command lives in a module in the :mod:`distutils.command` package. "
"There is a sample template in that directory called "
":file:`command_template`.  Copy this file to a new module with the same "
"name as the new command you're implementing.  This module should "
"implement a class with the same name as the module (and the command).  "
"So, for instance, to create the command ``peel_banana`` (so that users "
"can run ``setup.py peel_banana``), you'd copy :file:`command_template` to"
" :file:`distutils/command/peel_banana.py`, then edit it so that it's "
"implementing the class :class:`peel_banana`, a subclass of "
":class:`distutils.cmd.Command`."
msgstr ""
"새로운 명령은 :mod:`distutils.command` 패키지의 모듈에 있습니다. 해당 디렉터리에 "
":file:`command_template`\\라는 샘플 템플릿이 있습니다. 구현 중인 새 명령과 이름이 같은 새 모듈에 이 파일을"
" 복사하십시오. 이 모듈은 모듈(및 명령)과 같은 이름의 클래스를 구현해야 합니다. 예를 들어, ``peel_banana`` 명령을"
" 만들려면 (사용자가 ``setup.py peel_banana``\\를 실행할 수 있도록), "
":file:`command_template`\\를 :file:`distutils/command/peel_banana.py`\\에 "
"복사한 다음, :class:`distutils.cmd.Command`\\의 서브 클래스인 :class:`peel_banana` "
"클래스를 구현하도록 편집합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1761
msgid "Subclasses of :class:`Command` must define the following methods."
msgstr ":class:`Command`\\의 서브 클래스는 다음 메서드를 정의해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1765
msgid ""
"Set default values for all the options that this command supports.  Note "
"that these defaults may be overridden by other commands, by the setup "
"script, by config files, or by the command-line.  Thus, this is not the "
"place to code dependencies between options; generally, "
":meth:`initialize_options` implementations are just a bunch of ``self.foo"
" = None`` assignments."
msgstr ""
"이 명령이 지원하는 모든 옵션의 기본값을 설정합니다. 이러한 기본값은 다른 명령, 설정 스크립트, 구성 파일 또는 명령 줄에 의해 "
"재정의될 수 있습니다. 따라서, 이것은 옵션 간의 종속성을 코딩하는 곳이 아닙니다; 일반적으로 "
":meth:`initialize_options` 구현은 한 무더기의 ``self.foo = None`` 대입일 뿐입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1774
msgid ""
"Set final values for all the options that this command supports. This is "
"always called as late as possible, ie.  after any option assignments from"
" the command-line or from other commands have been done.  Thus, this is "
"the place to code option dependencies: if *foo* depends on *bar*, then it"
" is safe to set *foo* from *bar* as long as *foo* still has the same "
"value it was assigned in :meth:`initialize_options`."
msgstr ""
"이 명령이 지원하는 모든 옵션에 대한 최종값을 설정합니다. 이것은 항상 가능한 한 늦게 호출됩니다, 즉, 명령 줄이나 다른 명령에서"
" 모든 옵션 대입이 완료된 후에. 따라서, 이것이 옵션 종속성을 코딩하는 장소입니다: *foo*\\가 *bar*\\에 의존하면, "
"*foo*\\가 :meth:`initialize_options`\\에서 대입된 것과 같은 값을 여전히 가지고 있는 한 "
"*foo*\\를 *bar*\\에서 설정하는 것이 안전합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1784
msgid ""
"A command's raison d'etre: carry out the action it exists to perform, "
"controlled by the options initialized in :meth:`initialize_options`, "
"customized by other commands, the setup script, the command-line, and "
"config files, and finalized in :meth:`finalize_options`.  All terminal "
"output and filesystem interaction should be done by :meth:`run`."
msgstr ""
"명령의 존재 이유: 수행하기 위해 존재하는 작업을 수행하고, :meth:`initialize_options`\\에서 초기화되고, "
"다른 명령, 설정 스크립트, 명령 줄 및 구성 파일로 사용자 정의되고, :meth:`finalize_options`\\에서 마무리된"
" 옵션으로 제어됩니다. 모든 터미널 출력과 파일 시스템 상호 작용은 :meth:`run`\\에서 수행해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1793
msgid ""
"*sub_commands* formalizes the notion of a \"family\" of commands, e.g. "
"``install`` as the parent with sub-commands ``install_lib``, "
"``install_headers``, etc.  The parent of a family of commands defines "
"*sub_commands* as a class attribute; it's a list of 2-tuples "
"``(command_name, predicate)``, with *command_name* a string and "
"*predicate* a function, a string or ``None``.  *predicate* is a method of"
" the parent command that determines whether the corresponding command is "
"applicable in the current situation.  (E.g. ``install_headers`` is only "
"applicable if we have any C header files to install.)  If *predicate* is "
"``None``, that command is always applicable."
msgstr ""
"*sub_commands*\\는 명령의 \"패밀리\" 개념을 형식화합니다, 예를 들어, 하위 명령 ``install_lib``, "
"``install_headers`` 등이 있는 부모로서의 ``install``. 명령 패밀리의 부모는 "
"*sub_commands*\\를 클래스 어트리뷰트로 정의합니다; 2-튜플 ``(command_name, predicate)``\\의"
" 리스트인데, *command_name*\\은 문자열이고 *predicate*\\는 함수, 문자열 또는 ``None``\\입니다. "
"*predicate*\\는 해당 명령이 현재 상황에서 적용 가능한지를 결정하는 상위 명령의 메서드입니다. (예를 들어 "
"``install_headers``\\는 설치할 C 헤더 파일이 있을 때만 적용됩니다.) *predicate*\\가 "
"``None``\\이면, 해당 명령은 항상 적용 가능합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1804
msgid ""
"*sub_commands* is usually defined at the *end* of a class, because "
"predicates can be methods of the class, so they must already have been "
"defined.  The canonical example is the :command:`install` command."
msgstr ""
"*sub_commands*\\는 일반적으로 클래스의 *끝*\\에서 정의됩니다, predicate는 클래스의 메서드일 수 있는데, "
"이때는 이미 정의되어 있어야 하기 때문입니다. 규범적 예는 :command:`install` 명령입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1810
msgid ":mod:`distutils.command` --- Individual Distutils commands"
msgstr ":mod:`distutils.command` --- 개별 Distutils 명령"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1821
msgid ":mod:`distutils.command.bdist` --- Build a binary installer"
msgstr ":mod:`distutils.command.bdist` --- 바이너리 설치 프로그램 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1831
msgid ""
":mod:`distutils.command.bdist_packager` --- Abstract base class for "
"packagers"
msgstr ":mod:`distutils.command.bdist_packager` --- 패키저를 위한 추상 베이스 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1841
msgid ":mod:`distutils.command.bdist_dumb` --- Build a \"dumb\" installer"
msgstr ":mod:`distutils.command.bdist_dumb` --- \"dumb\" 설치 프로그램 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1851
msgid ""
":mod:`distutils.command.bdist_msi` --- Build a Microsoft Installer binary"
" package"
msgstr ":mod:`distutils.command.bdist_msi` --- Microsoft 설치 프로그램 바이너리 패키지 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1858
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1887
msgid "Use bdist_wheel (wheel packages) instead."
msgstr "대신 bdist_wheel(휠 패키지)을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1861
msgid "Builds a `Windows Installer`_ (.msi) binary package."
msgstr "`Windows Installer`_ (.msi) 바이너리 패키지를 빌드합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1865
msgid ""
"In most cases, the ``bdist_msi`` installer is a better choice than the "
"``bdist_wininst`` installer, because it provides better support for Win64"
" platforms, allows administrators to perform non-interactive "
"installations, and allows installation through group policies."
msgstr ""
"대부분의 경우, ``bdist_msi`` 설치 프로그램은 Win64 플랫폼에 대한 더 나은 지원을 제공하고, 관리자가 비대화 형 "
"설치를 수행할 수 있도록 하며, 그룹 정책을 통한 설치를 허용하기 때문에 ``bdist_wininst`` 설치 프로그램보다 더 나은"
" 선택입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1872
msgid ""
":mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a "
"Redhat RPM and SRPM"
msgstr ":mod:`distutils.command.bdist_rpm` --- Redhat RPM과 SRPM으로 바이너리 배포판 구축"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1882
msgid ":mod:`distutils.command.bdist_wininst` --- Build a Windows installer"
msgstr ":mod:`distutils.command.bdist_wininst` --- 윈도우 설치 프로그램 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1895
msgid ":mod:`distutils.command.sdist` --- Build a source distribution"
msgstr ":mod:`distutils.command.sdist` --- 소스 배포판 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1905
msgid ":mod:`distutils.command.build` --- Build all files of a package"
msgstr ":mod:`distutils.command.build` --- 패키지의 모든 파일 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1915
msgid ":mod:`distutils.command.build_clib` --- Build any C libraries in a package"
msgstr ":mod:`distutils.command.build_clib` --- 패키지의 모든 C 라이브러리 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1925
msgid ":mod:`distutils.command.build_ext` --- Build any extensions in a package"
msgstr ":mod:`distutils.command.build_ext` --- 패키지의 모든 확장 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1935
msgid ""
":mod:`distutils.command.build_py` --- Build the .py/.pyc files of a "
"package"
msgstr ":mod:`distutils.command.build_py` --- 패키지의 .py/.pyc 파일 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1945
msgid ""
"Alternative implementation of build_py which also runs the 2to3 "
"conversion library on each .py file that is going to be installed. To use"
" this in a setup.py file for a distribution that is designed to run with "
"both Python 2.x and 3.x, add::"
msgstr ""
"설치할 각 .py 파일에 대해 2to3 변환 라이브러리를 실행하는 build_py의 대체 구현입니다. 파이썬 2.x와 3.x "
"모두에서 실행되도록 설계된 배포판의 setup.py 파일에서 이를 사용하려면, 여러분의 setup.py 에 다음을 추가하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1955
msgid "to your setup.py, and later::"
msgstr "그리고 나중에::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1959
msgid "to the invocation of setup()."
msgstr "를 setup() 호출에 추가하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1963
msgid ":mod:`distutils.command.build_scripts` --- Build the scripts of a package"
msgstr ":mod:`distutils.command.build_scripts` --- 패키지의 스크립트 빌드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1973
msgid ":mod:`distutils.command.clean` --- Clean a package build area"
msgstr ":mod:`distutils.command.clean` --- 패키지 빌드 영역 정리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1978
msgid ""
"This command removes the temporary files created by :command:`build` and "
"its subcommands, like intermediary compiled object files.  With the "
"``--all`` option, the complete build directory will be removed."
msgstr ""
"이 명령은 중간 컴파일된 오브젝트 파일과 같이 :command:`build`\\와 하위 명령에 의해 만들어진 임시 파일들을 "
"제거합니다. ``--all`` 옵션을 사용하면, 전체 빌드 디렉터리가 제거됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1982
msgid ""
"Extension modules built :ref:`in place <distutils-build-ext-inplace>` "
"will not be cleaned, as they are not in the build directory."
msgstr ""
":ref:`제자리에서 <distutils-build-ext-inplace>` 빌드된 확장 모듈은 빌드 디렉터리에 없기 때문에 "
"정리되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1987
msgid ":mod:`distutils.command.config` --- Perform package configuration"
msgstr ":mod:`distutils.command.config` --- 패키지 구성 수행"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:1997
msgid ":mod:`distutils.command.install` --- Install a package"
msgstr ":mod:`distutils.command.install` --- 패키지 설치"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2007
msgid ""
":mod:`distutils.command.install_data` --- Install data files from a "
"package"
msgstr ":mod:`distutils.command.install_data` --- 패키지에서 데이터 파일 설치"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2017
msgid ""
":mod:`distutils.command.install_headers` --- Install C/C++ header files "
"from a package"
msgstr ":mod:`distutils.command.install_headers` --- 패키지에서 C/C++ 헤더 파일 설치"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2027
msgid ""
":mod:`distutils.command.install_lib` --- Install library files from a "
"package"
msgstr ":mod:`distutils.command.install_lib` --- 패키지에서 라이브러리 파일 설치"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2037
msgid ""
":mod:`distutils.command.install_scripts` --- Install script files from a "
"package"
msgstr ":mod:`distutils.command.install_scripts` --- 패키지에서 스크립트 파일 설치"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2047
msgid ""
":mod:`distutils.command.register` --- Register a module with the Python "
"Package Index"
msgstr ":mod:`distutils.command.register` --- 파이썬 패키지 색인에 모듈 등록"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2053
msgid ""
"The ``register`` command registers the package with the Python Package  "
"Index. This is described in more detail in :pep:`301`."
msgstr ""
"``register`` 명령은 패키지를 파이썬 패키지 색인에 등록합니다. 이것은 :pep:`301`\\에 더 자세히 설명되어 "
"있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2060
msgid ":mod:`distutils.command.check` --- Check the meta-data of a package"
msgstr ":mod:`distutils.command.check` --- 패키지의 메타 데이터 확인"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/distutils/apiref.rst:2066
msgid ""
"The ``check`` command performs some tests on the meta-data of a package. "
"For example, it verifies that all required meta-data are provided as the "
"arguments passed to the :func:`setup` function."
msgstr ""
"``check`` 명령은 패키지의 메타 데이터에 대해 몇 가지 테스트를 수행합니다. 예를 들어, 모든 필수 메타 데이터가 "
":func:`setup` 함수에 전달된 인자로 제공되는지 확인합니다."

