# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/distutils/setupscript.rst:5
msgid "Writing the Setup Script"
msgstr "설정 스크립트 작성하기"

#: ../Doc/distutils/_setuptools_disclaimer.rst:3
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at "
"https://setuptools.readthedocs.io/en/latest/setuptools.html independently"
" covers all of the relevant information currently included here."
msgstr ""
"이 문서는 https://setuptools.readthedocs.io/en/latest/setuptools.html 의 "
"``setuptools`` 설명서가 현재 여기에 포함된 모든 관련 정보를 독립적으로 다루기 전까지만 보존됩니다."

#: ../Doc/distutils/setupscript.rst:9
msgid ""
"The setup script is the centre of all activity in building, distributing,"
" and installing modules using the Distutils.  The main purpose of the "
"setup script is to describe your module distribution to the Distutils, so"
" that the various commands that operate on your modules do the right "
"thing.  As we saw in section :ref:`distutils-simple-example` above, the "
"setup script consists mainly of a call to :func:`setup`, and most "
"information supplied to the Distutils by the module developer is supplied"
" as keyword arguments to :func:`setup`."
msgstr ""
"설정 스크립트는 Distutils를 사용하여 모듈을 빌드, 배포 및 설치하는 모든 활동의 중심입니다. 설정 스크립트의 주요 목적은 "
"여러분의 모듈 배포를 Distutils에 설명하여, 여러분의 모듈에 대해 작동하는 다양한 명령이 올바르게 수행되도록 하는 것입니다."
" 위의 :ref:`distutils-simple-example` 섹션에서 보았듯이, 설정 스크립트는 주로 "
":func:`setup`\\에 대한 호출로 구성되며, 모듈 개발자가 Distutils에 제공하는 대부분의 정보는 "
":func:`setup`\\에 키워드 인자로 제공됩니다."

#: ../Doc/distutils/setupscript.rst:17
msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, "
"shown here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"다음 몇 개의 섹션에서 다룰, 약간 더 개선된 예가 여기 있습니다: Distutils의 자체 설정 스크립트. (Distutils가 "
"파이썬 1.6 이상에 포함되어 있지만, 파이썬 1.5.2 사용자가 다른 모듈 배포판을 설치하는 데 사용할 수 있도록 독립적으로 "
"존재함에 유의하십시오. 여기에 표시된 Distutils의 자체 설정 스크립트는 파이썬 1.5.2에 패키지를 설치하는 데 "
"사용됩니다.) ::"

#: ../Doc/distutils/setupscript.rst:37
msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather"
" than by module.  This is important since the Distutils consist of a "
"couple of dozen modules split into (so far) two packages; an explicit "
"list of every module would be tedious to generate and difficult to "
"maintain.  For more information on the additional meta-data, see section "
":ref:`meta-data`."
msgstr ""
"이 섹션과 :ref:`distutils-simple-example` 섹션에 제시된 간단한 단일 파일 배포판에는 두 가지 차이점이 "
"있습니다: 더 많은 메타 데이터와 모듈이 아니라 패키지를 사용한 순수 파이썬 모듈 명세. 이것은 Distutils가 (지금까지) 두"
" 개의 패키지로 분할된 수십 개의 모듈로 구성되어 있어서 중요합니다; 모든 모듈의 명시적인 목록은 생성하기가 지루하고 유지하기가 "
"어려울 것입니다. 추가 메타 데이터에 대한 자세한 내용은, 섹션 :ref:`meta-data`\\를 참조하십시오."

#: ../Doc/distutils/setupscript.rst:45
msgid ""
"Note that any pathnames (files or directories) supplied in the setup "
"script should be written using the Unix convention, i.e. slash-separated."
"  The Distutils will take care of converting this platform-neutral "
"representation into whatever is appropriate on your current platform "
"before actually using the pathname.  This makes your setup script "
"portable across operating systems, which of course is one of the major "
"goals of the Distutils.  In this spirit, all pathnames in this document "
"are slash-separated."
msgstr ""
"설정 스크립트에 제공된 모든 경로명(파일이나 디렉터리)은 슬래시로 구분된 유닉스 규칙을 사용하여 작성해야 함에 유의하십시오. "
"Distutils는 이 플랫폼 중립적 표현을 실제로 경로명을 사용하기 전에 현재 플랫폼에 적절한 것으로 변환합니다. 이는 운영 "
"체제에 걸쳐 설정 스크립트를 이식성 있게 만드는데, 이것은 물론 Distutils의 주요 목표 중 하나입니다. 이러한 취지로, 이 "
"문서의 모든 경로명은 슬래시로 구분됩니다."

#: ../Doc/distutils/setupscript.rst:53
msgid ""
"This, of course, only applies to pathnames given to Distutils functions."
"  If you, for example, use standard Python functions such as "
":func:`glob.glob` or :func:`os.listdir` to specify files, you should be "
"careful to write portable code instead of hardcoding path separators::"
msgstr ""
"물론, 이것은 Distutils 함수에 주어진 경로명에만 적용됩니다. 예를 들어, :func:`glob.glob`\\이나 "
":func:`os.listdir`\\과 같은 표준 파이썬 함수를 사용하여 파일을 지정하면, 경로 구분자를 하드 코딩 하는 대신 "
"이식성 있는 코드를 작성하도록 주의해야 합니다::"

#: ../Doc/distutils/setupscript.rst:65
msgid "Listing whole packages"
msgstr "전체 패키지 나열하기"

#: ../Doc/distutils/setupscript.rst:67
msgid ""
"The ``packages`` option tells the Distutils to process (build, "
"distribute, install, etc.) all pure Python modules found in each package "
"mentioned in the ``packages`` list.  In order to do this, of course, "
"there has to be a correspondence between package names and directories in"
" the filesystem.  The default correspondence is the most obvious one, "
"i.e. package :mod:`distutils` is found in the directory :file:`distutils`"
" relative to the distribution root. Thus, when you say ``packages = "
"['foo']`` in your setup script, you are promising that the Distutils will"
" find a file :file:`foo/__init__.py` (which might be spelled differently "
"on your system, but you get the idea) relative to the directory where "
"your setup script lives.  If you break this promise, the Distutils will "
"issue a warning but still process the broken package anyway."
msgstr ""
"``packages`` 옵션은 Distutils가 ``packages`` 리스트에 언급된 각 패키지에 있는 모든 순수 파이썬 모듈을"
" 처리(빌드, 배포, 설치 등)하도록 지시합니다. 물론 이를 위해서는 패키지 이름과 파일 시스템의 디렉터리 간의 대응 관계가 있어야"
" 합니다. 기본 대응 관계는 가장 분명한 것입니다, 즉, 패키지 :mod:`distutils`\\는 배포 루트에 상대적인 디렉터리 "
":file:`distutils`\\에서 발견됩니다. 따라서 설정 스크립트에서 ``packages = ['foo']``\\라고 할 "
"때, Distutils가 설정 스크립트가 있는 디렉터리에 상대적으로 :file:`foo/__init__.py` 파일(여러분의 "
"시스템에서는 철자가 다를 수 있지만, 무슨 뜻인지는 알 겁니다)을 찾을 것이라고 약속하는 것입니다. 이 약속을 어기면, "
"Distutils는 경고를 표시하지만, 여전히 손상된 패키지를 처리합니다."

#: ../Doc/distutils/setupscript.rst:79
msgid ""
"If you use a different convention to lay out your source directory, "
"that's no problem: you just have to supply the ``package_dir`` option to "
"tell the Distutils about your convention.  For example, say you keep all "
"Python source under :file:`lib`, so that modules in the \"root package\" "
"(i.e., not in any package at all) are in :file:`lib`, modules in the "
":mod:`foo` package are in :file:`lib/foo`, and so forth.  Then you would "
"put ::"
msgstr ""
"다른 규칙을 사용하여 소스 디렉터리를 배치하는 것도 문제가 되지 않습니다: Distutils에 규칙에 대해 알리기 위해 "
"``package_dir`` 옵션을 제공하기만 하면 됩니다. 예를 들어, 모든 파이썬 소스를 :file:`lib` 밑에 유지하여, "
"\"루트 패키지\"의 모듈(즉, 어떤 패키지에도 속하지 않은 것)은 :file:`lib`\\에 있고, :mod:`foo` 패키지의 "
"모듈은 :file:`lib/foo`\\에 있고 등등. 그러면 다음을 여러분의 설정 스크립트에 넣습니다::"

#: ../Doc/distutils/setupscript.rst:88
msgid ""
"in your setup script.  The keys to this dictionary are package names, and"
" an empty package name stands for the root package.  The values are "
"directory names relative to your distribution root.  In this case, when "
"you say ``packages = ['foo']``, you are promising that the file "
":file:`lib/foo/__init__.py` exists."
msgstr ""
"이 딕셔너리의 키는 패키지 이름이며, 빈 패키지 이름은 루트 패키지를 나타냅니다. 값은 배포 루트에 상대적인 디렉터리 이름입니다. "
"이 경우, ``packages = ['foo']``\\라고 할 때, 파일 :file:`lib/foo/__init__.py`\\가 "
"존재한다고 약속하는 것입니다."

#: ../Doc/distutils/setupscript.rst:93
msgid ""
"Another possible convention is to put the :mod:`foo` package right in "
":file:`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This "
"would be written in the setup script as ::"
msgstr ""
"또 다른 가능한 규칙은 :mod:`foo` 패키지를 :file:`lib`\\에, :mod:`foo.bar` 패키지를 "
":file:`lib/bar`\\에 두는 것입니다. 이것은 설치 스크립트에서 다음과 같이 작성됩니다 ::"

#: ../Doc/distutils/setupscript.rst:99
msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo',"
" 'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and"
" :file:`lib/bar/__init__.py`.  (Keep in mind that although "
"``package_dir`` applies recursively, you must explicitly list all "
"packages in ``packages``: the Distutils will *not* recursively scan your "
"source tree looking for any directory with an :file:`__init__.py` file.)"
msgstr ""
"``package_dir`` 딕셔너리의 ``package: dir`` 항목은 *package* 아래의 모든 패키지에 묵시적으로 "
"적용되므로, :mod:`foo.bar` 사례는 여기에서 자동으로 처리됩니다. 이 예에서, ``packages = ['foo', "
"'foo.bar']``\\가 있으면 Distutils에 :file:`lib/__init__.py`\\와 "
":file:`lib/bar/__init__.py`\\를 찾도록 지시합니다. (``package_dir``\\이 재귀적으로 "
"적용되지만, ``packages``\\의 모든 패키지를 명시적으로 나열해야 함에 유의하십시오: Distutils는 "
":file:`__init__.py` 파일이 있는 디렉터리를 찾기 위해 소스 트리를 재귀적으로 스캔하지 *않습니다*.)"

#: ../Doc/distutils/setupscript.rst:112
msgid "Listing individual modules"
msgstr "개별 모듈 나열하기"

#: ../Doc/distutils/setupscript.rst:114
msgid ""
"For a small module distribution, you might prefer to list all modules "
"rather than listing packages---especially the case of a single module "
"that goes in the \"root package\" (i.e., no package at all).  This "
"simplest case was shown in section :ref:`distutils-simple-example`; here "
"is a slightly more involved example::"
msgstr ""
"소규모 모듈 배포의 경우, 패키지를 나열하는 대신 모든 모듈을 나열하는 것이 좋습니다---특히 \"루트 패키지\"에 있는 단일 "
"모듈의 경우 (즉, 패키지가 아예 없습니다). 이 가장 간단한 경우는 섹션 :ref:`distutils-simple-"
"example`\\에 표시되었습니다; 다음은 약간 더 개선된 예입니다::"

#: ../Doc/distutils/setupscript.rst:121
msgid ""
"This describes two modules, one of them in the \"root\" package, the "
"other in the :mod:`pkg` package.  Again, the default package/directory "
"layout implies that these two modules can be found in :file:`mod1.py` and"
" :file:`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. "
"And again, you can override the package/directory correspondence using "
"the ``package_dir`` option."
msgstr ""
"이것은 두 모듈을 기술합니다, 하나는 \"루트\" 패키지에 있고, 다른 하나는 :mod:`pkg` 패키지에 있습니다. 다시, 기본 "
"패키지/디렉터리 레이아웃은 이 두 모듈이 :file:`mod1.py`\\와 :file:`pkg/mod2.py`\\에서 발견될 수 "
"있고 :file:`pkg/__init__.py`\\도 존재함을 암시합니다. 그리고 다시, ``package_dir`` 옵션을 "
"사용하여 패키지/디렉터리 대응 관계를 재정의할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:131
msgid "Describing extension modules"
msgstr "확장 모듈 기술하기"

#: ../Doc/distutils/setupscript.rst:133
msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit "
"more complicated. Unlike pure modules, it's not enough just to list "
"modules or packages and expect the Distutils to go out and find the right"
" files; you have to specify the extension name, source file(s), and any "
"compile/link requirements (include directories, libraries to link with, "
"etc.)."
msgstr ""
"순수 파이썬 모듈을 작성하는 것보다 파이썬 확장 모듈을 작성하는 것이 조금 더 복잡한 것처럼, 확장 모듈을 Distutils에 "
"설명하는 것은 조금 더 복잡합니다. 순수한 모듈과 달리, 단지 모듈이나 패키지를 나열하고 Distutils가 가서 올바른 파일을 "
"찾을 것으로 기대할 수는 없습니다; 확장 이름, 소스 파일 및 컴파일/링크 요구 사항(인클루드 디렉터리, 링크할 라이브러리 등)을 "
"지정해야 합니다."

#: ../Doc/distutils/setupscript.rst:142
msgid ""
"All of this is done through another keyword argument to :func:`setup`, "
"the ``ext_modules`` option.  ``ext_modules`` is just a list of "
":class:`~distutils.core.Extension` instances, each of which describes a "
"single extension module. Suppose your distribution includes a single "
"extension, called :mod:`foo` and implemented by :file:`foo.c`.  If no "
"additional instructions to the compiler/linker are needed, describing "
"this extension is quite simple::"
msgstr ""
"이 모든 것은 :func:`setup`\\에 대한 또 다른 키워드 인자를 통해 수행됩니다, ``ext_modules`` 옵션. "
"``ext_modules``\\는 단지 :class:`~distutils.core.Extension` 인스턴스의 리스트일 뿐이며, "
"각각 단일 확장 모듈을 설명합니다. 여러분의 배포판에 :mod:`foo`\\라는 단일 확장이 포함되어 있고 "
":file:`foo.c`\\로 구현되었다고 가정합시다. 컴파일러/링커에 대한 추가 지침이 필요하지 않으면, 이 확장을 설명하는 것은"
" 매우 간단합니다::"

#: ../Doc/distutils/setupscript.rst:152
msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module "
"distribution that contains only this one extension and nothing else might"
" be::"
msgstr ""
":class:`Extension` 클래스는 :func:`setup`\\과 함께 :mod:`distutils.core`\\에서 임포트"
" 할 수 있습니다. 따라서, 이 하나의 확장만 포함하고 다른 것은 포함하지 않는 모듈 배포판의 설정 스크립트는 다음과 같습니다::"

#: ../Doc/distutils/setupscript.rst:162
msgid ""
"The :class:`Extension` class (actually, the underlying extension-building"
" machinery implemented by the :command:`build_ext` command) supports a "
"great deal of flexibility in describing Python extensions, which is "
"explained in the following sections."
msgstr ""
":class:`Extension` 클래스(실제로는, :command:`build_ext` 명령으로 구현된 하부 확장 빌드 시스템)는"
" 파이썬 확장을 설명하는 데 많은 유연성을 지원하고, 다음 섹션에서 설명합니다."

#: ../Doc/distutils/setupscript.rst:169
msgid "Extension names and packages"
msgstr "확장 이름과 패키지"

#: ../Doc/distutils/setupscript.rst:171
msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor "
"is always the name of the extension, including any package names.  For "
"example, ::"
msgstr ""
":class:`~distutils.core.Extension` 생성자에 대한 첫 번째 인자는 항상 패키지 이름을 포함한 확장의 "
"이름입니다. 예를 들면, ::"

#: ../Doc/distutils/setupscript.rst:176
msgid "describes an extension that lives in the root package, while ::"
msgstr "는 루트 패키지에 있는 확장을 설명하지만, ::"

#: ../Doc/distutils/setupscript.rst:180
msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files"
" and resulting object code are identical in both cases; the only "
"difference is where in the filesystem (and therefore where in Python's "
"namespace hierarchy) the resulting extension lives."
msgstr ""
"는 :mod:`pkg` 패키지에 있는 같은 확장을 설명합니다. 소스 파일과 결과 객체 코드는 두 경우 모두 동일합니다; 유일한 "
"차이점은 결과 확장이 존재할 파일 시스템에서의 위치(그리고 파이썬의 이름 공간 계층에서의 위치)입니다."

#: ../Doc/distutils/setupscript.rst:185
msgid ""
"If you have a number of extensions all in the same package (or all under "
"the same base package), use the ``ext_package`` keyword argument to "
":func:`setup`.  For example, ::"
msgstr ""
"모두 같은 패키지에 있는 여러 개의 확장이 있으면 (또는 모두 같은 베이스 패키지 아래), :func:`setup`\\에 "
"``ext_package`` 키워드 인자를 사용하십시오. 예를 들면, ::"

#: ../Doc/distutils/setupscript.rst:195
msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and "
":file:`bar.c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"는 :file:`foo.c`\\를 확장 :mod:`pkg.foo`\\로, :file:`bar.c`\\를 "
":mod:`pkg.subpkg.bar`\\로 컴파일합니다."

#: ../Doc/distutils/setupscript.rst:200
msgid "Extension source files"
msgstr "확장 소스 파일"

#: ../Doc/distutils/setupscript.rst:202
msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor"
" is a list of source files.  Since the Distutils currently only support "
"C, C++, and Objective-C extensions, these are normally C/C++/Objective-C "
"source files.  (Be sure to use appropriate extensions to distinguish C++ "
"source files: :file:`.cc` and :file:`.cpp` seem to be recognized by both "
"Unix and Windows compilers.)"
msgstr ""
":class:`~distutils.core.Extension` 생성자에 대한 두 번째 인자는 소스 파일 리스트입니다. "
"Distutils는 현재 C, C++ 및 Objective-C 확장만 지원하므로, 일반적으로 C/C++/Objective-C 소스 "
"파일입니다. (C++ 소스 파일을 구별하기 위해 적절한 확장자를 사용해야 합니다: :file:`.cc`\\와 "
":file:`.cpp`\\는 유닉스와 윈도우 컴파일러 모두에서 인식되는 것 같습니다.)"

#: ../Doc/distutils/setupscript.rst:209
msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the "
"list; the :command:`build_ext` command knows how to deal with SWIG "
"extensions: it will run SWIG on the interface file and compile the "
"resulting C/C++ file into your extension."
msgstr ""
"그러나, 리스트에 SWIG 인터페이스 (:file:`.i`) 파일을 포함할 수도 있습니다; :command:`build_ext` "
"명령은 SWIG 확장을 처리하는 방법을 알고 있습니다: 인터페이스 파일에 대해 SWIG을 실행하고 결과 C/C++ 파일을 확장으로 "
"컴파일합니다."

#: ../Doc/distutils/setupscript.rst:216
msgid ""
"This warning notwithstanding, options to SWIG can be currently passed "
"like this::"
msgstr "이 경고에도 불구하고, SWIG에 대한 옵션은 현재 다음과 같이 전달될 수 있습니다::"

#: ../Doc/distutils/setupscript.rst:225
msgid "Or on the commandline like this::"
msgstr "또는 다음과 같이 명령 줄에서::"

#: ../Doc/distutils/setupscript.rst:229
msgid ""
"On some platforms, you can include non-source files that are processed by"
" the compiler and included in your extension.  Currently, this just means"
" Windows message text (:file:`.mc`) files and resource definition "
"(:file:`.rc`) files for Visual C++. These will be compiled to binary "
"resource (:file:`.res`) files and linked into the executable."
msgstr ""
"일부 플랫폼에서는, 컴파일러에서 처리되고 확장에 포함되는 비 소스 파일을 포함할 수 있습니다. 현재, 이것은 Visual C++ 용"
" 윈도우 메시지 텍스트 (:file:`.mc`) 파일과 리소스 정의 (:file:`.rc`) 파일을 의미합니다. 이들은 바이너리 "
"리소스 (:file:`.res`) 파일로 컴파일되고 실행 파일에 링크됩니다."

#: ../Doc/distutils/setupscript.rst:237
msgid "Preprocessor options"
msgstr "전 처리기 옵션"

#: ../Doc/distutils/setupscript.rst:239
msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help "
"if you need to specify include directories to search or preprocessor "
"macros to define/undefine: ``include_dirs``, ``define_macros``, and "
"``undef_macros``."
msgstr ""
":class:`~distutils.core.Extension`\\에 대한 세 가지 선택적 인자는 검색할 인클루드 디렉터리나 "
"정의/정의 해제할 전 처리기 매크로를 지정해야 하는 경우 도움이 됩니다: ``include_dirs``, "
"``define_macros`` 및 ``undef_macros``."

#: ../Doc/distutils/setupscript.rst:243
msgid ""
"For example, if your extension requires header files in the "
":file:`include` directory under your distribution root, use the "
"``include_dirs`` option::"
msgstr ""
"예를 들어, 확장에 배포 루트 아래의 :file:`include` 디렉터리에 있는 헤더 파일이 필요한 경우, "
"``include_dirs`` 옵션을 사용하십시오::"

#: ../Doc/distutils/setupscript.rst:248
msgid ""
"You can specify absolute directories there; if you know that your "
"extension will only be built on Unix systems with X11R6 installed to "
":file:`/usr`, you can get away with ::"
msgstr ""
"거기에 절대 디렉터리를 지정할 수 있습니다; X11R6이 :file:`/usr`\\에 설치된 유닉스 시스템에서만 확장이 빌드된다는 "
"것을 알고 있다면, 다음과 같이 할 수 있습니다 ::"

#: ../Doc/distutils/setupscript.rst:254
msgid ""
"You should avoid this sort of non-portable usage if you plan to "
"distribute your code: it's probably better to write C code like  ::"
msgstr "코드를 배포하려는 경우 이런 종류의 이식성 없는 사용을 피해야 합니다: 다음과 같은 C 코드를 작성하는 것이 좋습니다 ::"

#: ../Doc/distutils/setupscript.rst:259
msgid ""
"If you need to include header files from some other Python extension, you"
" can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard "
"Unix installation) to :file:`/usr/local/include/python1.5/Numerical`. "
"(The exact location will differ according to your platform and Python "
"installation.)  Since the Python include directory---\\ "
":file:`/usr/local/include/python1.5` in this case---is always included in"
" the search path when building Python extensions, the best approach is to"
" write C code like  ::"
msgstr ""
"다른 파이썬 확장의 헤더 파일을 포함해야 하는 경우, Distutils :command:`install_headers` 명령으로 "
"헤더 파일이 일관된 방식으로 설치된다는 사실을 이용할 수 있습니다. 예를 들어, Numerical Python 헤더 파일은 (표준 "
"유닉스 설치 시) :file:`/usr/local/include/python1.5/Numerical`\\에 설치됩니다. (정확한 "
"위치는 플랫폼과 파이썬 설치에 따라 다릅니다.) 파이썬 인클루드 디렉터리---\\ 이 경우 "
":file:`/usr/local/include/python1.5`---는 파이썬 확장을 빌드할 때 항상 검색 경로에 포함되므로, "
"다음과 같이 C 코드를 작성하는 것이 가장 좋습니다 ::"

#: ../Doc/distutils/setupscript.rst:271
msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the "
"Distutils :mod:`distutils.sysconfig` module::"
msgstr ""
":file:`Numerical` 인클루드 디렉터리를 헤더 검색 경로에 바로 넣어야 하면, Distutils "
":mod:`distutils.sysconfig` 모듈을 사용하여 해당 디렉터리를 찾을 수 있습니다::"

#: ../Doc/distutils/setupscript.rst:281
msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write"
" your C code in the sensible way."
msgstr "이것은 꽤 이식성 있지만---플랫폼과 관계없이, 모든 파이썬 설치에서 작동합니다---C 코드를 현명하게 작성하기가 더 쉽습니다."

#: ../Doc/distutils/setupscript.rst:285
msgid ""
"You can define and undefine pre-processor macros with the "
"``define_macros`` and ``undef_macros`` options. ``define_macros`` takes a"
" list of ``(name, value)`` tuples, where ``name`` is the name of the "
"macro to define (a string) and ``value`` is its value: either a string or"
" ``None``.  (Defining a macro ``FOO`` to ``None`` is the equivalent of a "
"bare ``#define FOO`` in your C source: with most compilers, this sets "
"``FOO`` to the string ``1``.)  ``undef_macros`` is just a list of macros "
"to undefine."
msgstr ""
"``define_macros``\\와 ``undef_macros`` 옵션을 사용하여 전 처리기 매크로를 정의하고 정의를 해제할 수 "
"있습니다. ``define_macros``\\는 ``(name, value)`` 튜플의 리스트를 취합니다, 여기서 "
"``name``\\은 정의할 매크로의 이름(문자열)이고 ``value``\\는 값입니다: 문자열이거나 ``None``. (매크로 "
"``FOO``\\를 ``None``\\으로 정의하는 것은 C 소스에서 값이 없는 ``#define FOO``\\와 같습니다: "
"대부분의 컴파일러에서는 ``FOO``\\를 문자열 ``1``\\로 설정합니다.) ``undef_macros``\\는 정의 해제할 "
"매크로의 리스트입니다."

#: ../Doc/distutils/setupscript.rst:293
msgid "For example::"
msgstr "예를 들면::"

#: ../Doc/distutils/setupscript.rst:300
msgid "is the equivalent of having this at the top of every C source file::"
msgstr "는 모든 C 소스 파일의 맨 위에 다음과 같은 것을 넣는 것과 동등합니다::"

#: ../Doc/distutils/setupscript.rst:309
msgid "Library options"
msgstr "라이브러리 옵션"

#: ../Doc/distutils/setupscript.rst:311
msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  "
"link-time, and ``runtime_library_dirs`` is a list of directories to  "
"search for shared (dynamically loaded) libraries at run-time."
msgstr ""
"확장을 빌드할 때 링크할 라이브러리와 해당 라이브러리를 검색할 디렉터리를 지정할 수도 있습니다. ``libraries`` 옵션은 "
"링크할 라이브러리의 리스트이고, ``library_dirs``\\는 링크 시점에 라이브러리를 검색할 디렉터리 리스트이고, "
"``runtime_library_dirs``\\는 실행 시간에 공유 (동적으로 로드된) 라이브러리를 검색할 디렉터리 리스트입니다."

#: ../Doc/distutils/setupscript.rst:317
msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr "예를 들어, 대상 시스템의 표준 라이브러리 검색 경로에 있는 것으로 알려진 라이브러리와 링크해야 하면 ::"

#: ../Doc/distutils/setupscript.rst:323
msgid ""
"If you need to link with libraries in a non-standard location, you'll "
"have to include the location in ``library_dirs``::"
msgstr "비표준 위치의 라이브러리와 링크해야 하면, ``library_dirs``\\에 위치를 포함해야 합니다::"

#: ../Doc/distutils/setupscript.rst:330
msgid ""
"(Again, this sort of non-portable construct should be avoided if you "
"intend to distribute your code.)"
msgstr "(다시, 코드를 배포하려는 경우 이러한 이식성 없는 구성은 피해야 합니다.)"

#: ../Doc/distutils/setupscript.rst:337
msgid "Other options"
msgstr "다른 옵션"

#: ../Doc/distutils/setupscript.rst:339
msgid ""
"There are still some other options which can be used to handle special "
"cases."
msgstr "특수한 경우를 처리하는 데 사용할 수 있는 다른 옵션이 아직 남아있습니다."

#: ../Doc/distutils/setupscript.rst:341
msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in "
"the extension will not abort the build process, but instead simply not "
"install the failing extension."
msgstr ""
"``optional`` 옵션은 불리언입니다. 참이면, 그 확장에서의 빌드 실패는 빌드 프로세스를 중단시키지 않고 대신 실패한 확장을"
" 설치하지 않습니다."

#: ../Doc/distutils/setupscript.rst:345
msgid ""
"The ``extra_objects`` option is a list of object files to be passed to "
"the linker. These files must not have extensions, as the default "
"extension for the compiler is used."
msgstr ""
"``extra_objects`` 옵션은 링커에 전달할 객체 파일의 리스트입니다. 컴파일러의 기본 확장자가 사용되므로 이러한 파일에는"
" 확장자가 없어야 합니다."

#: ../Doc/distutils/setupscript.rst:349
msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args``\\와 ``extra_link_args``\\를 사용하여 해당 컴파일러와 링커 명령 줄에 "
"대한 추가 명령 줄 옵션을 지정할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:353
msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not "
"needed when building compiled extensions: Distutils  will automatically "
"add ``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols``\\는 윈도우에서만 유용합니다. 내보낼 심볼 (함수나 변수) 목록을 포함할 수 있습니다. 컴파일된 "
"확장을 빌드할 때는 이 옵션이 필요하지 않습니다: Distutils는 내 보내는 심볼 목록에 ``initmodule``\\을 "
"자동으로 추가합니다."

#: ../Doc/distutils/setupscript.rst:358
msgid ""
"The ``depends`` option is a list of files that the extension depends on "
"(for example header files). The build command will call the compiler on "
"the sources to rebuild extension if any on this files has been modified "
"since the previous build."
msgstr ""
"``depends`` 옵션은 확장이 의존하는 파일의 리스트입니다 (예를 들어 헤더 파일). build 명령은 이전 빌드 이후 이 "
"파일들에 수정된 파일이 있으면 소스에 대해 컴파일러를 호출하여 확장을 다시 빌드합니다."

#: ../Doc/distutils/setupscript.rst:364
msgid "Relationships between Distributions and Packages"
msgstr "배포판과 패키지의 관계"

#: ../Doc/distutils/setupscript.rst:366
msgid "A distribution may relate to packages in three specific ways:"
msgstr "배포판은 세 가지 방법으로 패키지와 관련될 수 있습니다:"

#: ../Doc/distutils/setupscript.rst:368
msgid "It can require packages or modules."
msgstr "패키지나 모듈이 필요할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:370
msgid "It can provide packages or modules."
msgstr "패키지나 모듈을 제공할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:372
msgid "It can obsolete packages or modules."
msgstr "패키지나 모듈을 폐기(obsolete)할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:374
msgid ""
"These relationships can be specified using keyword arguments to the "
":func:`distutils.core.setup` function."
msgstr "이러한 관계는 :func:`distutils.core.setup` 함수에 키워드 인자를 사용하여 지정할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:377
msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value "
"must be a list of strings.  Each string specifies a package that is "
"required, and optionally what versions are sufficient."
msgstr ""
"*requires* 키워드 인자를 :func:`setup`\\에 제공하여 다른 파이썬 모듈과 패키지에 대한 의존성을 지정할 수 "
"있습니다. 값은 문자열 리스트여야 합니다. 각 문자열은 필요한 패키지와 선택적으로 충분한 버전을 지정합니다."

#: ../Doc/distutils/setupscript.rst:382
msgid ""
"To specify that any version of a module or package is required, the "
"string should consist entirely of the module or package name. Examples "
"include ``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""
"모듈이나 패키지의 임의의 버전이 필요하도록 지정하려면, 문자열은 모듈이나 패키지 이름으로만 구성되어야 합니다. 예로는 "
"``'mymodule'``\\과 ``'xml.parsers.expat'``\\이 있습니다."

#: ../Doc/distutils/setupscript.rst:386
msgid ""
"If specific versions are required, a sequence of qualifiers can be "
"supplied in parentheses.  Each qualifier may consist of a comparison "
"operator and a version number.  The accepted comparison operators are::"
msgstr ""
"특정 버전이 필요하면, 일련의 한정자를 괄호 안에 제공할 수 있습니다. 각 한정자는 비교 연산자와 버전 번호로 구성될 수 있습니다."
" 허용되는 비교 연산자는 다음과 같습니다::"

#: ../Doc/distutils/setupscript.rst:393
msgid ""
"These can be combined by using multiple qualifiers separated by commas "
"(and optional whitespace).  In this case, all of the qualifiers must be "
"matched; a logical AND is used to combine the evaluations."
msgstr ""
"쉼표(와 선택적인 공백)로 구분된 여러 한정자를 사용하여 결합 할 수 있습니다. 이 경우, 모든 한정자가 일치해야 합니다; 논리적 "
"AND가 평가를 결합하는 데 사용됩니다."

#: ../Doc/distutils/setupscript.rst:397
msgid "Let's look at a bunch of examples:"
msgstr "여러 가지 예를 살펴보겠습니다:"

#: ../Doc/distutils/setupscript.rst:400
msgid "Requires Expression"
msgstr "Requires 표현식"

#: ../Doc/distutils/setupscript.rst:400 ../Doc/distutils/setupscript.rst:418
msgid "Explanation"
msgstr "설명"

#: ../Doc/distutils/setupscript.rst:402
msgid "``==1.0``"
msgstr "``==1.0``"

#: ../Doc/distutils/setupscript.rst:402
msgid "Only version ``1.0`` is compatible"
msgstr "버전 ``1.0``\\만 호환됩니다"

#: ../Doc/distutils/setupscript.rst:404
msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

#: ../Doc/distutils/setupscript.rst:404
msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except "
"``1.5.1``"
msgstr "``1.0`` 이후와 ``2.0`` 이전의 모든 버전이 호환됩니다, ``1.5.1``\\은 제외"

#: ../Doc/distutils/setupscript.rst:408
msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using"
" the *provides* keyword argument to :func:`setup`. The value for this "
"keyword is a list of strings, each of which names a Python module or "
"package, and optionally identifies the version.  If the version is not "
"specified, it is assumed to match that of the distribution."
msgstr ""
"이제 의존성을 지정할 수 있으니, 다른 배포에 필요한 것을 제공할 수도 있어야 합니다. 이는 :func:`setup`\\에 "
"*provides* 키워드 인자를 사용하여 수행됩니다. 이 키워드의 값은 문자열의 리스트이며, 각 문자열은 파이썬 모듈이나 패키지의"
" 이름이며, 선택적으로 버전을 식별합니다. 버전을 지정하지 않으면, 배포판의 버전과 일치하는 것으로 간주합니다."

#: ../Doc/distutils/setupscript.rst:415
msgid "Some examples:"
msgstr "몇 가지 예:"

#: ../Doc/distutils/setupscript.rst:418
msgid "Provides Expression"
msgstr "Provides 표현식"

#: ../Doc/distutils/setupscript.rst:420
msgid "``mypkg``"
msgstr "``mypkg``"

#: ../Doc/distutils/setupscript.rst:420
msgid "Provide ``mypkg``, using the distribution version"
msgstr "배포판 버전을 사용하여, ``mypkg``\\를 제공합니다"

#: ../Doc/distutils/setupscript.rst:423
msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

#: ../Doc/distutils/setupscript.rst:423
msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr "배포판 버전과 관계없이, ``mypkg`` 버전 1.1을 제공합니다"

#: ../Doc/distutils/setupscript.rst:427
msgid ""
"A package can declare that it obsoletes other packages using the "
"*obsoletes* keyword argument.  The value for this is similar to that of "
"the *requires* keyword: a list of strings giving module or package "
"specifiers.  Each specifier consists of a module or package name "
"optionally followed by one or more version qualifiers.  Version "
"qualifiers are given in parentheses after the module or package name."
msgstr ""
"패키지는 *obsoletes* 키워드 인자를 사용하여 다른 패키지를 폐기한다고 선언할 수 있습니다. 이것의 값은 *requires*"
" 키워드의 값과 유사합니다: 모듈이나 패키지 지정자를 제공하는 문자열의 리스트. 각 지정자는 모듈이나 패키지 이름으로 구성되고 "
"선택적으로 하나 이상의 버전 한정자가 뒤따릅니다. 버전 한정자는 모듈이나 패키지 이름 다음에 괄호 안에 주어집니다."

#: ../Doc/distutils/setupscript.rst:434
msgid ""
"The versions identified by the qualifiers are those that are obsoleted by"
" the distribution being described.  If no qualifiers are given, all "
"versions of the named module or package are understood to be obsoleted."
msgstr ""
"한정자에 의해 식별된 버전은 기술 중인 배포판에 의해 폐기되는 버전입니다. 한정자가 제공되지 않으면, 명명된 모듈이나 패키지의 모든"
" 버전이 폐기되는 것으로 이해됩니다."

#: ../Doc/distutils/setupscript.rst:441
msgid "Installing Scripts"
msgstr "스크립트 설치하기"

#: ../Doc/distutils/setupscript.rst:443
msgid ""
"So far we have been dealing with pure and non-pure Python modules, which "
"are usually not run by themselves but imported by scripts."
msgstr "지금까지 우리는 순수하거나 순수하지 않은 파이썬 모듈을 다루어 왔는데, 보통은 그 스스로 실행하지 않고 스크립트가 임포트 합니다."

#: ../Doc/distutils/setupscript.rst:446
msgid ""
"Scripts are files containing Python source code, intended to be started "
"from the command line.  Scripts don't require Distutils to do anything "
"very complicated. The only clever feature is that if the first line of "
"the script starts with ``#!`` and contains the word \"python\", the "
"Distutils will adjust the first line to refer to the current interpreter "
"location. By default, it is replaced with the current interpreter "
"location.  The :option:`!--executable` (or :option:`!-e`) option will "
"allow the interpreter path to be explicitly overridden."
msgstr ""
"스크립트는 명령 줄에서 시작하려는 의도로 만들어진, 파이썬 소스 코드를 포함하는 파일입니다. 스크립트는 Distutils가 매우 "
"복잡한 작업을 수행하도록 요구하지는 않습니다. 유일한 영리한 기능은 스크립트의 첫 번째 줄이 ``#!``\\로 시작하고 단어 "
"\"python\"을 포함하면, Distutils가 첫 번째 줄을 조정하여 현재 인터프리터 위치를 참조하도록 만든다는 것입니다. "
"기본적으로, 현재 인터프리터 위치로 바뀝니다. :option:`!--executable` (또는 :option:`!-e`) 옵션을 "
"사용하면 인터프리터 경로를 명시적으로 재정의할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:454
msgid ""
"The ``scripts`` option simply is a list of files to be handled in this "
"way.  From the PyXML setup script::"
msgstr "``scripts`` 옵션은 단순히 이런 방식으로 처리할 파일의 리스트입니다. PyXML 설정 스크립트에서::"

#: ../Doc/distutils/setupscript.rst:461
msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no "
"template is provided.  See :ref:`manifest`."
msgstr "템플릿이 제공되지 않으면 모든 스크립트가 ``MANIFEST`` 파일에 추가됩니다. :ref:`manifest`\\를 참조하십시오."

#: ../Doc/distutils/setupscript.rst:469
msgid "Installing Package Data"
msgstr "패키지 데이터 설치하기"

#: ../Doc/distutils/setupscript.rst:471
msgid ""
"Often, additional files need to be installed into a package.  These files"
" are often data that's closely related to the package's implementation, "
"or text files containing documentation that might be of interest to "
"programmers using the package.  These files are called :dfn:`package "
"data`."
msgstr ""
"종종, 추가 파일을 패키지에 설치해야 합니다. 이러한 파일은 종종 패키지 구현과 밀접한 관련이 있는 데이터, 또는 패키지를 사용하는"
" 프로그래머가 관심을 가질 설명서가 포함된 텍스트 파일입니다. 이러한 파일을 :dfn:`패키지 데이터(package "
"data)`\\라고 합니다."

#: ../Doc/distutils/setupscript.rst:476
msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from"
" package name to a list of relative path names that should be copied into"
" the package.  The paths are interpreted as relative to the directory "
"containing the package (information from the ``package_dir`` mapping is "
"used if appropriate); that is, the files are expected to be part of the "
"package in the source directories. They may contain glob patterns as "
"well."
msgstr ""
":func:`setup` 함수에 ``package_data`` 키워드 인자를 사용하여 패키지 데이터를 패키지에 추가할 수 있습니다."
" 값은 패키지 이름에서 패키지로 복사해야 하는 상대 경로 이름의 리스트로의 매핑이어야 합니다. 경로는 패키지를 포함하는 디렉터리에 "
"상대적으로 해석됩니다 (적절하면 ``package_dir`` 매핑의 정보가 사용됩니다); 즉, 파일은 소스 디렉터리에서 패키지 "
"일부가 될 것으로 예상됩니다. glob 패턴도 포함할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:484
msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr "경로 이름에는 디렉터리 부분이 포함될 수 있습니다; 모든 필요한 디렉터리가 설치 시에 만들어집니다."

#: ../Doc/distutils/setupscript.rst:487
msgid ""
"For example, if a package should contain a subdirectory with several data"
" files, the files can be arranged like this in the source tree::"
msgstr "예를 들어, 패키지에 여러 데이터 파일이 있는 서브 디렉터리가 있어야 하면, 소스 트리에서 다음과 같이 파일을 배열할 수 있습니다::"

#: ../Doc/distutils/setupscript.rst:500
msgid "The corresponding call to :func:`setup` might be::"
msgstr ":func:`setup`\\에 대한 해당 호출은 다음과 같습니다::"

#: ../Doc/distutils/setupscript.rst:509
msgid ""
"All the files that match ``package_data`` will be added to the "
"``MANIFEST`` file if no template is provided.  See :ref:`manifest`."
msgstr ""
"템플릿이 제공되지 않으면 ``package_data``\\와 일치하는 모든 파일이 ``MANIFEST`` 파일에 추가됩니다. "
":ref:`manifest`\\를 참조하십시오."

#: ../Doc/distutils/setupscript.rst:517
msgid "Installing Additional Files"
msgstr "추가 파일 설치하기"

#: ../Doc/distutils/setupscript.rst:519
msgid ""
"The ``data_files`` option can be used to specify additional files needed "
"by the module distribution: configuration files, message catalogs, data "
"files, anything which doesn't fit in the previous categories."
msgstr ""
"``data_files`` 옵션은 모듈 배포에 필요한 추가 파일을 지정하는 데 사용할 수 있습니다: 구성 파일, 메시지 카탈로그, "
"데이터 파일, 이전 범주에 맞지 않는 모든 것."

#: ../Doc/distutils/setupscript.rst:523
msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in "
"the following way::"
msgstr "``data_files``\\는 다음과 같은 방식으로 (*directory*, *files*) 쌍의 시퀀스를 지정합니다::"

#: ../Doc/distutils/setupscript.rst:531
msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the "
"installation directory and the files to install there."
msgstr "시퀀스의 각 (*directory*, *files*) 쌍은 설치 디렉터리와 그곳에 설치할 파일을 지정합니다."

#: ../Doc/distutils/setupscript.rst:534
msgid ""
"Each file name in *files* is interpreted relative to the :file:`setup.py`"
" script at the top of the package source distribution. Note that you can "
"specify the directory where the data files will be installed, but you "
"cannot rename the data files themselves."
msgstr ""
"*files*\\의 각 파일 이름은 패키지 소스 배포의 맨 위에 있는 :file:`setup.py` 스크립트에 상대적으로 "
"해석됩니다. 데이터 파일이 설치될 디렉터리를 지정할 수 있지만 데이터 파일 자체의 이름을 바꿀 수는 없음에 유의하십시오."

#: ../Doc/distutils/setupscript.rst:539
msgid ""
"The *directory* should be a relative path. It is interpreted relative to "
"the installation prefix (Python's ``sys.prefix`` for system "
"installations; ``site.USER_BASE`` for user installations). Distutils "
"allows *directory* to be an absolute installation path, but this is "
"discouraged since it is incompatible with the wheel packaging format. No "
"directory information from *files* is used to determine the final "
"location of the installed file; only the name of the file is used."
msgstr ""
"*directory*\\는 상대 경로여야 합니다. 설치 접두사(시스템 설치의 경우 파이썬의 ``sys.prefix``; 사용자 "
"설치의 경우 ``site.USER_BASE``)에 상대적으로 해석됩니다. Distutils는 *directory*\\에 절대 설치 "
"경로를 허용하지만, 휠(wheel) 패키징 형식과 호환되지 않아서 권장하지 않습니다. 설치되는 파일의 최종 위치를 판별하기 위해 "
"*files*\\의 디렉터리 정보가 사용되지 않습니다; 파일 이름 만 사용됩니다."

#: ../Doc/distutils/setupscript.rst:547
msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and "
"the :command:`install` command will print a warning in this case. To "
"install data files directly in the target directory, an empty string "
"should be given as the directory."
msgstr ""
"대상 디렉터리를 지정하지 않고 ``data_files`` 옵션을 간단한 files의 시퀀스로 지정할 수 있지만, 이 방법은 권장되지"
" 않으며, 이 경우 :command:`install` 명령은 경고를 인쇄합니다. 대상 디렉터리에 데이터 파일을 직접 설치하려면, "
"directory에 빈 문자열을 지정해야 합니다."

#: ../Doc/distutils/setupscript.rst:553
msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST``"
" file if no template is provided.  See :ref:`manifest`."
msgstr ""
"템플릿이 제공되지 않으면 ``data_files``\\와 일치하는 모든 파일이 ``MANIFEST`` 파일에 추가됩니다. "
":ref:`manifest`\\를 참조하십시오."

#: ../Doc/distutils/setupscript.rst:561
msgid "Additional meta-data"
msgstr "추가 메타 데이터"

#: ../Doc/distutils/setupscript.rst:563
msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr "설정 스크립트에는 이름과 버전 이외의 추가 메타 데이터가 포함될 수 있습니다. 이 정보에는 다음이 포함됩니다:"

#: ../Doc/distutils/setupscript.rst:567
msgid "Meta-Data"
msgstr "메타 데이터"

#: ../Doc/distutils/setupscript.rst:567
msgid "Description"
msgstr "설명"

#: ../Doc/distutils/setupscript.rst:567
msgid "Value"
msgstr "값"

#: ../Doc/distutils/setupscript.rst:567
msgid "Notes"
msgstr "노트"

#: ../Doc/distutils/setupscript.rst:569
msgid "``name``"
msgstr "``name``"

#: ../Doc/distutils/setupscript.rst:569
msgid "name of the package"
msgstr "패키지 이름"

#: ../Doc/distutils/setupscript.rst:569 ../Doc/distutils/setupscript.rst:571
#: ../Doc/distutils/setupscript.rst:573 ../Doc/distutils/setupscript.rst:578
#: ../Doc/distutils/setupscript.rst:585 ../Doc/distutils/setupscript.rst:601
msgid "short string"
msgstr "짧은 문자열"

#: ../Doc/distutils/setupscript.rst:569 ../Doc/distutils/setupscript.rst:583
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/distutils/setupscript.rst:571
msgid "``version``"
msgstr "``version``"

#: ../Doc/distutils/setupscript.rst:571
msgid "version of this release"
msgstr "이 릴리스의 버전"

#: ../Doc/distutils/setupscript.rst:571
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/distutils/setupscript.rst:573
msgid "``author``"
msgstr "``author``"

#: ../Doc/distutils/setupscript.rst:573
msgid "package author's name"
msgstr "패키지 저자의 이름"

#: ../Doc/distutils/setupscript.rst:573 ../Doc/distutils/setupscript.rst:575
#: ../Doc/distutils/setupscript.rst:578 ../Doc/distutils/setupscript.rst:580
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/distutils/setupscript.rst:575
msgid "``author_email``"
msgstr "``author_email``"

#: ../Doc/distutils/setupscript.rst:575
msgid "email address of the package author"
msgstr "패키지 저자의 이메일 주소"

#: ../Doc/distutils/setupscript.rst:575 ../Doc/distutils/setupscript.rst:580
msgid "email address"
msgstr "이메일 주소"

#: ../Doc/distutils/setupscript.rst:578
msgid "``maintainer``"
msgstr "``maintainer``"

#: ../Doc/distutils/setupscript.rst:578
msgid "package maintainer's name"
msgstr "패키지 관리자의 이름"

#: ../Doc/distutils/setupscript.rst:580
msgid "``maintainer_email``"
msgstr "``maintainer_email``"

#: ../Doc/distutils/setupscript.rst:580
msgid "email address of the package maintainer"
msgstr "패키지 관리자의 이메일 주소"

#: ../Doc/distutils/setupscript.rst:583
msgid "``url``"
msgstr "``url``"

#: ../Doc/distutils/setupscript.rst:583
msgid "home page for the package"
msgstr "패키지 홈페이지"

#: ../Doc/distutils/setupscript.rst:583 ../Doc/distutils/setupscript.rst:592
msgid "URL"
msgstr "URL"

#: ../Doc/distutils/setupscript.rst:585
msgid "``description``"
msgstr "``description``"

#: ../Doc/distutils/setupscript.rst:585
msgid "short, summary description of the package"
msgstr "패키지에 대한 짧은 요약 설명"

#: ../Doc/distutils/setupscript.rst:589
msgid "``long_description``"
msgstr "``long_description``"

#: ../Doc/distutils/setupscript.rst:589
msgid "longer description of the package"
msgstr "패키지에 대한 자세한 설명"

#: ../Doc/distutils/setupscript.rst:589
msgid "long string"
msgstr "긴 문자열"

#: ../Doc/distutils/setupscript.rst:589
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/distutils/setupscript.rst:592
msgid "``download_url``"
msgstr "``download_url``"

#: ../Doc/distutils/setupscript.rst:592
msgid "location where the package may be downloaded"
msgstr "패키지를 다운로드할 수 있는 위치"

#: ../Doc/distutils/setupscript.rst:595
msgid "``classifiers``"
msgstr "``classifiers``"

#: ../Doc/distutils/setupscript.rst:595
msgid "a list of classifiers"
msgstr "범주 목록"

#: ../Doc/distutils/setupscript.rst:595 ../Doc/distutils/setupscript.rst:597
#: ../Doc/distutils/setupscript.rst:599
msgid "list of strings"
msgstr "문자열의 리스트"

#: ../Doc/distutils/setupscript.rst:595
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/distutils/setupscript.rst:597
msgid "``platforms``"
msgstr "``platforms``"

#: ../Doc/distutils/setupscript.rst:597
msgid "a list of platforms"
msgstr "플랫폼 목록"

#: ../Doc/distutils/setupscript.rst:597 ../Doc/distutils/setupscript.rst:599
msgid "(6)(8)"
msgstr "(6)(8)"

#: ../Doc/distutils/setupscript.rst:599
msgid "``keywords``"
msgstr "``keywords``"

#: ../Doc/distutils/setupscript.rst:599
msgid "a list of keywords"
msgstr "키워드의 리스트"

#: ../Doc/distutils/setupscript.rst:601
msgid "``license``"
msgstr "``license``"

#: ../Doc/distutils/setupscript.rst:601
msgid "license for the package"
msgstr "패키지 라이선스"

#: ../Doc/distutils/setupscript.rst:601
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/distutils/setupscript.rst:604
msgid "Notes:"
msgstr "노트:"

#: ../Doc/distutils/setupscript.rst:607
msgid "These fields are required."
msgstr "이 필드는 필수입니다."

#: ../Doc/distutils/setupscript.rst:610
msgid "It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr "버전은 *major.minor[.patch[.sub]]* 형식을 사용하는 것이 좋습니다."

#: ../Doc/distutils/setupscript.rst:613
msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr ""
"author나 maintainer를 식별해야 합니다. maintainer가 제공되면, distutils는 이를 :file:`PKG-"
"INFO`\\에 저자로 나열합니다."

#: ../Doc/distutils/setupscript.rst:617
msgid ""
"The ``long_description`` field is used by PyPI when you publish a "
"package, to build its project page."
msgstr "``long_description`` 필드는 패키지를 게시할 때 PyPI에서 프로젝트 페이지를 빌드하는 데 사용됩니다."

#: ../Doc/distutils/setupscript.rst:621
msgid ""
"The ``license`` field is a text indicating the license covering the "
"package where the license is not a selection from the \"License\" Trove "
"classifiers. See the ``Classifier`` field. Notice that there's a "
"``licence`` distribution option which is deprecated but still acts as an "
"alias for ``license``."
msgstr ""
"``license`` 필드는 라이선스가 \"License\" Trove 분류에서 선택되지 않았을 때 패키지에 대한 라이선스를 "
"나타내는 텍스트입니다. ``Classifier`` 필드를 참조하십시오. 폐지되었지만 여전히 ``license``\\의 별칭으로 "
"작동하는 ``licence`` 배포 옵션이 있음에 유의하십시오."

#: ../Doc/distutils/setupscript.rst:628
msgid "This field must be a list."
msgstr "이 필드는 리스트여야 합니다."

#: ../Doc/distutils/setupscript.rst:631
msgid ""
"The valid classifiers are listed on `PyPI "
"<https://pypi.org/classifiers>`_."
msgstr "유효한 분류자는 `PyPI <https://pypi.org/classifiers>`_\\에 나열되어 있습니다."

#: ../Doc/distutils/setupscript.rst:635
msgid ""
"To preserve backward compatibility, this field also accepts a string. If "
"you pass a comma-separated string ``'foo, bar'``, it will be converted to"
" ``['foo', 'bar']``, Otherwise, it will be converted to a list of one "
"string."
msgstr ""
"이전 버전과의 호환성을 유지하기 위해, 이 필드는 문자열도 허용합니다. 쉼표로 구분된 문자열 ``'foo, bar'``\\를 "
"전달하면, ``['foo', 'bar']``\\로 변환되고, 그렇지 않으면, 하나의 문자열 리스트로 변환됩니다."

#: ../Doc/distutils/setupscript.rst:641
msgid "'short string'"
msgstr "'짧은 문자열'"

#: ../Doc/distutils/setupscript.rst:641
msgid "A single line of text, not more than 200 characters."
msgstr "한 줄의 텍스트, 200자 이하."

#: ../Doc/distutils/setupscript.rst:645
msgid "'long string'"
msgstr "'긴 문자열'"

#: ../Doc/distutils/setupscript.rst:644
msgid ""
"Multiple lines of plain text in reStructuredText format (see "
"http://docutils.sourceforge.net/)."
msgstr ""
"reStructuredText 형식의 여러 줄 단순 텍스트 (http://docutils.sourceforge.net/ 을 "
"참조하십시오)."

#: ../Doc/distutils/setupscript.rst:648
msgid "'list of strings'"
msgstr "'문자열의 리스트'"

#: ../Doc/distutils/setupscript.rst:648
msgid "See below."
msgstr "아래를 참조하십시오."

#: ../Doc/distutils/setupscript.rst:650
msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The "
"major number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. "
"The minor number is incremented when important new features are added to "
"the package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate "
"sub-releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release "
"release testing). Some examples:"
msgstr ""
"버전 정보를 인코딩하는 것은 그 자체로 기술입니다. 파이썬 패키지는 일반적으로 *major.minor[.patch][sub]* 버전"
" 형식을 따릅니다. 소프트웨어의 초기 실험 릴리스의 major 번호는 0입니다. 패키지의 주요 이정표를 나타내는 릴리스마다 "
"증가합니다. 중요한 새로운 기능이 패키지에 추가되면 minor 번호가 증가합니다. 버그 수정이 릴리스 되면 patch 번호가 "
"증가합니다. 서브 릴리스를 나타내는 데 추가 후행 버전 정보가 사용되기도 합니다. 이것들은 \"a1,a2,...,aN\" (기능과 "
"API가 변경될 수 있는 알파 릴리스의 경우), \"b1,b2,...,bN\" (버그만 수정하는 베타 릴리스의 경우) 및 "
"\"pr1,pr2,...,prN\" (최종 사전 릴리스 테스트 용) 입니다. 몇 가지 예:"

#: ../Doc/distutils/setupscript.rst:662
msgid "0.1.0"
msgstr "0.1.0"

#: ../Doc/distutils/setupscript.rst:662
msgid "the first, experimental release of a package"
msgstr "패키지의 첫 번째 실험 릴리스"

#: ../Doc/distutils/setupscript.rst:665
msgid "1.0.1a2"
msgstr "1.0.1a2"

#: ../Doc/distutils/setupscript.rst:665
msgid "the second alpha release of the first patch version of 1.0"
msgstr "1.0의 첫 번째 패치 버전의 두 번째 알파 릴리스"

#: ../Doc/distutils/setupscript.rst:667
msgid "``classifiers`` must be specified in a list::"
msgstr "``classifiers``\\는 리스트로 지정해야 합니다::"

#: ../Doc/distutils/setupscript.rst:688
msgid ""
":class:`~distutils.core.setup` now warns when ``classifiers``, "
"``keywords`` or ``platforms`` fields are not specified as a list or a "
"string."
msgstr ""
":class:`~distutils.core.setup`\\은 이제 ``classifiers``, ``keywords`` 또는 "
"``platforms`` 필드가 리스트나 문자열로 지정되지 않으면 경고합니다."

#: ../Doc/distutils/setupscript.rst:695
msgid "Debugging the setup script"
msgstr "설정 스크립트 디버깅하기"

#: ../Doc/distutils/setupscript.rst:697
msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr "때때로 문제가 발생하고, 설치 스크립트가 개발자가 원하는 것을 수행하지 않습니다."

#: ../Doc/distutils/setupscript.rst:700
msgid ""
"Distutils catches any exceptions when running the setup script, and print"
" a simple error message before the script is terminated.  The motivation "
"for this behaviour is to not confuse administrators who don't know much "
"about Python and are trying to install a package.  If they get a big long"
" traceback from deep inside the guts of Distutils, they may think the "
"package or the Python installation is broken because they don't read all "
"the way down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils는 설정 스크립트를 실행할 때 모든 예외를 포착하고, 스크립트가 종료되기 전에 간단한 에러 메시지를 인쇄합니다. 이"
" 동작의 동기는 파이썬에 대해 잘 모르고 패키지를 설치하려는 관리자를 혼동하지 않도록 하는 것입니다. Distutils의 "
"내부로부터의 크고 긴 트레이스백을 얻으면, 끝까지 읽어서 권한 문제라는 것을 알아차리지 못하고 패키지나 파이썬 설치가 손상되었다고 "
"생각할 수 있습니다."

#: ../Doc/distutils/setupscript.rst:708
msgid ""
"On the other hand, this doesn't help the developer to find the cause of "
"the failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils "
"will now print detailed information about what it is doing, dump the full"
" traceback when an exception occurs, and print the whole command line "
"when an external program (like a C compiler) fails."
msgstr ""
"반면에, 이것은 개발자가 실패의 원인을 찾는 데 도움이 되지 않습니다. 이를 위해, :envvar:`DISTUTILS_DEBUG` "
"환경 변수를 빈 문자열 이외의 것으로 설정할 수 있으며, distutils는 현재 수행 중인 작업에 대한 자세한 정보를 인쇄하고, "
"예외가 발생하면 전체 트레이스백을 덤프하며, 외부 프로그램(C 컴파일러와 같은)이 실패할 때 전체 명령 줄을 인쇄합니다."

