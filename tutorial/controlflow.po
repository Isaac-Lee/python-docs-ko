# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-10 11:28+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "기타 제어 흐름 도구"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:7
msgid ""
"Besides the :keyword:`while` statement just introduced, Python uses the "
"usual flow control statements known from other languages, with some "
"twists."
msgstr ""
"방금 소개한 :keyword:`while` 문 외에도, 파이썬은 다른 언어들에서 알려진 일반적인 흐름 제어문들을 사용하고, 나름의 "
"변형을 가하고 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:14
msgid ":keyword:`!if` Statements"
msgstr ":keyword:`!if` 문"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` "
"statement.  For example::"
msgstr "아마도 가장 잘 알려진 문장 형은 :keyword:`if` 문일 것입니다. 예를 들어::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if',"
" and is useful to avoid excessive indentation.  An  :keyword:`!if` ... "
":keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for "
"the ``switch`` or ``case`` statements found in other languages."
msgstr ""
"없거나 여러 개의 :keyword:`elif` 부가 있을 수 있고, :keyword:`else` 부는 선택적입니다. 키워드 "
"':keyword:`!elif`' 는 'else if' 의 줄임 표현인데, 과도한 들여쓰기를 피하는 데 유용합니다. "
":keyword:`!if` ... :keyword:`!elif` ... :keyword:`!elif` ... 시퀀스는 다른 "
"언어들에서 발견되는 ``switch`` 나 ``case`` 문을 대신합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:43
msgid ":keyword:`!for` Statements"
msgstr ":keyword:`!for` 문"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:48
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be"
" used to in C or Pascal.  Rather than always iterating over an arithmetic"
" progression of numbers (like in Pascal), or giving the user the ability "
"to define both the iteration step and halting condition (as C), Python's "
":keyword:`!for` statement iterates over the items of any sequence (a list"
" or a string), in the order that they appear in the sequence.  For "
"example (no pun intended):"
msgstr ""
"파이썬에서 :keyword:`for` 문은 C 나 파스칼에서 사용하던 것과 약간 다릅니다. (파스칼처럼) 항상 숫자의 산술적인 "
"진행을 통해 이터레이션 하거나, (C처럼) 사용자가 이터레이션 단계와 중지 조건을 정의할 수 있도록 하는 대신, 파이썬의 "
":keyword:`!for` 문은 임의의 시퀀스 (리스트나 문자열)의 항목들을 그 시퀀스에 들어있는 순서대로 이터레이션 합니다. "
"예를 들어 (말장난이 아니라):"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:69
msgid ""
"Code that modifies a collection while iterating over that same collection"
" can be tricky to get right.  Instead, it is usually more straight-"
"forward to loop over a copy of the collection or to create a new "
"collection::"
msgstr ""
"컬렉션을 이터레이트 하는 동안 같은 컬렉션을 수정하는 코드는 올바르게 동작하도록 만들기 힘듭니다. 대신, 보통 컬렉션의 복사본으로 "
"루프를 만들거나 새 컬렉션을 만드는 것이 더 간단합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:88
msgid "The :func:`range` Function"
msgstr ":func:`range` 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:90
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in "
"function :func:`range` comes in handy.  It generates arithmetic "
"progressions::"
msgstr "숫자들의 시퀀스로 이터레이트할 필요가 있으면, 내장 함수 :func:`range`\\가 편리합니다. 수열을 만듭니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:102
msgid ""
"The given end point is never part of the generated sequence; "
"``range(10)`` generates 10 values, the legal indices for items of a "
"sequence of length 10.  It is possible to let the range start at another "
"number, or to specify a different increment (even negative; sometimes "
"this is called the 'step')::"
msgstr ""
"끝값은 만들어지는 수열에 포함되지 않습니다; ``range(10)`` 은 10개의 값을 만드는데, 길이 10인 시퀀스의 항목들을 "
"가리키는 올바른 인덱스들입니다. 범위가 다른 숫자로 시작하거나, 다른 증가분을 (음수조차 가능합니다; 때로 이것을 "
"'스텝(step)'이라고 부릅니다) 지정하는 것도 가능합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:116
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr "시퀀스의 인덱스들로 이터레이트 하려면, 다음처럼 :func:`range`\\와 :func:`len` 을 결합할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:129
msgid ""
"In most such cases, however, it is convenient to use the "
":func:`enumerate` function, see :ref:`tut-loopidioms`."
msgstr ""
"하지만, 그럴 때 대부분은, :func:`enumerate` 함수를 쓰는 것이 편리합니다, :ref:`tut-loopidioms` "
"를 보세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:132
msgid "A strange thing happens if you just print a range::"
msgstr "범위를 그냥 인쇄하면 이상한 일이 일어납니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:137
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"많은 경우에 :func:`range`\\가 돌려준 객체는 리스트인 것처럼 동작하지만, 사실 리스트가 아닙니다. 이터레이트할 때 "
"원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 공간을 절약합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:142
msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target "
"for functions and constructs that expect something from which they can "
"obtain successive items until the supply is exhausted.  We have seen that"
" the :keyword:`for` statement is such a construct, while an example of a "
"function that takes an iterable is :func:`sum`::"
msgstr ""
"이런 객체를 :term:`이터러블 <iterable>` 이라고 부릅니다. 공급이 소진될 때까지 일련의 항목들을 얻을 수 있는 "
"무엇인가를 기대하는 함수와 구조물들의 타깃으로 적합합니다. 우리는 :keyword:`for` 문이 그런 구조물임을 보았습니다. "
"이터러블을 취하는 함수의 예는 :func:`sum`\\입니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:151
msgid ""
"Later we will see more functions that return iterables and take iterables"
" as arguments.  Lastly, maybe you are curious about how to get a list "
"from a range. Here is the solution::"
msgstr ""
"나중에 이터러블을 돌려주고 이터러블을 인자로 받는 함수들을 더 보게 됩니다. 마지막으로, range에서 리스트를 얻는 방법에 대해 "
"궁금할 것입니다. 이렇게 합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:158
msgid ""
"In chapter :ref:`tut-structures`, we will discuss in more detail about "
":func:`list`."
msgstr ":ref:`tut-structures` 장에서 :func:`list`\\에 대해 더 자세히 논의할 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:164
msgid ""
":keyword:`!break` and :keyword:`!continue` Statements, and "
":keyword:`!else` Clauses on Loops"
msgstr "루프의 :keyword:`!break` 와 :keyword:`!continue` 문, 그리고 :keyword:`!else` 절"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:166
msgid ""
"The :keyword:`break` statement, like in C, breaks out of the innermost "
"enclosing :keyword:`for` or :keyword:`while` loop."
msgstr ""
":keyword:`break` 문은, C처럼, 가장 가까이서 둘러싸는 :keyword:`for` 나 :keyword:`while` "
"루프로부터 빠져나가게 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:169
msgid ""
"Loop statements may have an :keyword:`!else` clause; it is executed when "
"the loop terminates through exhaustion of the iterable (with "
":keyword:`for`) or when the condition becomes false (with "
":keyword:`while`), but not when the loop is terminated by a "
":keyword:`break` statement.  This is exemplified by the following loop, "
"which searches for prime numbers::"
msgstr ""
"루프 문은 :keyword:`!else` 절을 가질 수 있습니다; 루프가 이터러블의 소진이나 (:keyword:`for`\\의 "
"경우) 조건이 거짓이 돼서 (:keyword:`while`\\의 경우) 종료할 때 실행됩니다. 하지만 루프가 "
":keyword:`break` 문으로 종료할 때는 실행되지 않습니다. 소수를 찾는 루프를 통해 다음에서 예시합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:193
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause "
"belongs to the :keyword:`for` loop, **not** the :keyword:`if` statement.)"
msgstr ""
"(이것은 올바른 코드입니다. 자세히 들여다보면: ``else`` 절은 :keyword:`if` 문이 **아니라** "
":keyword:`for` 루프에 속합니다.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:196
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of "
":keyword:`if` statements: a :keyword:`try` statement's ``else`` clause "
"runs when no exception occurs, and a loop's ``else`` clause runs when no "
"``break`` occurs. For more on the :keyword:`!try` statement and "
"exceptions, see :ref:`tut-handling`."
msgstr ""
"루프와 함께 사용될 때, ``else`` 절은 :keyword:`if` 문보다는 :keyword:`try` 문의 ``else`` "
"절과 비슷한 면이 많습니다: :keyword:`try` 문의 ``else`` 절은 예외가 발생하지 않을 때 실행되고, 루프의 "
"``else`` 절은 ``break``\\가 발생하지 않을 때 실행됩니다. :keyword:`!try` 문과 예외에 관한 자세한 "
"내용은 :ref:`tut-handling` 를 보세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:203
msgid ""
"The :keyword:`continue` statement, also borrowed from C, continues with "
"the next iteration of the loop::"
msgstr ":keyword:`continue` 문은, 역시 C에서 빌렸습니다, 루프의 다음 이터레이션에서 계속하도록 만듭니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:223
msgid ":keyword:`!pass` Statements"
msgstr ":keyword:`!pass` 문"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:225
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a "
"statement is required syntactically but the program requires no action. "
"For example::"
msgstr ""
":keyword:`pass` 문은 아무것도 하지 않습니다. 문법적으로 문장이 필요하지만, 프로그램이 특별히 할 일이 없을 때 사용할"
" 수 있습니다. 예를 들어::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:232
msgid "This is commonly used for creating minimal classes::"
msgstr "최소한의 클래스를 만들 때 흔히 사용됩니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:238
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing "
"you to keep thinking at a more abstract level.  The :keyword:`!pass` is "
"silently ignored::"
msgstr ""
":keyword:`pass`\\가 사용될 수 있는 다른 장소는 새 코드를 작업할 때 함수나 조건부 바디의 자리를 채우는 것인데, "
"여러분이 더 추상적인 수준에서 생각할 수 있게 합니다. :keyword:`!pass` 는 조용히 무시됩니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:249
msgid "Defining Functions"
msgstr "함수 정의하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:251
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary"
" boundary::"
msgstr "피보나치 수열을 임의의 한도까지 출력하는 함수를 만들 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:271
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must "
"be followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at "
"the next line, and must be indented."
msgstr ""
"키워드 :keyword:`def`\\는 함수 *정의*\\를 시작합니다. 함수 이름과 괄호로 싸인 형식 매개변수들의 목록이 "
"뒤따릅니다. 함수의 바디를 형성하는 문장들이 다음 줄에서 시작되고, 반드시 들여쓰기 되어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:276
msgid ""
"The first statement of the function body can optionally be a string "
"literal; this string literal is the function's documentation string, or "
":dfn:`docstring`. (More about docstrings can be found in the section :ref"
":`tut-docstrings`.) There are tools which use docstrings to automatically"
" produce online or printed documentation, or to let the user "
"interactively browse through code; it's good practice to include "
"docstrings in code that you write, so make a habit of it."
msgstr ""
"함수 바디의 첫 번째 문장은 선택적으로 문자열 리터럴이 될 수 있습니다; 이 문자열 리터럴은 함수의 도큐멘테이션 문자열, 즉 "
":dfn:`독스트링 (docstring)` 입니다. (독스트링에 대한 자세한 내용은 :ref:`tut-docstrings` 에 "
"나옵니다.) 독스트링을 사용해서 온라인이나 인쇄된 설명서를 자동 생성하거나, 사용자들이 대화형으로 코드를 열람할 수 있도록 하는 "
"도구들이 있습니다; 여러분이 작성하는 코드에 독스트링을 첨부하는 것은 좋은 관습입니다, 그러니 버릇을 들이는 것이 좋습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:283
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable "
"assignments in a function store the value in the local symbol table; "
"whereas variable references first look in the local symbol table, then in"
" the local symbol tables of enclosing functions, then in the global "
"symbol table, and finally in the table of built-in names. Thus, global "
"variables and variables of enclosing functions cannot be directly "
"assigned a value within a function (unless, for global variables, named "
"in a :keyword:`global` statement, or, for variables of enclosing "
"functions, named in a :keyword:`nonlocal` statement), although they may "
"be referenced."
msgstr ""
"함수의 *실행*\\은 함수의 지역 변수들을 위한 새 심볼 테이블을 만듭니다. 좀 더 구체적으로, 함수에서의 모든 변수 대입들은 값을"
" 지역 심볼 테이블에 저장합니다; 반면에 변수 참조는 먼저 지역 심볼 테이블을 본 다음, 전역 심볼 테이블을 본 후, 마지막으로 "
"내장 이름들의 테이블을 살핍니다. 그래서, 참조될 수는 있다 하더라도, 전역 변수들과 둘러싸는 함수의 변수들은 함수 내에서 직접 "
"값이 대입될 수 없습니다 (전역 변수를 :keyword:`global` 문으로 명시하거나 둘러싸는 함수의 변수를 "
":keyword:`nonlocal` 문으로 명시하지 않는 이상)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:294
msgid ""
"The actual parameters (arguments) to a function call are introduced in "
"the local symbol table of the called function when it is called; thus, "
"arguments are passed using *call by value* (where the *value* is always "
"an object *reference*, not the value of the object). [#]_ When a function"
" calls another function, a new local symbol table is created for that "
"call."
msgstr ""
"함수 호출로 전달되는 실제 매개변수들 (인자들)은 호출될 때 호출되는 함수의 지역 심볼 테이블에 만들어집니다; 그래서 인자들은 "
"*값에 의한 호출(call by value)*\\로 전달됩니다 (*값*\\은 항상 객체의 값이 아니라 객체 *참조*\\입니다). "
"[#]_ 함수가 다른 함수를 호출할 때, 그 호출을 위한 새 지역 심볼 테이블이 만들어집니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:300
msgid ""
"A function definition associates the function name with the function "
"object in the current symbol table.  The interpreter recognizes the "
"object pointed to by that name as a user-defined function.  Other names "
"can also point to that same function object and can also be used to "
"access the function::"
msgstr ""
"함수 정의는 함수 이름을 현재 심볼 테이블의 함수 객체와 연결합니다. 인터프리터는 해당 이름이 가리키는 객체를 사용자 정의 함수로 "
"인식합니다. 다른 이름은 같은 함수 객체를 가리킬 수 있으며 함수에 액세스하는 데 사용될 수도 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:311
msgid ""
"Coming from other languages, you might object that ``fib`` is not a "
"function but a procedure since it doesn't return a value.  In fact, even "
"functions without a :keyword:`return` statement do return a value, albeit"
" a rather boring one.  This value is called ``None`` (it's a built-in "
"name).  Writing the value ``None`` is normally suppressed by the "
"interpreter if it would be the only value written. You can see it if you "
"really want to using :func:`print`::"
msgstr ""
"다른 언어들을 사용했다면, ``fib`` 가 값을 돌려주지 않기 때문에 함수가 아니라 프로시저라고 생각할 수 있습니다. 사실, "
":keyword:`return` 문이 없는 함수도 값을 돌려줍니다, 비록 따분한 값이기는 하지만. 이 값은 ``None``\\이라고"
" 불립니다 (내장 이름입니다). ``None`` 이 출력할 유일한 값이라면, 인터프리터는 보통 ``None`` 값 출력을 "
"억제합니다. 꼭 보길 원한다면 :func:`print`\\를 사용할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:322
msgid ""
"It is simple to write a function that returns a list of the numbers of "
"the Fibonacci series, instead of printing it::"
msgstr "인쇄하는 대신, 피보나치 수열의 숫자들 리스트를 돌려주는 함수를 작성하는 것도 간단합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:338
msgid "This example, as usual, demonstrates some new Python features:"
msgstr "여느 때처럼, 이 예는 몇 가지 새 파이썬 기능을 보여줍니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:340
msgid ""
"The :keyword:`return` statement returns with a value from a function. "
":keyword:`!return` without an expression argument returns ``None``. "
"Falling off the end of a function also returns ``None``."
msgstr ""
":keyword:`return` 문은 함수로부터 값을 갖고 복귀하게 만듭니다. 표현식 인자 없는 :keyword:`!return` "
"은 ``None``\\을 돌려줍니다. 함수의 끝으로 떨어지면 역시 ``None``\\을 돌려줍니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:344
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is "
"named ``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined "
"by the object's type. Different types define different methods.  Methods "
"of different types may have the same name without causing ambiguity.  (It"
" is possible to define your own object types and methods, using "
"*classes*, see :ref:`tut-classes`) The method :meth:`append` shown in the"
" example is defined for list objects; it adds a new element at the end of"
" the list.  In this example it is equivalent to ``result = result + "
"[a]``, but more efficient."
msgstr ""
"문장 ``result.append(a)`` 은 리스트 객체 ``result``\\의 *메서드*\\를 호출합니다. 메서드는 객체에 "
"'속하는' 함수이고 ``obj.methodname`` 라고 이름 붙여지는데, ``obj``\\는 어떤 객체이고 (표현식이 될 수 "
"있습니다), ``methodname`` 는 객체의 형에 의해 정의된 메서드의 이름입니다. 다른 형은 다른 메서드들을 정의합니다. "
"서로 다른 형들의 메서드는 모호함 없이 같은 이름을 가질 수 있습니다. (*클래스*\\를 사용해서 여러분 자신의 형과 메서드를 "
"정의하는 것이 가능합니다, :ref:`tut-classes`\\를 보세요) 예에 나오는 메서드 :meth:`append`\\는 "
"리스트 객체들에 정의되어 있습니다; 요소를 리스트의 끝에 덧붙입니다. 이 예에서는 ``result = result + [a]`` 와"
" 동등하지만, 더 효율적입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:359
msgid "More on Defining Functions"
msgstr "함수 정의 더 보기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:361
msgid ""
"It is also possible to define functions with a variable number of "
"arguments. There are three forms, which can be combined."
msgstr "정해지지 않은 개수의 인자들로 함수를 정의하는 것도 가능합니다. 세 가지 형식이 있는데, 조합할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:368
msgid "Default Argument Values"
msgstr "기본 인자 값"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:370
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer "
"arguments than it is defined to allow.  For example::"
msgstr ""
"가장 쓸모 있는 형식은 하나나 그 이상 인자들의 기본값을 지정하는 것입니다. 정의된 것보다 더 적은 개수의 인자들로 호출될 수 있는"
" 함수를 만듭니다. 예를 들어::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:386
msgid "This function can be called in several ways:"
msgstr "이 함수는 여러 가지 방법으로 호출될 수 있습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:388
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to "
"quit?')``"
msgstr "오직 꼭 필요한 인자만 전달해서: ``ask_ok('정말 끝내길 원하세요?')``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:390
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the "
"file?', 2)``"
msgstr "선택적 인자 하나를 제공해서: ``ask_ok('파일을 덮어써도 좋습니까?', 2)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:392
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``"
msgstr "또는 모든 인자를 제공해서: ``ask_ok('파일을 덮어써도 좋습니까?', 2, '자, 예나 아니요로만 답하세요!')``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:395
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests "
"whether or not a sequence contains a certain value."
msgstr "이 예는 :keyword:`in` 키워드도 소개하고 있습니다. 시퀀스가 어떤 값을 가졌는지 아닌지를 검사합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:398
msgid ""
"The default values are evaluated at the point of function definition in "
"the *defining* scope, so that ::"
msgstr "기본값은 함수 정의 시점에 *정의되고 있는* 스코프에서 구해집니다, 그래서 ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:409
msgid "will print ``5``."
msgstr "는 ``5``\\를 인쇄합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:411
msgid ""
"**Important warning:**  The default value is evaluated only once. This "
"makes a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**중요한 주의사항:** 기본값은 오직 한 번만 값이 구해집니다. 이것은 기본값이 리스트나 딕셔너리나 대부분 클래스의 인스턴스와 "
"같은 가변 객체일 때 차이를 만듭니다. 예를 들어, 다음 함수는 계속되는 호출로 전달된 인자들을 누적합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:424
msgid "This will print ::"
msgstr "다음과 같은 것을 인쇄합니다 ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:430
msgid ""
"If you don't want the default to be shared between subsequent calls, you "
"can write the function like this instead::"
msgstr "연속된 호출 간에 기본값이 공유되지 않기를 원한다면, 대신 함수를 이런 식으로 쓸 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:443
msgid "Keyword Arguments"
msgstr "키워드 인자"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:445
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"함수는 ``kwarg=value`` 형식의 :term:`키워드 인자 <keyword argument>` 를 사용해서 호출될 수 "
"있습니다. 예를 들어, 다음 함수는::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:454
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in "
"any of the following ways::"
msgstr ""
"하나의 필수 인자(``voltage``)와 세 개의 선택적 인자 (``state``, ``action``, ``type``) 를 "
"받아들입니다. 이 함수는 다음과 같은 방법 중 아무것으로나 호출될 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:465
msgid "but all the following calls would be invalid::"
msgstr "하지만 다음과 같은 호출들은 모두 올바르지 않습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:472
msgid ""
"In a function call, keyword arguments must follow positional arguments. "
"All the keyword arguments passed must match one of the arguments accepted"
" by the function (e.g. ``actor`` is not a valid argument for the "
"``parrot`` function), and their order is not important.  This also "
"includes non-optional arguments (e.g. ``parrot(voltage=1000)`` is valid "
"too). No argument may receive a value more than once. Here's an example "
"that fails due to this restriction::"
msgstr ""
"함수 호출에서, 키워드 인자는 위치 인자 뒤에 나와야 합니다. 전달된 모든 키워드 인자는 함수가 받아들이는 인자 중 하나와 맞아야 "
"하며 (예를 들어, ``actor``\\는 ``parrot`` 함수의 올바른 인자가 아니다), 그 순서는 중요하지 않습니다. "
"이것들에는 필수 인자들도 포함됩니다 (예를 들어, ``parrot(voltage=1000)`` 도 올바릅니다). 어떤 인자도 두 개"
" 이상의 값을 받을 수 없습니다. 여기, 이 제약 때문에 실패하는 예가 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:488
msgid ""
"When a final formal parameter of the form ``**name`` is present, it "
"receives a dictionary (see :ref:`typesmapping`) containing all keyword "
"arguments except for those corresponding to a formal parameter.  This may"
" be combined with a formal parameter of the form ``*name`` (described in "
"the next subsection) which receives a :ref:`tuple <tut-tuples>` "
"containing the positional arguments beyond the formal parameter list.  "
"(``*name`` must occur before ``**name``.) For example, if we define a "
"function like this::"
msgstr ""
"``**name`` 형식의 마지막 형식 매개변수가 존재하면, 형식 매개변수들에 대응하지 않는 모든 키워드 인자들을 담은 딕셔너리 "
"(:ref:`typesmapping` 를 보세요) 를 받습니다. 이것은 ``*name`` (다음 서브섹션에서 설명합니다) 형식의 "
"형식 매개변수와 조합될 수 있는데, 형식 매개변수 목록 밖의 위치 인자들을 담은 :ref:`튜플 <tut-tuples>`\\을 "
"받습니다. (``*name``\\은 ``**name`` 앞에 나와야 합니다.) 예를 들어, 이런 함수를 정의하면::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:505
msgid "It could be called like this::"
msgstr "이런 식으로 호출될 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:513
msgid "and of course it would print:"
msgstr "그리고 당연히 이렇게 인쇄합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:526
msgid ""
"Note that the order in which the keyword arguments are printed is "
"guaranteed to match the order in which they were provided in the function"
" call."
msgstr "인쇄되는 키워드 인자들의 순서 함수 호출로 전달된 순서와 일치함이 보장됨에 주목하세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:530
msgid "Special parameters"
msgstr "특수 매개 변수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:532
msgid ""
"By default, arguments may be passed to a Python function either by "
"position or explicitly by keyword. For readability and performance, it "
"makes sense to restrict the way arguments can be passed so that a "
"developer need only look at the function definition to determine if items"
" are passed by position, by position or keyword, or by keyword."
msgstr ""
"기본적으로, 인자는 위치나 명시적인 키워드로 파이썬 함수에 전달될 수 있습니다. 가독성과 성능을 위해, 개발자가 항목이 위치, "
"위치나 키워드 또는 키워드로 전달되는지를 판단할 때 함수 정의만을 보면 되도록, 인자가 전달될 방법을 제한하면 좋습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:538
msgid "A function definition may look like:"
msgstr "함수 정의는 다음과 같습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:549
msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the "
"kind of parameter by how the arguments may be passed to the function: "
"positional-only, positional-or-keyword, and keyword-only. Keyword "
"parameters are also referred to as named parameters."
msgstr ""
"여기서 ``/``\\와 ``*``\\는 선택적입니다. 사용하면, 이 기호는 인자가 함수에 전달되는 방식에 따른 매개 변수의 종류를 "
"나타냅니다: 위치 전용, 위치-키워드 및 키워드 전용. 키워드 매개 변수는 명명된(named) 매개 변수라고도 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:556
msgid "Positional-or-Keyword Arguments"
msgstr "위치-키워드(Positional-or-Keyword) 인자"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:558
msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments "
"may be passed to a function by position or by keyword."
msgstr "함수 정의에 ``/``\\와 ``*``\\가 없으면, 인자를 위치나 키워드로 함수에 전달할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:563
msgid "Positional-Only Parameters"
msgstr "위치 전용 매개 변수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:565
msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' "
"order matters, and the parameters cannot be passed by keyword. "
"Positional-only parameters are placed before a ``/`` (forward-slash). The"
" ``/`` is used to logically separate the positional-only parameters from "
"the rest of the parameters. If there is no ``/`` in the function "
"definition, there are no positional-only parameters."
msgstr ""
"좀 더 자세하게 살펴보면, 특정 매개 변수를 *위치 전용*\\으로 표시할 수 있습니다. *위치 전용*\\이면, 매개 변수의 순서가 "
"중요하며, 키워드로 매개 변수를 전달할 수 없습니다. 위치 전용 매개 변수는 ``/`` (슬래시) 앞에 놓입니다. ``/``\\는 "
"위치 전용 매개 변수를 나머지 매개 변수들로부터 논리적으로 분리하는 데 사용됩니다. 함수 정의에 ``/``\\가 없으면, 위치 전용"
" 매개 변수는 없습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:573
msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or "
"*keyword-only*."
msgstr "``/`` 다음의 매개 변수는 *위치-키워드*\\나 *키워드 전용*\\일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:577
msgid "Keyword-Only Arguments"
msgstr "키워드 전용 인자"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:579
msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just "
"before the first *keyword-only* parameter."
msgstr ""
"매개 변수를 키워드 인자로 전달해야 함을 나타내도록, 매개 변수를 *키워드 전용*\\으로 표시하려면, 첫 번째 *키워드 전용* 매개"
" 변수 바로 전에 인자 목록에 ``*``\\를 넣으십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:585
msgid "Function Examples"
msgstr "함수 예제"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:587
msgid ""
"Consider the following example function definitions paying close "
"attention to the markers ``/`` and ``*``::"
msgstr "``/``\\와 ``*`` 마커에 주의를 기울이는 다음 예제 함수 정의를 고려하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:603
msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be "
"passed by position or keyword::"
msgstr ""
"첫 번째 함수 정의 ``standard_arg``\\는 가장 익숙한 형식으로, 호출 규칙에 아무런 제한을 두지 않으며 인자는 위치나"
" 키워드로 전달될 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:613
msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional"
" parameters as there is a ``/`` in the function definition::"
msgstr "두 번째 함수 ``pos_only_arg``\\는 함수 정의에 ``/``\\가 있으므로 위치 매개 변수만 사용하도록 제한됩니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:624
msgid ""
"The third function ``kwd_only_args`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr "세 번째 함수 ``kwd_only_args``\\는 함수 정의에서 ``*``\\로 표시된 키워드 인자만 허용합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:635
msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr "마지막은 같은 함수 정의에서 세 가지 호출 규칙을 모두 사용합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:655
msgid ""
"Finally, consider this function definition which has a potential "
"collision between the positional argument ``name``  and ``**kwds`` which "
"has ``name`` as a key::"
msgstr ""
"마지막으로, 위치 인자 ``name``\\과 ``name``\\을 키로 가지는 ``**kwds`` 사이에 잠재적인 충돌이 있는 이 "
"함수 정의를 고려하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:660
msgid ""
"There is no possible call that will make it return ``True`` as the "
"keyword ``'name'`` will always to bind to the first parameter. For "
"example::"
msgstr ""
"``'name'`` 키워드는 항상 첫 번째 매개 변수에 결합하므로 ``True``\\를 반환할 수 있는 호출은 불가능합니다. 예를 "
"들면::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:669
msgid ""
"But using ``/`` (positional only arguments), it is possible since it "
"allows ``name`` as a positional argument and ``'name'`` as a key in the "
"keyword arguments::"
msgstr ""
"그러나 ``/``\\(위치 전용 인자)를 사용하면, ``name``\\을 위치 인자로, 동시에 ``'name'``\\을 키워드 "
"인자의 키로 사용할 수 있으므로 가능합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:676
msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr "즉, 위치 전용 매개 변수의 이름을 ``**kwds``\\에서 모호함 없이 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:681
msgid "Recap"
msgstr "복습"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:683
msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr "사용 사례가 함수 정의에서 어떤 매개 변수를 사용할지 결정합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:687
msgid "As guidance:"
msgstr "지침으로서:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:689
msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the "
"function is called or if you need to take some positional parameters and "
"arbitrary keywords."
msgstr ""
"매개 변수의 이름을 사용자가 사용할 수 없도록 하려면 위치 전용을 사용하십시오. 매개 변수 이름이 실제 의미가 없을 때, 함수가 "
"호출될 때 인자의 순서를 강제하려고 할 때, 또는 일부 위치 매개 변수와 임의의 키워드를 받아들이고 싶을 때 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:694
msgid ""
"Use keyword-only when names have meaning and the function definition is "
"more understandable by being explicit with names or you want to prevent "
"users relying on the position of the argument being passed."
msgstr ""
"이름이 의미가 있고 함수 정의가 이름을 명시적으로 지정함으로써 더 이해하기 쉬워지거나, 사용자가 전달되는 인자의 위치에 의존하지 "
"못하도록 하려면 키워드 전용을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:697
msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr "API의 경우, 향후 매개 변수의 이름이 수정될 때 비호환 API 변경이 발생하는 것을 방지하려면 위치 전용을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:703
msgid "Arbitrary Argument Lists"
msgstr "임의의 인자 목록"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:708
msgid ""
"Finally, the least frequently used option is to specify that a function "
"can be called with an arbitrary number of arguments.  These arguments "
"will be wrapped up in a tuple (see :ref:`tut-tuples`).  Before the "
"variable number of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"마지막으로, 가장 덜 사용되는 옵션은 함수가 임의의 개수 인자로 호출될 수 있도록 지정하는 것입니다. 이 인자들은 튜플로 묶입니다 "
"(:ref:`tut-tuples` 을 보세요). 가변 길이 인자 앞에, 없거나 여러 개의 일반 인자들이 올 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:717
msgid ""
"Normally, these ``variadic`` arguments will be last in the list of formal"
" parameters, because they scoop up all remaining input arguments that are"
" passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can "
"only be used as keywords rather than positional arguments. ::"
msgstr ""
"보통, 이 ``가변 길이`` 인자들은 형식 매개변수 목록의 마지막에 옵니다, 함수로 전달된 남은 입력 인자들 전부를 그러모으기 "
"때문입니다. ``*args`` 매개변수 뒤에 등장하는 형식 매개변수들은 모두 '키워드-전용' 인자들인데, 위치 인자 대신 키워드 "
"인자로만 사용될 수 있다는 뜻입니다. ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:734
msgid "Unpacking Argument Lists"
msgstr "인자 목록 언 패킹"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:736
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available"
" separately, write the function call with the  ``*``\\ -operator to "
"unpack the arguments out of a list or tuple::"
msgstr ""
"인자들이 이미 리스트나 튜플에 있지만, 분리된 위치 인자들을 요구하는 함수 호출을 위해 언 패킹 해야 하는 경우 반대 상황이 "
"벌어집니다. 예를 들어, 내장 :func:`range` 함수는 별도의 *start*\\와 *stop* 인자를 기대합니다. 그것들이 "
"따로 있지 않으면, 리스트와 튜플로부터 인자를 언 패킹하기 위해 ``*``\\ -연산자를 사용해서 함수를 호출하면 됩니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:752
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr "같은 방식으로 딕셔너리도 ``**``\\ -연산자를 써서 키워드 인자를 전달할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:768
msgid "Lambda Expressions"
msgstr "람다 표현식"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:770
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` "
"keyword. This function returns the sum of its two arguments: ``lambda a, "
"b: a+b``. Lambda functions can be used wherever function objects are "
"required.  They are syntactically restricted to a single expression.  "
"Semantically, they are just syntactic sugar for a normal function "
"definition.  Like nested function definitions, lambda functions can "
"reference variables from the containing scope::"
msgstr ""
":keyword:`lambda` 키워드들 사용해서 작고 이름 없는 함수를 만들 수 있습니다. 이 함수는 두 인자의 합을 돌려줍니다:"
" ``lambda a, b: a+b``. 함수 객체가 있어야 하는 곳이면 어디나 람다 함수가 사용될 수 있습니다. 문법적으로는 "
"하나의 표현식으로 제한됩니다. 의미적으로는, 일반적인 함수 정의의 편의 문법일 뿐입니다. 중첩된 함수 정의처럼, 람다 함수는 "
"둘러싸는 스코프에 있는 변수들을 참조할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:787
msgid ""
"The above example uses a lambda expression to return a function.  Another"
" use is to pass a small function as an argument::"
msgstr "위의 예는 함수를 돌려주기 위해 람다 표현식을 사용합니다. 또 다른 용도는 작은 함수를 인자로 전달하는 것입니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:799
msgid "Documentation Strings"
msgstr "도큐멘테이션 문자열"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:806
msgid ""
"Here are some conventions about the content and formatting of "
"documentation strings."
msgstr "여기에 도큐멘테이션 문자열의 내용과 포매팅에 관한 몇 가지 관례가 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:809
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name "
"or type, since these are available by other means (except if the name "
"happens to be a verb describing a function's operation).  This line "
"should begin with a capital letter and end with a period."
msgstr ""
"첫 줄은 항상 객체의 목적을 짧고, 간결하게 요약해야 합니다. 간결함을 위해, 객체의 이름이나 형을 명시적으로 언급하지 않아야 "
"하는데, 이것들은 다른 방법으로 제공되기 때문입니다 (이름이 함수의 작업을 설명하는 동사라면 예외입니다). 이 줄은 대문자로 "
"시작하고 마침표로 끝나야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:815
msgid ""
"If there are more lines in the documentation string, the second line "
"should be blank, visually separating the summary from the rest of the "
"description.  The following lines should be one or more paragraphs "
"describing the object's calling conventions, its side effects, etc."
msgstr ""
"도큐멘테이션 문자열에 여러 줄이 있다면, 두 번째 줄은 비어있어서, 시각적으로 요약과 나머지 설명을 분리해야 합니다. 뒤따르는 "
"줄들은 하나나 그 이상의 문단으로, 객체의 호출 규약, 부작용 등을 설명해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:820
msgid ""
"The Python parser does not strip indentation from multi-line string "
"literals in Python, so tools that process documentation have to strip "
"indentation if desired.  This is done using the following convention. The"
" first non-blank line *after* the first line of the string determines the"
" amount of indentation for the entire documentation string.  (We can't "
"use the first line since it is generally adjacent to the string's opening"
" quotes so its indentation is not apparent in the string literal.)  "
"Whitespace \"equivalent\" to this indentation is then stripped from the "
"start of all lines of the string.  Lines that are indented less should "
"not occur, but if they occur all their leading whitespace should be "
"stripped.  Equivalence of whitespace should be tested after expansion of "
"tabs (to 8 spaces, normally)."
msgstr ""
"파이썬 파서는 여러 줄 문자열 리터럴에서 들여쓰기를 제거하지 않기 때문에, 설명서를 처리하는 도구들은 필요하면 들여쓰기를 "
"제거합니다. 이것은 다음과 같은 관례를 사용합니다. 문자열의 첫줄 *뒤에 오는* 첫 번째 비어있지 않은 줄이 전체 도튜멘테이션 "
"문자열의 들여쓰기 수준을 결정합니다. (우리는 첫 줄을 사용할 수 없는데, 일반적으로 문자열을 시작하는 따옴표에 붙어있어서 "
"들여쓰기가 문자열 리터럴의 것을 반영하지 않기 때문입니다.) 이 들여쓰기와 \"동등한\" 공백이 문자열의 모든 줄의 시작 부분에서 "
"제거됩니다. 덜 들여쓰기 된 줄이 나타나지는 말아야 하지만, 나타난다면 모든 앞부분의 공백이 제거됩니다. 공백의 동등성은 탭 확장 "
"(보통 8개의 스페이스) 후에 검사됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:832
msgid "Here is an example of a multi-line docstring::"
msgstr "여기 여러 줄 독스트링의 예가 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:850
msgid "Function Annotations"
msgstr "함수 어노테이션"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:858
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see "
":pep:`3107` and :pep:`484` for more information)."
msgstr ""
":ref:`함수 어노테이션 <function>` 은 사용자 정의 함수가 사용하는 형들에 대한 완전히 선택적인 메타데이터 정보입니다 "
"(자세한 내용은 :pep:`3107` 과 :pep:`484` 를 보세요)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:862
msgid ""
":term:`Annotations <function annotation>` are stored in the "
":attr:`__annotations__` attribute of the function as a dictionary and "
"have no effect on any other part of the function.  Parameter annotations "
"are defined by a colon after the parameter name, followed by an "
"expression evaluating to the value of the annotation.  Return annotations"
" are defined by a literal ``->``, followed by an expression, between the "
"parameter list and the colon denoting the end of the :keyword:`def` "
"statement.  The following example has a positional argument, a keyword "
"argument, and the return value annotated::"
msgstr ""
":term:`어노테이션 <function annotation>`\\은 함수의 :attr:`__annotations__` 어트리뷰트에"
" 딕셔너리로 저장되고 함수의 다른 부분에는 아무런 영향을 미치지 않습니다. 매개변수 어노테이션은 매개변수 이름 뒤에 오는 콜론으로 "
"정의되는데, 값을 구할 때 어노테이션의 값을 주는 표현식이 뒤따릅니다. 반환 값 어노테이션은 리터럴 ``->`` 와 그 뒤를 따르는"
" 표현식으로 정의되는데, 매개변수 목록과 :keyword:`def` 문의 끝을 나타내는 콜론 사이에 놓입니다. 다음 예에서 위치 "
"인자, 키워드 인자, 반환 값이 어노테이트 됩니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:884
msgid "Intermezzo: Coding Style"
msgstr "막간극: 코딩 스타일"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:889
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it"
" is a good time to talk about *coding style*.  Most languages can be "
"written (or more concise, *formatted*) in different styles; some are more"
" readable than others. Making it easy for others to read your code is "
"always a good idea, and adopting a nice coding style helps tremendously "
"for that."
msgstr ""
"이제 여러분은 파이썬의 더 길고, 더 복잡한 조각들을 작성하려고 합니다, *코딩 스타일*\\에 대해 말할 적절한 시간입니다. 대부분"
" 언어는 서로 다른 스타일로 작성될 (또는 더 간략하게, *포맷될*) 수 있습니다; 어떤 것들은 다른 것들보다 더 읽기 쉽습니다. "
"다른 사람들이 여러분의 코드를 읽기 쉽게 만드는 것은 항상 좋은 생각이고, 훌륭한 코딩 스타일을 도입하는 것은 그렇게 하는 데 큰 "
"도움을 줍니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:895
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  "
"Every Python developer should read it at some point; here are the most "
"important points extracted for you:"
msgstr ""
"파이썬을 위해, 대부분 프로젝트가 고수하는 스타일 가이드로 :pep:`8`\\이 나왔습니다; 이것은 매우 읽기 쉽고 눈이 편안한 "
"코딩 스타일을 장려합니다. 모든 파이썬 개발자는 언젠가는 이 문서를 읽어야 합니다; 여러분을 위해 가장 중요한 부분들을 "
"추려봤습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:900
msgid "Use 4-space indentation, and no tabs."
msgstr "들려 쓰기에 4-스페이스를 사용하고, 탭을 사용하지 마세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:902
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"4개의 스페이스는 작은 들여쓰기 (더 많은 중첩 도를 허락합니다) 와 큰 들여쓰기 (읽기 쉽습니다) 사이의 좋은 절충입니다. 탭은 "
"혼란을 일으키고, 없애는 것이 최선입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:906
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr "79자를 넘지 않도록 줄 넘김 하세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:908
msgid ""
"This helps users with small displays and makes it possible to have "
"several code files side-by-side on larger displays."
msgstr "이것은 작은 화면을 가진 사용자를 돕고 큰 화면에서는 여러 코드 파일들을 나란히 볼 수 있게 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:911
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of "
"code inside functions."
msgstr "함수, 클래스, 함수 내의 큰 코드 블록 사이에 빈 줄을 넣어 분리하세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:914
msgid "When possible, put comments on a line of their own."
msgstr "가능하다면, 주석은 별도의 줄로 넣으세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:916
msgid "Use docstrings."
msgstr "독스트링을 사용하세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:918
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"연산자들 주변과 콤마 뒤에 스페이스를 넣고, 괄호 바로 안쪽에는 스페이스를 넣지 마세요: ``a = f(1, 2) + g(3, "
"4)``."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:921
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first "
"method argument (see :ref:`tut-firstclasses` for more on classes and "
"methods)."
msgstr ""
"클래스와 함수들에 일관성 있는 이름을 붙이세요; 관례는 클래스의 경우 ``UpperCamelCase``, 함수와 메서드의 경우 "
"``lowercase_with_underscores``\\입니다. 첫 번째 메서드 인자의 이름으로는 항상 ``self``\\를 "
"사용하세요 (클래스와 메서드에 대한 자세한 내용은 :ref:`tut-firstclasses` 을 보세요)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:926
msgid ""
"Don't use fancy encodings if your code is meant to be used in "
"international environments.  Python's default, UTF-8, or even plain ASCII"
" work best in any case."
msgstr ""
"여러분의 코드를 국제적인 환경에서 사용하려고 한다면 특별한 인코딩을 사용하지 마세요. 어떤 경우에도 파이썬의 기본, UTF-8, "
"또는 단순 ASCII조차, 이 최선입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:930
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only "
"the slightest chance people speaking a different language will read or "
"maintain the code."
msgstr ""
"마찬가지로, 다른 언어를 사용하는 사람이 코드를 읽거나 유지할 약간의 가능성만 있더라도, 식별자에 ASCII 이외의 문자를 사용하지"
" 마세요."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:936
msgid "Footnotes"
msgstr "각주"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/tutorial/controlflow.rst:937
msgid ""
"Actually, *call by object reference* would be a better description, since"
" if a mutable object is passed, the caller will see any changes the "
"callee makes to it (items inserted into a list)."
msgstr ""
"실제로, *객체 참조에 의한 호출 (call by object reference)* 이 더 좋은 표현인데, 가변 객체가 전달되면, "
"호출자는 피호출자가 만든 변경을 볼 수 있기 때문입니다 (가령 리스트에 항목을 추가합니다)."

