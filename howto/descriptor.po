# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-12 08:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr "디스크립터 사용법 안내서"

#: ../Doc/howto/descriptor.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../Doc/howto/descriptor.rst
msgid "Contact"
msgstr "연락처"

#: ../Doc/howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../Doc/howto/descriptor.rst:11
msgid "Contents"
msgstr "목차"

#: ../Doc/howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""

#: ../Doc/howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr ""

#: ../Doc/howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple "
"examples, adding one feature at a time.  Start here if you're new to "
"descriptors."
msgstr ""

#: ../Doc/howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If "
"you already know the basics, start there."
msgstr ""

#: ../Doc/howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""

#: ../Doc/howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors "
"that are written in C.  Read this if you're curious about how functions "
"turn into bound methods or about the implementation of common tools like "
":func:`classmethod`, :func:`staticmethod`, :func:`property`, and "
":term:`__slots__`."
msgstr ""

#: ../Doc/howto/descriptor.rst:36
msgid "Primer"
msgstr ""

#: ../Doc/howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then "
"we'll add new capabilities one by one."
msgstr ""

#: ../Doc/howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr ""

#: ../Doc/howto/descriptor.rst:45
msgid ""
"The :class:`Ten` class is a descriptor that always returns the constant "
"``10`` from its :meth:`__get__` method:"
msgstr ""

#: ../Doc/howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr ""

#: ../Doc/howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute "
"lookup and descriptor lookup:"
msgstr ""

#: ../Doc/howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds the key ``x`` and"
" the value ``5`` in the class dictionary.  In the ``a.y`` lookup, the dot"
" operator finds a descriptor instance, recognized by its ``__get__`` "
"method, and calls that method which returns ``10``."
msgstr ""

#: ../Doc/howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary "
"or the instance dictionary.  Instead, the value ``10`` is computed on "
"demand."
msgstr ""

#: ../Doc/howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very "
"useful. For retrieving constants, normal attribute lookup would be "
"better."
msgstr ""

#: ../Doc/howto/descriptor.rst:84
msgid "In the next section, we'll create something more useful, a dynamic lookup."
msgstr ""

#: ../Doc/howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr ""

#: ../Doc/howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""

#: ../Doc/howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""

#: ../Doc/howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter"
" is either *g* or *s*, an instance of *Directory*.  It is the *obj* "
"parameter that lets the :meth:`__get__` method learn the target "
"directory.  The *objtype* parameter is the class *Directory*."
msgstr ""

#: ../Doc/howto/descriptor.rst:131
msgid "Managed attributes"
msgstr ""

#: ../Doc/howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary "
"while the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods"
" are triggered when the public attribute is accessed."
msgstr ""

#: ../Doc/howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the"
" private attribute.  When the public attribute is accessed, the "
"descriptor logs the lookup or update:"
msgstr ""

#: ../Doc/howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute "
"*age* is logged, but that the regular attribute *name* is not logged:"
msgstr ""

#: ../Doc/howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance "
"can only have one logged attribute and that its name is unchangeable.  In"
" the next example, we'll fix that problem."
msgstr ""

#: ../Doc/howto/descriptor.rst:213
msgid "Customized names"
msgstr ""

#: ../Doc/howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""

#: ../Doc/howto/descriptor.rst:218
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field "
"names can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""

#: ../Doc/howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`Person` class has called "
":meth:`__set_name__` so that the field names would be recorded.  Here we "
"call :func:`vars` to look up the descriptor without triggering it:"
msgstr ""

#: ../Doc/howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr ""

#: ../Doc/howto/descriptor.rst:284
msgid "The two *Person* instances contain only the private names::"
msgstr ""

#: ../Doc/howto/descriptor.rst:293
msgid "Closing thoughts"
msgstr ""

#: ../Doc/howto/descriptor.rst:295
msgid ""
"A :term:`descriptor` is what we call any object that defines "
":meth:`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""

#: ../Doc/howto/descriptor.rst:298
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class "
"where it was created or the name of class variable it was assigned to.  "
"(This method, if present, is called even if the class is not a "
"descriptor.)"
msgstr ""

#: ../Doc/howto/descriptor.rst:303
msgid ""
"Descriptors get invoked by the dot \"operator\" during attribute lookup."
"  If a descriptor is accessed indirectly with "
"``vars(some_class)[descriptor_name]``, the descriptor instance is "
"returned without invoking it."
msgstr ""

#: ../Doc/howto/descriptor.rst:307
msgid ""
"Descriptors only work when used as class variables.  When put in "
"instances, they have no effect."
msgstr ""

#: ../Doc/howto/descriptor.rst:310
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects"
" stored in class variables to control what happens during attribute "
"lookup."
msgstr ""

#: ../Doc/howto/descriptor.rst:313
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up "
"to have a say in the matter."
msgstr ""

#: ../Doc/howto/descriptor.rst:317
msgid ""
"Descriptors are used throughout the language.  It is how functions turn "
"into bound methods.  Common tools like :func:`classmethod`, "
":func:`staticmethod`, :func:`property`, and "
":func:`functools.cached_property` are all implemented as descriptors."
msgstr ""

#: ../Doc/howto/descriptor.rst:324
msgid "Complete Practical Example"
msgstr ""

#: ../Doc/howto/descriptor.rst:326
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""

#: ../Doc/howto/descriptor.rst:331
msgid "Validator class"
msgstr ""

#: ../Doc/howto/descriptor.rst:333
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to "
"storing any data, it verifies that the new value meets various type and "
"range restrictions.  If those restrictions aren't met, it raises an "
"exception to prevent data corruption at its source."
msgstr ""

#: ../Doc/howto/descriptor.rst:338
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and "
"a managed attribute descriptor:"
msgstr ""

#: ../Doc/howto/descriptor.rst:361
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply"
" a :meth:`validate` method to test various restrictions as needed."
msgstr ""

#: ../Doc/howto/descriptor.rst:366
msgid "Custom validators"
msgstr ""

#: ../Doc/howto/descriptor.rst:368
msgid "Here are three practical data validation utilities:"
msgstr ""

#: ../Doc/howto/descriptor.rst:370
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of "
"options."
msgstr ""

#: ../Doc/howto/descriptor.rst:372
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or "
":class:`float`.  Optionally, it verifies that a value is between a given "
"minimum or maximum."
msgstr ""

#: ../Doc/howto/descriptor.rst:376
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-"
"defined `predicate "
"<https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ as well."
msgstr ""

#: ../Doc/howto/descriptor.rst:435
msgid "Practical application"
msgstr ""

#: ../Doc/howto/descriptor.rst:437
msgid "Here's how the data validators can be used in a real class:"
msgstr ""

#: ../Doc/howto/descriptor.rst:452
msgid "The descriptors prevent invalid instances from being created:"
msgstr ""

#: ../Doc/howto/descriptor.rst:479
msgid "Technical Tutorial"
msgstr ""

#: ../Doc/howto/descriptor.rst:481
msgid ""
"What follows is a more technical tutorial for the mechanics and details "
"of how descriptors work."
msgstr ""

#: ../Doc/howto/descriptor.rst:486
msgid "Abstract"
msgstr "요약"

#: ../Doc/howto/descriptor.rst:488
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors "
"are called.  Provides an example showing how object relational mappings "
"work."
msgstr ""

#: ../Doc/howto/descriptor.rst:491
#, fuzzy
msgid ""
"Learning about descriptors not only provides access to a larger toolset, "
"it creates a deeper understanding of how Python works."
msgstr ""
"디스크립터에 대한 학습은 더 큰 도구 집합에 대한 액세스를 제공할 뿐만 아니라, 파이썬의 작동 방식에 대한 심층적인 이해와 설계의 "
"우아함에 대한 감사를 만듭니다."

#: ../Doc/howto/descriptor.rst:496
#, fuzzy
msgid "Definition and introduction"
msgstr "정의와 소개"

#: ../Doc/howto/descriptor.rst:498
msgid ""
"In general, a descriptor is an attribute value that has one of the "
"methods in the descriptor protocol.  Those methods are :meth:`__get__`, "
":meth:`__set__`, and :meth:`__delete__`.  If any of those methods are "
"defined for an the attribute, it is said to be a :term:`descriptor`."
msgstr ""

#: ../Doc/howto/descriptor.rst:503
#, fuzzy
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a "
"lookup chain starting with ``a.__dict__['x']``, then "
"``type(a).__dict__['x']``, and continuing through the method resolution "
"order of ``type(a)``. If the looked-up value is an object defining one of"
" the descriptor methods, then Python may override the default behavior "
"and invoke the descriptor method instead. Where this occurs in the "
"precedence chain depends on which descriptor methods were defined."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 가져오거나(get) 설정하거나(set) 삭제하는(delete) "
"것입니다. 예를 들어, ``a.x``\\는 ``a.__dict__['x']``\\로 시작한 다음 "
"``type(a).__dict__['x']``\\를 거쳐, 메타 클래스를 제외한 ``type(a)``\\의 베이스 클래스로 계속되는"
" 조회 체인을 갖습니다. 조회된 값이 디스크립터 메서드 중 하나를 정의하는 객체이면, 파이썬은 기본 동작을 대체하고 대신 디스크립터"
" 메서드를 호출 할 수 있습니다. 우선순위 체인에서 이것이 어디쯤 등장하는지는 어떤 디스크립터 메서드가 정의되었는지에 따라 "
"다릅니다."

#: ../Doc/howto/descriptor.rst:512
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""

#: ../Doc/howto/descriptor.rst:520
#, fuzzy
msgid "Descriptor protocol"
msgstr "디스크립터 프로토콜"

#: ../Doc/howto/descriptor.rst:522
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../Doc/howto/descriptor.rst:524
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../Doc/howto/descriptor.rst:526
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../Doc/howto/descriptor.rst:528
msgid ""
"That is all there is to it.  Define any of these methods and an object is"
" considered a descriptor and can override default behavior upon being "
"looked up as an attribute."
msgstr ""
"이것이 전부입니다. 이러한 메서드 중 하나를 정의하십시오, 그러면 객체를 디스크립터로 간주하고 어트리뷰트로 조회될 때 기본 동작을 "
"재정의할 수 있습니다."

#: ../Doc/howto/descriptor.rst:532
#, fuzzy
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is "
"considered a data descriptor.  Descriptors that only define "
":meth:`__get__` are called non-data descriptors (they are often used for "
"methods but other uses are possible)."
msgstr ""
"객체가 :meth:`__set__`\\이나 :meth:`__delete__`\\를 정의하면, 데이터 디스크립터로 간주합니다. "
":meth:`__get__` 만 정의하는 디스크립터를 비 데이터 디스크립터라고 합니다 (보통 메서드에 사용되지만 다른 용도도 "
"가능합니다)."

#: ../Doc/howto/descriptor.rst:537
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with"
" respect to entries in an instance's dictionary.  If an instance's "
"dictionary has an entry with the same name as a data descriptor, the data"
" descriptor takes precedence.  If an instance's dictionary has an entry "
"with the same name as a non-data descriptor, the dictionary entry takes "
"precedence."
msgstr ""
"데이터와 비 데이터 디스크립터는 인스턴스 딕셔너리의 항목과 관련하여 재정의가 계산되는 방식이 다릅니다. 인스턴스 딕셔너리에 데이터 "
"디스크립터와 이름이 같은 항목이 있으면, 데이터 디스크립터가 우선합니다. 인스턴스의 딕셔너리에 비 데이터 디스크립터와 이름이 같은 "
"항목이 있으면, 딕셔너리 항목이 우선합니다."

#: ../Doc/howto/descriptor.rst:543
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and "
":meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError`"
" when called.  Defining the :meth:`__set__` method with an exception "
"raising placeholder is enough to make it a data descriptor."
msgstr ""
"읽기 전용 데이터 디스크립터를 만들려면, :meth:`__get__`\\과 :meth:`__set__`\\을 모두 정의하고, "
":meth:`__set__`\\이 호출될 때 :exc:`AttributeError`\\를 발생시키십시오. 데이터 디스크립터를 만들기"
" 위해 예외를 발생시키는 자리 표시자로 :meth:`__set__` 메서드를 정의하는 것으로 충분합니다."

#: ../Doc/howto/descriptor.rst:550
msgid "Overview of descriptor invocation"
msgstr ""

#: ../Doc/howto/descriptor.rst:552
#, fuzzy
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or "
"``desc.__get__(None, cls)``."
msgstr "디스크립터는 메서드 이름으로 직접 호출 할 수 있습니다. 예를 들어, ``d.__get__(obj)``."

#: ../Doc/howto/descriptor.rst:555
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""

#: ../Doc/howto/descriptor.rst:558
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to"
" the precedence rules listed below."
msgstr ""

#: ../Doc/howto/descriptor.rst:563
#, fuzzy
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, "
"or instance of super."
msgstr "호출 세부 사항은 ``obj``\\가 객체인지 클래스인지에 따라 다릅니다."

#: ../Doc/howto/descriptor.rst:568
msgid "Invocation from an instance"
msgstr ""

#: ../Doc/howto/descriptor.rst:570
msgid ""
"Instance lookup scans through a chain of namespaces giving data "
"descriptors the highest priority, followed by instance variables, then "
"non-data descriptors, then class variables, and lastly "
":meth:`__getattr__` if it is provided."
msgstr ""

#: ../Doc/howto/descriptor.rst:575
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: "
"``desc.__get__(a, type(a))``."
msgstr ""

#: ../Doc/howto/descriptor.rst:578
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  "
"Here is a pure Python equivalent:"
msgstr ""

#: ../Doc/howto/descriptor.rst:698
msgid ""
"Interestingly, attribute lookup doesn't call "
":meth:`object.__getattribute__` directly.  Instead, both the dot operator"
" and the :func:`getattr` function perform attribute lookup by way of a "
"helper function:"
msgstr ""

#: ../Doc/howto/descriptor.rst:713
msgid ""
"So if :meth:`__getattr__` exists, it is called whenever "
":meth:`__getattribute__` raises :exc:`AttributeError` (either directly or"
" in one of the descriptor calls)."
msgstr ""

#: ../Doc/howto/descriptor.rst:716
msgid ""
"Also, if a user calls :meth:`object.__getattribute__` directly, the "
":meth:`__getattr__` hook is bypassed entirely."
msgstr ""

#: ../Doc/howto/descriptor.rst:721
#, fuzzy
msgid "Invocation from a class"
msgstr "클래스에서 호출"

#: ../Doc/howto/descriptor.rst:723
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in "
":meth:`type.__getattribute__`.  The steps are similar to those for "
":meth:`object.__getattribute__` but the instance dictionary lookup is "
"replaced by a search through the class's :term:`method resolution order`."
msgstr ""

#: ../Doc/howto/descriptor.rst:728
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr ""

#: ../Doc/howto/descriptor.rst:730
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and "
":c:func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""

#: ../Doc/howto/descriptor.rst:735
msgid "Invocation from super"
msgstr ""

#: ../Doc/howto/descriptor.rst:737
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""

#: ../Doc/howto/descriptor.rst:740
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches "
"``obj.__class__.__mro__`` for the base class ``B`` immediately following "
"``A`` and then returns ``B.__dict__['m'].__get__(obj, A)``.  If not a "
"descriptor, ``m`` is returned unchanged."
msgstr ""

#: ../Doc/howto/descriptor.rst:745
#, fuzzy
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in "
":source:`Objects/typeobject.c`.  A pure Python equivalent can be found in"
" `Guido's Tutorial "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_."
msgstr ""
"구현 세부 사항은 :source:`Objects/typeobject.c`\\의 :c:func:`super_getattro()`\\에"
" 있습니다. `Guido's Tutorial`_\\에서 순수한 파이썬 동등 물을 찾을 수 있습니다."

#: ../Doc/howto/descriptor.rst:752
msgid "Summary of invocation logic"
msgstr ""

#: ../Doc/howto/descriptor.rst:754
msgid ""
"The mechanism for descriptors is embedded in the "
":meth:`__getattribute__()` methods for :class:`object`, :class:`type`, "
"and :func:`super`."
msgstr ""

#: ../Doc/howto/descriptor.rst:757
msgid "The important points to remember are:"
msgstr "기억해야 할 중요한 사항은 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:759
#, fuzzy
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "디스크립터는 :meth:`__getattribute__` 메서드에 의해 호출됩니다"

#: ../Doc/howto/descriptor.rst:761
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or "
":func:`super`."
msgstr ""

#: ../Doc/howto/descriptor.rst:764
#, fuzzy
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr ":meth:`__getattribute__`\\를 재정의하면 자동 디스크립터 호출이 방지됩니다"

#: ../Doc/howto/descriptor.rst:767
#, fuzzy
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and "
"may include the class.  The second puts in ``None`` for the instance and "
"always includes the class."
msgstr ""
":meth:`object.__getattribute__`\\와 :meth:`type.__getattribute__`\\는 "
":meth:`__get__`\\를 다르게 호출합니다."

#: ../Doc/howto/descriptor.rst:772
#, fuzzy
msgid "Data descriptors always override instance dictionaries."
msgstr "데이터 디스크립터는 항상 인스턴스 딕셔너리를 대체합니다."

#: ../Doc/howto/descriptor.rst:774
#, fuzzy
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "비 데이터 디스크립터는 인스턴스 딕셔너리로 대체될 수 있습니다."

#: ../Doc/howto/descriptor.rst:778
msgid "Automatic name notification"
msgstr ""

#: ../Doc/howto/descriptor.rst:780
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable "
"name it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries "
"are descriptors and if they define :meth:`__set_name__`, that method is "
"called with two arguments.  The *owner* is the class where the descriptor"
" is used, and the *name* is the class variable the descriptor was "
"assigned to."
msgstr ""

#: ../Doc/howto/descriptor.rst:787
#, fuzzy
msgid ""
"The implementation details are in :c:func:`type_new()` and "
":c:func:`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""
"구현 세부 사항은 :source:`Objects/typeobject.c`\\의 :c:func:`super_getattro()`\\에"
" 있습니다. `Guido's Tutorial`_\\에서 순수한 파이썬 동등 물을 찾을 수 있습니다."

#: ../Doc/howto/descriptor.rst:790
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only "
"take place at the time of class creation.  If descriptors are added to "
"the class afterwards, :meth:`__set_name__` will need to be called "
"manually."
msgstr ""

#: ../Doc/howto/descriptor.rst:796
#, fuzzy
msgid "ORM example"
msgstr "디스크립터 예제"

#: ../Doc/howto/descriptor.rst:798
#, python-format
msgid ""
"The following code is simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""

#: ../Doc/howto/descriptor.rst:802
msgid ""
"The essential idea is that the data is stored in an external database.  "
"The Python instances only hold keys to the database's tables.  "
"Descriptors take care of lookups or updates:"
msgstr ""

#: ../Doc/howto/descriptor.rst:821
msgid ""
"We can use the :class:`Field` class to define `models "
"<https://en.wikipedia.org/wiki/Database_model>`_ that describe the schema"
" for each table in a database:"
msgstr ""

#: ../Doc/howto/descriptor.rst:846
msgid "To use the models, first connect to the database::"
msgstr ""

#: ../Doc/howto/descriptor.rst:851
msgid ""
"An interactive session shows how data is retrieved from the database and "
"how it can be updated:"
msgstr ""

#: ../Doc/howto/descriptor.rst:896
msgid "Pure Python Equivalents"
msgstr ""

#: ../Doc/howto/descriptor.rst:898
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into "
"built-in tools. Properties, bound methods, static methods, class methods,"
" and \\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""

#: ../Doc/howto/descriptor.rst:905
msgid "Properties"
msgstr "프로퍼티"

#: ../Doc/howto/descriptor.rst:907
#, fuzzy
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature"
" is::"
msgstr ""
":func:`property` 호출은 어트리뷰트에 액세스할 때 함수 호출을 트리거 하는 데이터 디스크립터를 작성하는 간결한 "
"방법입니다. 서명은 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:912
#, fuzzy
msgid "The documentation shows a typical use to define a managed attribute ``x``:"
msgstr "설명(doc)은 관리되는 어트리뷰트 ``x``\\를 정의하는 일반적인 사용법을 보여줍니다::"

#: ../Doc/howto/descriptor.rst:922
#, fuzzy
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"디스크립터 프로토콜 측면에서 :func:`property`\\가 어떻게 구현되는지 확인하려면, 여기 순수한 파이썬 동등 물이 "
"있습니다::"

#: ../Doc/howto/descriptor.rst:1015
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of "
"a method."
msgstr ""
":func:`property` 내장은 사용자 인터페이스가 어트리뷰트 액세스를 허가한 후 후속 변경이 메서드의 개입을 요구할 때 "
"도움을 줍니다."

#: ../Doc/howto/descriptor.rst:1019
#, fuzzy
msgid ""
"For instance, a spreadsheet class may grant access to a cell value "
"through ``Cell('b10').value``. Subsequent improvements to the program "
"require the cell to be recalculated on every access; however, the "
"programmer does not want to affect existing client code accessing the "
"attribute directly.  The solution is to wrap access to the value "
"attribute in a property data descriptor:"
msgstr ""
"예를 들어, 스프레드시트 클래스는 ``Cell('b10').value``\\를 통해 셀 값에 대한 액세스를 허가할 수 있습니다. "
"프로그램에 대한 후속 개선은 액세스할 때마다 셀이 재계산될 것을 요구합니다; 하지만, 프로그래머는 어트리뷰트에 직접 액세스하는 기존"
" 클라이언트 코드에 영향을 미치고 싶지 않습니다. 해결책은 프로퍼티 데이터 디스크립터로 value 어트리뷰트에 대한 액세스를 감싸는"
" 것입니다::"

#: ../Doc/howto/descriptor.rst:1036
msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr ""

#: ../Doc/howto/descriptor.rst:1041
#, fuzzy
msgid "Functions and methods"
msgstr "함수와 메서드"

#: ../Doc/howto/descriptor.rst:1043
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "파이썬의 객체 지향 기능은 함수 기반 환경을 기반으로 합니다. 비 데이터 디스크립터를 사용하면, 두 개가 매끄럽게 병합됩니다."

#: ../Doc/howto/descriptor.rst:1046
msgid ""
"Functions stored in class dictionaries get turned into methods when "
"invoked. Methods only differ from regular functions in that the object "
"instance is prepended to the other arguments.  By convention, the "
"instance is called *self* but could be called *this* or any other "
"variable name."
msgstr ""

#: ../Doc/howto/descriptor.rst:1051
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1068
msgid ""
"To support automatic creation of methods, functions include the "
":meth:`__get__` method for binding methods during attribute access.  This"
" means that functions are non-data descriptors that return bound methods "
"during dotted lookup from an instance.  Here's how it works:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1084
#, fuzzy
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr "인터프리터를 실행하면 실제로 함수 디스크립터가 작동하는 방식을 보여줍니다::"

#: ../Doc/howto/descriptor.rst:1093
msgid ""
"The function has a :term:`qualified name` attribute to support "
"introspection:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1100
msgid ""
"Accessing the function through the class dictionary does not invoke "
":meth:`__get__`.  Instead, it just returns the underlying function "
"object::"
msgstr ""

#: ../Doc/howto/descriptor.rst:1106
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr ""

#: ../Doc/howto/descriptor.rst:1112
msgid ""
"The interesting behavior occurs during dotted access from an instance.  "
"The dotted lookup calls :meth:`__get__` which returns a bound method "
"object::"
msgstr ""

#: ../Doc/howto/descriptor.rst:1119
msgid ""
"Internally, the bound method stores the underlying function and the bound"
" instance::"
msgstr ""

#: ../Doc/howto/descriptor.rst:1128
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""

#: ../Doc/howto/descriptor.rst:1133
#, fuzzy
msgid "Static methods"
msgstr "staticmethod"

#: ../Doc/howto/descriptor.rst:1135
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the "
"usual patterns of binding functions into methods."
msgstr "비 데이터 디스크립터는 함수에 메서드를 바인딩하는 일반적인 패턴을 변형하는 간단한 메커니즘을 제공합니다."

#: ../Doc/howto/descriptor.rst:1138
#, fuzzy
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"요약하면, 함수에는 :meth:`__get__` 메서드가 있어서 어트리뷰트로 액세스할 때 메서드로 변환될 수 있습니다. 비 데이터 "
"디스크립터는 ``obj.f(*args)`` 호출을 ``f(obj, *args)``\\로 변환합니다. "
"``klass.f(*args)`` 호출은 ``f(*args)``\\가 됩니다."

#: ../Doc/howto/descriptor.rst:1143
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "이 표는 연결과 가장 유용한 두 가지 변형을 요약합니다:"

#: ../Doc/howto/descriptor.rst:1146
msgid "Transformation"
msgstr "변환"

#: ../Doc/howto/descriptor.rst:1146
#, fuzzy
msgid "Called from an object"
msgstr "객체에서 호출"

#: ../Doc/howto/descriptor.rst:1146
#, fuzzy
msgid "Called from a class"
msgstr "클래스에서 호출"

#: ../Doc/howto/descriptor.rst:1149
msgid "function"
msgstr "함수"

#: ../Doc/howto/descriptor.rst:1149
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../Doc/howto/descriptor.rst:1149 ../Doc/howto/descriptor.rst:1151
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../Doc/howto/descriptor.rst:1151
msgid "staticmethod"
msgstr "staticmethod"

#: ../Doc/howto/descriptor.rst:1153
msgid "classmethod"
msgstr "classmethod"

#: ../Doc/howto/descriptor.rst:1153
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../Doc/howto/descriptor.rst:1153
#, fuzzy
msgid "f(cls, \\*args)"
msgstr "f(klass, \\*args)"

#: ../Doc/howto/descriptor.rst:1156
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr ""
"정적 메서드는 변경 없이 하부 함수를 반환합니다. ``c.f``\\나 ``C.f`` 호출은 "
"``object.__getattribute__(c, \"f\")``\\나 ``object.__getattribute__(C, "
"\"f\")``\\를 직접 조회하는 것과 동등합니다. 결과적으로, 함수는 객체나 클래스에서 동일하게 액세스 할 수 있습니다."

#: ../Doc/howto/descriptor.rst:1162
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "정적 메서드에 적합한 후보는 ``self`` 변수를 참조하지 않는 메서드입니다."

#: ../Doc/howto/descriptor.rst:1165
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on "
"the data. However, there may be useful functions which are conceptually "
"related but do not depend on the data.  For instance, ``erf(x)`` is handy"
" conversion routine that comes up in statistical work but does not "
"directly depend on a particular dataset. It can be called either from an "
"object or the class:  ``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> "
".9332``."
msgstr ""
"예를 들어, 통계 패키지는 실험 데이터를 위한 컨테이너 클래스를 포함 할 수 있습니다. 이 클래스는 데이터에 의존하는 산술 평균, "
"평균, 중앙값 및 기타 기술 통계량을 계산하는 일반 메서드를 제공합니다. 그러나, 개념적으로 관련되어 있지만, 데이터에 의존하지 "
"않는 유용한 함수가 있을 수 있습니다. 예를 들어, ``erf(x)``\\는 통계 작업에서 등장하지만, 특정 데이터 집합에 직접 "
"의존하지 않는 편리한 변환 루틴입니다. 객체나 클래스에서 호출 할 수 있습니다: ``s.erf(1.5) --> .9332`` 또는 "
"``Sample.erf(1.5) --> .9332``"

#: ../Doc/howto/descriptor.rst:1174
#, fuzzy
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr "정적 메서드는 변경 없이 하부 함수를 반환하므로, 예제 호출은 흥미롭지 않습니다::"

#: ../Doc/howto/descriptor.rst:1191
#, fuzzy
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this:"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`staticmethod`\\는 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:1207
#, fuzzy
msgid "Class methods"
msgstr "classmethod"

#: ../Doc/howto/descriptor.rst:1209
#, fuzzy
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"정적 메서드와 달리, 클래스 메서드는 함수를 호출하기 전에 클래스 참조를 인자 목록 앞에 추가합니다. 이 형식은 호출자가 객체나 "
"클래스일 때 같습니다::"

#: ../Doc/howto/descriptor.rst:1227
#, fuzzy
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One "
"use for class methods is to create alternate class constructors.  For "
"example, the classmethod :func:`dict.fromkeys` creates a new dictionary "
"from a list of keys.  The pure Python equivalent is:"
msgstr ""
"이 동작은 함수가 클래스 참조 만 필요하고 하부 데이터를 신경 쓰지 않을 때 유용합니다. 클래스 메서드의 한 가지 용도는 대체 "
"클래스 생성자를 만드는 것입니다. 파이썬 2.3에서, 클래스 메서드 :func:`dict.fromkeys`\\는 키 리스트에서 새 "
"딕셔너리를 만듭니다. 순수한 파이썬 동등 물은 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:1244
#, fuzzy
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "이제 고유 키의 새로운 딕셔너리를 다음과 같이 구성 할 수 있습니다::"

#: ../Doc/howto/descriptor.rst:1254
#, fuzzy
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this:"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`classmethod`\\는 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:1292
msgid ""
"The code path for ``hasattr(obj, '__get__')`` was added in Python 3.9 and"
" makes it possible for :func:`classmethod` to support chained decorators."
" For example, a classmethod and property could be chained together:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1311
msgid "Member objects and __slots__"
msgstr ""

#: ../Doc/howto/descriptor.rst:1313
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries "
"with a fixed-length array of slot values.  From a user point of view that"
" has several effects:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1317
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are "
"allowed:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1333
msgid ""
"2. Helps create immutable objects where descriptors manage access to "
"private attributes stored in ``__slots__``:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1368
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two "
"attributes takes 48 bytes with ``__slots__`` and 152 bytes without.  This"
" `flyweight design pattern "
"<https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely only matters "
"when a large number of instances are going to be created."
msgstr ""

#: ../Doc/howto/descriptor.rst:1373
msgid ""
"4. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1395
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and "
"control over object memory allocation.  However, we can build a mostly "
"faithful simulation where the actual C structure for slots is emulated by"
" a private ``_slotvalues`` list.  Reads and writes to that private "
"structure are managed by member descriptors:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1438
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to "
"class variables:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1454
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that "
"have slots instead of an instance dictionary.  Here is a rough simulation"
" in pure Python:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1489
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` "
"and set the :term:`metaclass` to :class:`Type`:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1503
msgid "At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr ""

#: ../Doc/howto/descriptor.rst:1524
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""

#: ../Doc/howto/descriptor.rst:1536
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr ""

#~ msgid ""
#~ "Defines descriptors, summarizes the protocol,"
#~ " and shows how descriptors are "
#~ "called.  Examines a custom descriptor "
#~ "and several built-in Python descriptors"
#~ " including functions, properties, static "
#~ "methods, and class methods.  Shows how"
#~ " each works by giving a pure "
#~ "Python equivalent and a sample "
#~ "application."
#~ msgstr ""
#~ "디스크립터를 정의하고, 프로토콜을 요약하며 디스크립터를 호출하는 "
#~ "방법을 보여줍니다. 사용자 정의 디스크립터와 함수, 프로퍼티,"
#~ " 정적 메서드 및 클래스 메서드를 포함한 몇 "
#~ "가지 내장 파이썬 디스크립터를 살펴봅니다. 순수 파이썬과"
#~ " 동등 물과 샘플 응용 프로그램을 제공하여 각각이 "
#~ "작동하는 방식을 보여줍니다."

#~ msgid ""
#~ "In general, a descriptor is an "
#~ "object attribute with \"binding behavior\","
#~ " one whose attribute access has been"
#~ " overridden by methods in the "
#~ "descriptor protocol.  Those methods are "
#~ ":meth:`__get__`, :meth:`__set__`, and "
#~ ":meth:`__delete__`.  If any of those "
#~ "methods are defined for an object, "
#~ "it is said to be a descriptor."
#~ msgstr ""
#~ "일반적으로 디스크립터는 \"바인딩 동작\"이 있는 객체 "
#~ "어트리뷰트로, 디스크립터 프로토콜의 메서드가 어트리뷰트 액세스를 "
#~ "재정의합니다. 이러한 메서드는 :meth:`__get__`, "
#~ ":meth:`__set__` 및 :meth:`__delete__`\\입니다. 이러한 "
#~ "메서드 중 어느 하나가 객체에 대해 정의되면, "
#~ "디스크립터라고 합니다."

#~ msgid ""
#~ "Descriptors are a powerful, general "
#~ "purpose protocol.  They are the "
#~ "mechanism behind properties, methods, static"
#~ " methods, class methods, and "
#~ ":func:`super()`. They are used throughout "
#~ "Python itself to implement the new "
#~ "style classes introduced in version 2.2."
#~ "  Descriptors simplify the underlying "
#~ "C-code and offer a flexible set of"
#~ " new tools for everyday Python "
#~ "programs."
#~ msgstr ""
#~ "디스크립터는 강력한 범용 프로토콜입니다. 이것들이 프로퍼티, "
#~ "메서드, 정적 메서드, 클래스 메서드 및 "
#~ ":func:`super()`\\의 뒤에 있는 메커니즘입니다. 버전 "
#~ "2.2에 도입된 새로운 스타일 클래스를 구현하기 위해 "
#~ "파이썬 자체에서 사용되었습니다. 디스크립터는 하부 C 코드를"
#~ " 단순화하고 일상적인 파이썬 프로그램을 위한 유연한 새"
#~ " 도구 집합을 제공합니다."

#~ msgid "Invoking Descriptors"
#~ msgstr "디스크립터 호출하기"

#~ msgid ""
#~ "Alternatively, it is more common for "
#~ "a descriptor to be invoked automatically"
#~ " upon attribute access.  For example, "
#~ "``obj.d`` looks up ``d`` in the "
#~ "dictionary of ``obj``.  If ``d`` defines"
#~ " the method :meth:`__get__`, then "
#~ "``d.__get__(obj)`` is invoked according to "
#~ "the precedence rules listed below."
#~ msgstr ""
#~ "또는, 어트리뷰트 액세스 시 디스크립터가 자동으로 호출되는"
#~ " 것이 더 일반적입니다. 예를 들어, ``obj.d``\\는 "
#~ "``obj`` 딕셔너리에서 ``d``\\를 조회합니다. ``d``\\가 "
#~ "메서드 :meth:`__get__`\\을 정의하면, 아래 나열된 우선순위"
#~ " 규칙에 따라 ``d.__get__(obj)`` 가 호출됩니다."

#~ msgid ""
#~ "For objects, the machinery is in "
#~ ":meth:`object.__getattribute__` which transforms "
#~ "``b.x`` into ``type(b).__dict__['x'].__get__(b, "
#~ "type(b))``.  The implementation works through"
#~ " a precedence chain that gives data"
#~ " descriptors priority over instance "
#~ "variables, instance variables priority over"
#~ " non-data descriptors, and assigns "
#~ "lowest priority to :meth:`__getattr__` if "
#~ "provided. The full C implementation can"
#~ " be found in :c:func:`PyObject_GenericGetAttr()`"
#~ " in :source:`Objects/object.c`."
#~ msgstr ""
#~ "객체의 경우, 절차는 :meth:`object.__getattribute__`\\에 "
#~ "있으며 ``b.x``\\를 ``type(b).__dict__['x'].__get__(b, "
#~ "type(b))``\\로 변환합니다. 구현은 우선순위 체인을 통해 "
#~ "작동하며, 데이터 디스크립터는 인스턴스 변수보다 우선하고, "
#~ "인스턴스 변수는 비 데이터 디스크립터보다 우선하고, 제공된다면"
#~ " :meth:`__getattr__`\\에 가장 낮은 우선순위를 지정합니다."
#~ " 전체 C 구현은 :source:`Objects/object.c`\\의 "
#~ ":c:func:`PyObject_GenericGetAttr()` 에서 찾을 수 "
#~ "있습니다."

#~ msgid ""
#~ "For classes, the machinery is in "
#~ ":meth:`type.__getattribute__` which transforms "
#~ "``B.x`` into ``B.__dict__['x'].__get__(None, B)``."
#~ "  In pure Python, it looks like::"
#~ msgstr ""
#~ "클래스의 경우, 절차는 :meth:`type.__getattribute__`\\에 "
#~ "있으며 ``B.x``\\를 ``B.__dict__['x'].__get__(None, "
#~ "B)``\\로 변환합니다. 순수한 파이썬으로 표현하면, 다음과 "
#~ "같습니다::"

#~ msgid ""
#~ "The object returned by ``super()`` also"
#~ " has a custom :meth:`__getattribute__` "
#~ "method for invoking descriptors.  The "
#~ "attribute lookup ``super(B, obj).m`` searches"
#~ " ``obj.__class__.__mro__`` for the base "
#~ "class ``A`` immediately following ``B`` "
#~ "and then returns ``A.__dict__['m'].__get__(obj, "
#~ "B)``.  If not a descriptor, ``m`` "
#~ "is returned unchanged.  If not in "
#~ "the dictionary, ``m`` reverts to a "
#~ "search using :meth:`object.__getattribute__`."
#~ msgstr ""
#~ "``super()``\\가 반환한 객체에도 디스크립터 호출을 위한 "
#~ "사용자 정의 :meth:`__getattribute__` 메서드가 있습니다. "
#~ "어트리뷰트 조회 ``super(B, obj).m``\\은 "
#~ "``obj.__class__.__mro__``\\에서 ``B`` 바로 다음에 오는"
#~ " 베이스 클래스 ``A``\\를 검색한 다음 "
#~ "``A.__dict__['m'].__get__(obj, B)``\\를 반환합니다. 디스크립터가"
#~ " 아니면, ``m``\\이 변경되지 않은 상태로 반환됩니다. "
#~ "딕셔너리에 없으면, ``m``\\은 "
#~ ":meth:`object.__getattribute__`\\를 사용한 검색으로 되돌아갑니다."

#~ msgid ""
#~ "The details above show that the "
#~ "mechanism for descriptors is embedded in"
#~ " the :meth:`__getattribute__()` methods for "
#~ ":class:`object`, :class:`type`, and :func:`super`."
#~ "  Classes inherit this machinery when "
#~ "they derive from :class:`object` or if"
#~ " they have a meta-class providing "
#~ "similar functionality. Likewise, classes can"
#~ " turn-off descriptor invocation by "
#~ "overriding :meth:`__getattribute__()`."
#~ msgstr ""
#~ "위의 세부 사항은 디스크립터 메커니즘이 :class:`object`,"
#~ " :class:`type` 및 :func:`super`\\의 "
#~ ":meth:`__getattribute__()` 메서드에 내장되어 있음을 "
#~ "보여줍니다. 클래스는 :class:`object`\\에서 파생되거나 유사한 "
#~ "기능을 제공하는 메타 클래스가 있을 때 이 절차를"
#~ " 상속합니다. 마찬가지로, 클래스는 :meth:`__getattribute__()`\\를"
#~ " 재정의하여 디스크립터 호출을 끌 수 있습니다."

#~ msgid ""
#~ "The following code creates a class "
#~ "whose objects are data descriptors which"
#~ " print a message for each get "
#~ "or set.  Overriding :meth:`__getattribute__` "
#~ "is alternate approach that could do "
#~ "this for every attribute.  However, this"
#~ " descriptor is useful for monitoring "
#~ "just a few chosen attributes::"
#~ msgstr ""
#~ "다음 코드는 객체가 데이터 디스크립터인 클래스를 만들어 "
#~ "각 get이나 set에 대해 메시지를 인쇄합니다. "
#~ ":meth:`__getattribute__`\\를 재정의하는 것은 모든 어트리뷰트에"
#~ " 대해 이를 수행 할 수 있는 대안 "
#~ "방법입니다. 하지만, 이 디스크립터는 선택한 몇 가지 "
#~ "어트리뷰트만 모니터링하는 데 유용합니다::"

#~ msgid ""
#~ "The protocol is simple and offers "
#~ "exciting possibilities.  Several use cases "
#~ "are so common that they have been"
#~ " packaged into individual function calls."
#~ " Properties, bound methods, static methods,"
#~ " and class methods are all based "
#~ "on the descriptor protocol."
#~ msgstr ""
#~ "이 프로토콜은 간단하고 흥미로운 가능성을 제공합니다. 몇"
#~ " 가지 유스 케이스는 아주 흔해서 개별 함수 "
#~ "호출로 패키징되었습니다. 프로퍼티, 연결된 메서드, 정적 "
#~ "메서드 및 클래스 메서드는 모두 디스크립터 프로토콜을 "
#~ "기반으로 합니다."

#~ msgid ""
#~ "Class dictionaries store methods as "
#~ "functions.  In a class definition, "
#~ "methods are written using :keyword:`def` "
#~ "or :keyword:`lambda`, the usual tools "
#~ "for creating functions.  Methods only "
#~ "differ from regular functions in that"
#~ " the first argument is reserved for"
#~ " the object instance.  By Python "
#~ "convention, the instance reference is "
#~ "called *self* but may be called "
#~ "*this* or any other variable name."
#~ msgstr ""
#~ "클래스 딕셔너리는 메서드를 함수로 저장합니다. 클래스 "
#~ "정의에서, 메서드는 함수 작성을 위한 일반적인 도구인 "
#~ ":keyword:`def`\\나 :keyword:`lambda`\\를 사용하여 작성됩니다."
#~ " 첫 번째 인자가 객체 인스턴스에 예약되어 있다는 "
#~ "점에서만 메서드가 일반 함수와 다릅니다. 파이썬 규칙에 "
#~ "따라, 인스턴스 참조는 *self*\\라고 하지만 *this*\\나"
#~ " 다른 어떤 변수 이름도 될 수 있습니다."

#~ msgid ""
#~ "To support method calls, functions "
#~ "include the :meth:`__get__` method for "
#~ "binding methods during attribute access.  "
#~ "This means that all functions are "
#~ "non-data descriptors which return bound "
#~ "methods when they are invoked from "
#~ "an object.  In pure Python, it "
#~ "works like this::"
#~ msgstr ""
#~ "메서드 호출을 지원하기 위해, 함수는 어트리뷰트 액세스 "
#~ "중에 메서드를 연결하기 위한 :meth:`__get__` 메서드를 "
#~ "포함합니다. 즉, 모든 함수는 객체에서 호출될 때 "
#~ "연결된 메서드를 반환하는 비 데이터 디스크립터입니다. 순수한"
#~ " 파이썬으로 표현하면, 이것은 다음과 같이 작동합니다::"

#~ msgid "Static Methods and Class Methods"
#~ msgstr "정적 메서드와 클래스 메서드"

