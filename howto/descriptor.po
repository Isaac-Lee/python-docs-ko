# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-08 08:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr "디스크립터 사용법 안내서"

#: ../Doc/howto/descriptor.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../Doc/howto/descriptor.rst
msgid "Contact"
msgstr "연락처"

#: ../Doc/howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../Doc/howto/descriptor.rst:11
msgid "Contents"
msgstr "목차"

#: ../Doc/howto/descriptor.rst:13
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ":term:`디스크립터 <descriptor>`\\는 객체가 어트리뷰트 조회, 저장 및 삭제를 사용자 정의 할 수 있도록 합니다."

#: ../Doc/howto/descriptor.rst:16
msgid "This guide has four major sections:"
msgstr "이 지침서는 네 개의 주요 섹션으로 구성됩니다:"

#: ../Doc/howto/descriptor.rst:18
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple "
"examples, adding one feature at a time.  Start here if you're new to "
"descriptors."
msgstr ""
"\"입문\"은 간단한 예제에서 부드럽게 이동하여 한 번에 하나의 기능을 추가하는 기본 개요를 제공합니다. 디스크립터를 처음 사용하면"
" 여기에서 시작하세요."

#: ../Doc/howto/descriptor.rst:21
msgid ""
"The second section shows a complete, practical descriptor example.  If "
"you already know the basics, start there."
msgstr "두 번째 섹션은 완전하고 실용적인 디스크립터 예제를 보여줍니다. 이미 기본 사항을 알고 있다면, 여기에서 시작하십시오."

#: ../Doc/howto/descriptor.rst:24
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"세 번째 섹션에서는 디스크립터가 작동하는 방식에 대한 자세한 메커니즘에 관해 설명하는 더 기술적인 자습서를 제공합니다. 대부분의 "
"사람은 이러한 수준의 세부 정보가 필요하지 않습니다."

#: ../Doc/howto/descriptor.rst:28
msgid ""
"The last section has pure Python equivalents for built-in descriptors "
"that are written in C.  Read this if you're curious about how functions "
"turn into bound methods or about the implementation of common tools like "
":func:`classmethod`, :func:`staticmethod`, :func:`property`, and "
":term:`__slots__`."
msgstr ""
"마지막 섹션에는 C로 작성된 내장 디스크립터에 대한 순수한 파이썬 등가물이 있습니다. 함수가 연결된 메서드로 바뀌는 방법이나 "
":func:`classmethod`, :func:`staticmethod`, :func:`property` 및 "
":term:`__slots__`\\와 같은 일반적인 도구의 구현에 대해 궁금하면 이 문서를 읽으십시오."

#: ../Doc/howto/descriptor.rst:36
msgid "Primer"
msgstr "입문"

#: ../Doc/howto/descriptor.rst:38
msgid ""
"In this primer, we start with the most basic possible example and then "
"we'll add new capabilities one by one."
msgstr "이 입문서에서는, 가능한 가장 기본적인 예제로 시작한 다음 새로운 기능을 하나씩 추가할 것입니다."

#: ../Doc/howto/descriptor.rst:43
msgid "Simple example: A descriptor that returns a constant"
msgstr "간단한 예: 상수를 반환하는 디스크립터"

#: ../Doc/howto/descriptor.rst:45
msgid ""
"The :class:`Ten` class is a descriptor that always returns the constant "
"``10`` from its :meth:`__get__` method:"
msgstr ":class:`Ten` 클래스는 항상 :meth:`__get__` 메서드에서 상수 ``10``\\을 반환하는 디스크립터입니다:"

#: ../Doc/howto/descriptor.rst:54
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr "디스크립터를 사용하려면, 다른 클래스에 클래스 변수로 저장해야 합니다:"

#: ../Doc/howto/descriptor.rst:62
msgid ""
"An interactive session shows the difference between normal attribute "
"lookup and descriptor lookup:"
msgstr "대화 형 세션은 일반 어트리뷰트 조회와 디스크립터 조회의 차이점을 보여줍니다:"

#: ../Doc/howto/descriptor.rst:73
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds the key ``x`` and"
" the value ``5`` in the class dictionary.  In the ``a.y`` lookup, the dot"
" operator finds a descriptor instance, recognized by its ``__get__`` "
"method, and calls that method which returns ``10``."
msgstr ""
"``a.x`` 어트리뷰트 조회에서, 점 연산자는 클래스 딕셔너리에서 키 ``x`` 와 값 ``5``\\를 찾습니다. ``a.y`` "
"조회에서, 점 연산자는 ``__get__`` 메서드로 인식되는 디스크립터 인스턴스를 찾고, ``10``\\을 반환하는 메서드를 "
"호출합니다."

#: ../Doc/howto/descriptor.rst:78
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary "
"or the instance dictionary.  Instead, the value ``10`` is computed on "
"demand."
msgstr "``10`` 값이 클래스 딕셔너리나 인스턴스 딕셔너리에 저장되지 않음에 유의하십시오. 대신, ``10`` 값은 요청 시 계산됩니다."

#: ../Doc/howto/descriptor.rst:81
msgid ""
"This example shows how a simple descriptor works, but it isn't very "
"useful. For retrieving constants, normal attribute lookup would be "
"better."
msgstr ""
"이 예는 간단한 디스크립터가 어떻게 작동하는지 보여 주지만, 그다지 유용하지는 않습니다. 상수를 꺼내려면, 일반 어트리뷰트 조회가 "
"더 좋습니다."

#: ../Doc/howto/descriptor.rst:84
msgid "In the next section, we'll create something more useful, a dynamic lookup."
msgstr "다음 섹션에서는, 좀 더 유용한 동적 조회를 만들 것입니다."

#: ../Doc/howto/descriptor.rst:88
msgid "Dynamic lookups"
msgstr "동적 조회"

#: ../Doc/howto/descriptor.rst:90
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr "흥미로운 디스크립터는 보통 상수를 반환하는 대신 계산을 실행합니다:"

#: ../Doc/howto/descriptor.rst:109
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr "대화 형 세션은 조회가 동적임을 보여줍니다 - 매번 다른 갱신된 답변을 계산합니다::"

#: ../Doc/howto/descriptor.rst:122
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter"
" is either *g* or *s*, an instance of *Directory*.  It is the *obj* "
"parameter that lets the :meth:`__get__` method learn the target "
"directory.  The *objtype* parameter is the class *Directory*."
msgstr ""
"디스크립터가 계산을 실행하는 방법을 보여주는 것 외에도, 이 예제는 :meth:`__get__`\\에 대한 매개 변수의 목적을 "
"드러냅니다. *self* 매개 변수는 *DirectorySize*\\의 인스턴스인 *size*\\입니다. *obj* 매개 변수는 "
"*Directory*\\의 인스턴스인 *g*\\나 *s*\\입니다. :meth:`__get__` 메서드가 대상 디렉터리를 알게 하는"
" 것은 *obj* 매개 변수입니다. *objtype* 매개 변수는 클래스 *Directory*\\입니다."

#: ../Doc/howto/descriptor.rst:131
msgid "Managed attributes"
msgstr "관리되는 어트리뷰트"

#: ../Doc/howto/descriptor.rst:133
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary "
"while the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods"
" are triggered when the public attribute is accessed."
msgstr ""
"디스크립터의 흔한 용도는 인스턴스 데이터에 대한 액세스를 관리하는 것입니다. 디스크립터는 클래스 딕셔너리의 공용 어트리뷰트에 "
"대입되고 실제 데이터는 인스턴스 딕셔너리에 개인 어트리뷰트로 저장됩니다. 디스크립터의 :meth:`__get__`\\과 "
":meth:`__set__` 메서드는 공용 어트리뷰트에 액세스할 때 트리거 됩니다."

#: ../Doc/howto/descriptor.rst:139
msgid ""
"In the following example, *age* is the public attribute and *_age* is the"
" private attribute.  When the public attribute is accessed, the "
"descriptor logs the lookup or update:"
msgstr ""
"다음 예에서, *age*\\는 공용 어트리뷰트이고 *_age*\\는 개인 어트리뷰트입니다. 공용 어트리뷰트에 액세스하면, "
"디스크립터는 조회나 갱신을 로그 합니다:"

#: ../Doc/howto/descriptor.rst:172
msgid ""
"An interactive session shows that all access to the managed attribute "
"*age* is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"대화 형 세션은 관리되는 어트리뷰트 *age*\\에 대한 모든 액세스가 로그 되지만, 일반 어트리뷰트 *name*\\은 로그 되지 "
"않음을 보여줍니다:"

#: ../Doc/howto/descriptor.rst:206
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance "
"can only have one logged attribute and that its name is unchangeable.  In"
" the next example, we'll fix that problem."
msgstr ""
"이 예제의 한 가지 주요 문제는 개인 이름 *_age*\\가 *LoggedAgeAccess* 클래스에 고정되어 있다는 것입니다. "
"즉, 각 인스턴스는 하나의 로그 되는 어트리뷰트 만 가질 수 있으며 해당 이름을 변경할 수 없습니다. 다음 예에서는, 이 문제를 "
"수정합니다."

#: ../Doc/howto/descriptor.rst:213
msgid "Customized names"
msgstr "사용자 정의 이름"

#: ../Doc/howto/descriptor.rst:215
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr "클래스가 디스크립터를 사용할 때, 어떤 변수 이름이 사용되었는지 각 디스크립터에 알릴 수 있습니다."

#: ../Doc/howto/descriptor.rst:218
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field "
"names can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"이 예에서, :class:`Person` 클래스에는 *name*\\과 *age*\\라는 두 개의 디스크립터 인스턴스가 있습니다. "
":class:`Person` 클래스가 정의될 때, *LoggedAccess*\\의 :meth:`__set_name__`\\에 대한 "
"콜백을 만들어 필드 이름을 기록할 수 있도록 해서, 각 디스크립터에 자신만의 *public_name*\\과 "
"*private_name*\\을 제공합니다:"

#: ../Doc/howto/descriptor.rst:256
msgid ""
"An interactive session shows that the :class:`Person` class has called "
":meth:`__set_name__` so that the field names would be recorded.  Here we "
"call :func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"대화 형 세션은 :class:`Person` 클래스가 :meth:`__set_name__`\\을 호출하여 필드 이름이 기록되었음을 "
"보여줍니다. 여기에서 :func:`vars`\\를 호출하여 트리거 하지 않고 디스크립터를 조회합니다:"

#: ../Doc/howto/descriptor.rst:267
msgid "The new class now logs access to both *name* and *age*:"
msgstr "이제 새 클래스는 *name*\\과 *age* 모두에 대한 액세스를 로그 합니다:"

#: ../Doc/howto/descriptor.rst:284
#, fuzzy
msgid "The two *Person* instances contain only the private names:"
msgstr "두 개의 *Person* 인스턴스에는 개인 이름만 포함됩니다::"

#: ../Doc/howto/descriptor.rst:295
msgid "Closing thoughts"
msgstr "마무리 생각"

#: ../Doc/howto/descriptor.rst:297
msgid ""
"A :term:`descriptor` is what we call any object that defines "
":meth:`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
":term:`디스크립터 <descriptor>`\\는 :meth:`__get__`, :meth:`__set__` 또는 "
":meth:`__delete__`\\를 정의하는 모든 객체를 우리가 부르는 이름입니다."

#: ../Doc/howto/descriptor.rst:300
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class "
"where it was created or the name of class variable it was assigned to.  "
"(This method, if present, is called even if the class is not a "
"descriptor.)"
msgstr ""
"선택적으로, 디스크립터는 :meth:`__set_name__` 메서드를 가질 수 있습니다. 이것은 디스크립터가 만들어진 클래스나 "
"대입된 클래스 변수의 이름을 알아야 하는 경우에만 사용됩니다. (있다면, 이 메서드는 클래스가 디스크립터가 아니라도 호출됩니다.)"

#: ../Doc/howto/descriptor.rst:305
msgid ""
"Descriptors get invoked by the dot \"operator\" during attribute lookup."
"  If a descriptor is accessed indirectly with "
"``vars(some_class)[descriptor_name]``, the descriptor instance is "
"returned without invoking it."
msgstr ""
"디스크립터는 어트리뷰트 조회 중에 점 \"연산자\"에 의해 호출됩니다. 디스크립터가 "
"``vars(some_class)[descriptor_name]``\\을 사용하여 간접적으로 액세스 되면, 디스크립터 인스턴스는 "
"호출하지 않고 반환됩니다."

#: ../Doc/howto/descriptor.rst:309
msgid ""
"Descriptors only work when used as class variables.  When put in "
"instances, they have no effect."
msgstr "디스크립터는 클래스 변수로 사용될 때만 작동합니다. 인스턴스에 넣으면, 효과가 없습니다."

#: ../Doc/howto/descriptor.rst:312
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects"
" stored in class variables to control what happens during attribute "
"lookup."
msgstr ""
"디스크립터의 주요 동기는 클래스 변수에 저장된 객체가 어트리뷰트 조회 중에 발생하는 일을 제어 할 수 있도록 하는 훅을 제공하는 "
"것입니다."

#: ../Doc/howto/descriptor.rst:315
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up "
"to have a say in the matter."
msgstr ""
"전통적으로, 호출하는 클래스가 조회 중에 어떤 일이 일어날지 제어합니다. 디스크립터는 그 관계를 역전시키고 조회 중인 데이터가 "
"발언권을 갖도록 합니다."

#: ../Doc/howto/descriptor.rst:319
msgid ""
"Descriptors are used throughout the language.  It is how functions turn "
"into bound methods.  Common tools like :func:`classmethod`, "
":func:`staticmethod`, :func:`property`, and "
":func:`functools.cached_property` are all implemented as descriptors."
msgstr ""
"디스크립터는 언어 전체에서 사용됩니다. 함수가 연결된 메서드로 바뀌는 방법입니다. :func:`classmethod`, "
":func:`staticmethod`, :func:`property` 및 "
":func:`functools.cached_property`\\와 같은 일반적인 도구는 모두 디스크립터로 구현됩니다."

#: ../Doc/howto/descriptor.rst:326
msgid "Complete Practical Example"
msgstr "완전한 실용적인 예"

#: ../Doc/howto/descriptor.rst:328
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr "이 예에서는, 찾기가 매우 어려운 것으로 악명 높은 데이터 손상 버그의 위치를 찾기 위한 실용적이고 강력한 도구를 만듭니다."

#: ../Doc/howto/descriptor.rst:333
msgid "Validator class"
msgstr "유효성 검사기 클래스"

#: ../Doc/howto/descriptor.rst:335
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to "
"storing any data, it verifies that the new value meets various type and "
"range restrictions.  If those restrictions aren't met, it raises an "
"exception to prevent data corruption at its source."
msgstr ""
"유효성 검사기는 관리되는 어트리뷰트 액세스를 위한 디스크립터입니다. 데이터를 저장하기 전에, 새 값이 다양한 형과 범위 제한을 "
"충족하는지 확인합니다. 이러한 제한 사항이 충족되지 않으면, 데이터 손상을 방지하기 위해 원천에서 예외가 발생합니다."

#: ../Doc/howto/descriptor.rst:340
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and "
"a managed attribute descriptor:"
msgstr ""
"이 :class:`Validator` 클래스는 :term:`추상 베이스 클래스 <abstract base class>`\\이면서 "
"관리되는 어트리뷰트 디스크립터입니다:"

#: ../Doc/howto/descriptor.rst:363
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply"
" a :meth:`validate` method to test various restrictions as needed."
msgstr ""
"사용자 정의 유효성 검사기는 :class:`Validator`\\에서 상속해야 하며 필요에 따라 다양한 제한을 테스트하기 위해 "
":meth:`validate` 메서드를 제공해야 합니다."

#: ../Doc/howto/descriptor.rst:368
msgid "Custom validators"
msgstr "사용자 정의 유효성 검사기"

#: ../Doc/howto/descriptor.rst:370
msgid "Here are three practical data validation utilities:"
msgstr "다음은 세 가지 실용적인 데이터 유효성 검사 유틸리티입니다:"

#: ../Doc/howto/descriptor.rst:372
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of "
"options."
msgstr ":class:`OneOf`\\는 값이 제한된 옵션 집합 중 하나인지 확인합니다."

#: ../Doc/howto/descriptor.rst:374
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or "
":class:`float`.  Optionally, it verifies that a value is between a given "
"minimum or maximum."
msgstr ""
":class:`Number`\\는 값이 :class:`int`\\나 :class:`float`\\인지 확인합니다. 선택적으로, 값이"
" 주어진 최솟값이나 최댓값 사이에 있는지 확인합니다."

#: ../Doc/howto/descriptor.rst:378
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-"
"defined `predicate "
"<https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ as well."
msgstr ""
":class:`String`\\은 값이 :class:`str`\\인지 확인합니다. 선택적으로, 주어진 최소나 최대 길이의 유효성을 "
"검사합니다. 사용자 정의 `술어(predicate) "
"<https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_\\도 검증할 수"
" 있습니다."

#: ../Doc/howto/descriptor.rst:437
msgid "Practical application"
msgstr "실용적인 응용"

#: ../Doc/howto/descriptor.rst:439
msgid "Here's how the data validators can be used in a real class:"
msgstr "실제 클래스에서 데이터 유효성 검사기를 사용하는 방법은 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:454
msgid "The descriptors prevent invalid instances from being created:"
msgstr "디스크립터는 잘못된 인스턴스가 만들어지는 것을 방지합니다:"

#: ../Doc/howto/descriptor.rst:481
msgid "Technical Tutorial"
msgstr "기술적인 자습서"

#: ../Doc/howto/descriptor.rst:483
msgid ""
"What follows is a more technical tutorial for the mechanics and details "
"of how descriptors work."
msgstr "다음은 디스크립터의 작동 원리와 세부 사항에 대한 더 기술적인 자습서입니다."

#: ../Doc/howto/descriptor.rst:488
msgid "Abstract"
msgstr "요약"

#: ../Doc/howto/descriptor.rst:490
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors "
"are called.  Provides an example showing how object relational mappings "
"work."
msgstr ""
"디스크립터를 정의하고, 프로토콜을 요약하며 디스크립터를 호출하는 방법을 보여줍니다. 객체 관계형 매핑(object "
"relational mappings)이 작동하는 방식을 보여주는 예를 제공합니다."

#: ../Doc/howto/descriptor.rst:493
msgid ""
"Learning about descriptors not only provides access to a larger toolset, "
"it creates a deeper understanding of how Python works."
msgstr "디스크립터에 대한 학습은 더 큰 도구 집합에 대한 액세스를 제공할 뿐만 아니라, 파이썬의 작동 방식에 대한 심층적인 이해를 만듭니다."

#: ../Doc/howto/descriptor.rst:498
msgid "Definition and introduction"
msgstr "정의와 소개"

#: ../Doc/howto/descriptor.rst:500
#, fuzzy
msgid ""
"In general, a descriptor is an attribute value that has one of the "
"methods in the descriptor protocol.  Those methods are :meth:`__get__`, "
":meth:`__set__`, and :meth:`__delete__`.  If any of those methods are "
"defined for an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"일반적으로, 디스크립터는 디스크립터 프로토콜의 메서드 중 하나를 갖는 어트리뷰트 값입니다. 이러한 메서드는 "
":meth:`__get__`, :meth:`__set__` 및 :meth:`__delete__`\\입니다. 이러한 메서드 중 어느 "
"하나가 객체에 대해 정의되면, :term:`디스크립터 <descriptor>`\\라고 합니다."

#: ../Doc/howto/descriptor.rst:505
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a "
"lookup chain starting with ``a.__dict__['x']``, then "
"``type(a).__dict__['x']``, and continuing through the method resolution "
"order of ``type(a)``. If the looked-up value is an object defining one of"
" the descriptor methods, then Python may override the default behavior "
"and invoke the descriptor method instead. Where this occurs in the "
"precedence chain depends on which descriptor methods were defined."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 가져오거나(get) 설정하거나(set) 삭제하는(delete) "
"것입니다. 예를 들어, ``a.x``\\는 ``a.__dict__['x']``\\로 시작한 다음 "
"``type(a).__dict__['x']``\\를 거쳐, ``type(a)``\\의 메서드 결정 순서로 계속되는 조회 체인을 "
"갖습니다. 조회된 값이 디스크립터 메서드 중 하나를 정의하는 객체이면, 파이썬은 기본 동작을 대체하고 대신 디스크립터 메서드를 호출"
" 할 수 있습니다. 우선순위 체인에서 이것이 어디쯤 등장하는지는 어떤 디스크립터 메서드가 정의되었는지에 따라 다릅니다."

#: ../Doc/howto/descriptor.rst:514
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and "
":func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"디스크립터는 강력한 범용 프로토콜입니다. 이것들이 프로퍼티, 메서드, 정적 메서드, 클래스 메서드 및 "
":func:`super()`\\의 뒤에 있는 메커니즘입니다. 파이썬 자체에서 사용되었습니다. 디스크립터는 하부 C 코드를 단순화하고"
" 일상적인 파이썬 프로그램을 위한 유연한 새 도구 집합을 제공합니다."

#: ../Doc/howto/descriptor.rst:522
msgid "Descriptor protocol"
msgstr "디스크립터 프로토콜"

#: ../Doc/howto/descriptor.rst:524
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../Doc/howto/descriptor.rst:526
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../Doc/howto/descriptor.rst:528
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../Doc/howto/descriptor.rst:530
msgid ""
"That is all there is to it.  Define any of these methods and an object is"
" considered a descriptor and can override default behavior upon being "
"looked up as an attribute."
msgstr ""
"이것이 전부입니다. 이러한 메서드 중 하나를 정의하십시오, 그러면 객체를 디스크립터로 간주하고 어트리뷰트로 조회될 때 기본 동작을 "
"재정의할 수 있습니다."

#: ../Doc/howto/descriptor.rst:534
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is "
"considered a data descriptor.  Descriptors that only define "
":meth:`__get__` are called non-data descriptors (they are often used for "
"methods but other uses are possible)."
msgstr ""
"객체가 :meth:`__set__`\\이나 :meth:`__delete__`\\를 정의하면, 데이터 디스크립터로 간주합니다. "
":meth:`__get__` 만 정의하는 디스크립터를 비 데이터 디스크립터라고 합니다 (보통 메서드에 사용되지만 다른 용도도 "
"가능합니다)."

#: ../Doc/howto/descriptor.rst:539
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with"
" respect to entries in an instance's dictionary.  If an instance's "
"dictionary has an entry with the same name as a data descriptor, the data"
" descriptor takes precedence.  If an instance's dictionary has an entry "
"with the same name as a non-data descriptor, the dictionary entry takes "
"precedence."
msgstr ""
"데이터와 비 데이터 디스크립터는 인스턴스 딕셔너리의 항목과 관련하여 재정의가 계산되는 방식이 다릅니다. 인스턴스 딕셔너리에 데이터 "
"디스크립터와 이름이 같은 항목이 있으면, 데이터 디스크립터가 우선합니다. 인스턴스의 딕셔너리에 비 데이터 디스크립터와 이름이 같은 "
"항목이 있으면, 딕셔너리 항목이 우선합니다."

#: ../Doc/howto/descriptor.rst:545
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and "
":meth:`__set__` with the :meth:`__set__` raising an :exc:`AttributeError`"
" when called.  Defining the :meth:`__set__` method with an exception "
"raising placeholder is enough to make it a data descriptor."
msgstr ""
"읽기 전용 데이터 디스크립터를 만들려면, :meth:`__get__`\\과 :meth:`__set__`\\을 모두 정의하고, "
":meth:`__set__`\\이 호출될 때 :exc:`AttributeError`\\를 발생시키십시오. 데이터 디스크립터를 만들기"
" 위해 예외를 발생시키는 자리 표시자로 :meth:`__set__` 메서드를 정의하는 것으로 충분합니다."

#: ../Doc/howto/descriptor.rst:552
msgid "Overview of descriptor invocation"
msgstr "디스크립터 호출의 개요"

#: ../Doc/howto/descriptor.rst:554
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or "
"``desc.__get__(None, cls)``."
msgstr ""
"디스크립터는 ``desc.__get__(obj)``\\나 ``desc.__get__(None, cls)``\\로 직접 호출 할 수 "
"있습니다."

#: ../Doc/howto/descriptor.rst:557
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr "하지만 어트리뷰트 액세스 시 디스크립터가 자동으로 호출되는 것이 더 일반적입니다."

#: ../Doc/howto/descriptor.rst:560
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to"
" the precedence rules listed below."
msgstr ""
"표현식 ``obj.x``\\는 ``obj`` 이름 공간 체인에서 어트리뷰트 ``x``\\를 조회합니다. 검색이 인스턴스 "
"``__dict__`` 밖에 있는 디스크립터를 발견하면, 아래 나열된 우선순위 규칙에 따라 그것의 :meth:`__get__`\\이"
" 호출됩니다."

#: ../Doc/howto/descriptor.rst:565
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, "
"or instance of super."
msgstr "호출 세부 사항은 ``obj``\\가 객체, 클래스 혹은 super의 인스턴스인지에 따라 다릅니다."

#: ../Doc/howto/descriptor.rst:570
msgid "Invocation from an instance"
msgstr "인스턴스에서 호출"

#: ../Doc/howto/descriptor.rst:572
msgid ""
"Instance lookup scans through a chain of namespaces giving data "
"descriptors the highest priority, followed by instance variables, then "
"non-data descriptors, then class variables, and lastly "
":meth:`__getattr__` if it is provided."
msgstr ""
"인스턴스 조회는 데이터 디스크립터에 가장 높은 우선순위를 부여하고 인스턴스 변수, 비 데이터 디스크립터, 클래스 변수, 마지막으로 "
"제공되면 :meth:`__getattr__`\\을 제공하는 이름 공간 체인을 통해 스캔합니다."

#: ../Doc/howto/descriptor.rst:577
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: "
"``desc.__get__(a, type(a))``."
msgstr "``a.x``\\에 대한 디스크립터가 발견되면, ``desc.__get__(a, type(a))``\\로 호출됩니다."

#: ../Doc/howto/descriptor.rst:580
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  "
"Here is a pure Python equivalent:"
msgstr "점 조회의 로직은 :meth:`object.__getattribute__`\\에 있습니다. 다음은 순수한 파이썬 등가물입니다:"

#: ../Doc/howto/descriptor.rst:700
msgid ""
"Interestingly, attribute lookup doesn't call "
":meth:`object.__getattribute__` directly.  Instead, both the dot operator"
" and the :func:`getattr` function perform attribute lookup by way of a "
"helper function:"
msgstr ""
"흥미롭게도, 어트리뷰트 조회는 :meth:`object.__getattribute__`\\를 직접 호출하지 않습니다. 대신, 점 "
"연산자와 :func:`getattr` 함수는 모두 도우미 함수를 통해 어트리뷰트 조회를 수행합니다:"

#: ../Doc/howto/descriptor.rst:747
msgid ""
"So if :meth:`__getattr__` exists, it is called whenever "
":meth:`__getattribute__` raises :exc:`AttributeError` (either directly or"
" in one of the descriptor calls)."
msgstr ""
"따라서 :meth:`__getattr__`\\이 존재하면, :meth:`__getattribute__`\\가 "
":exc:`AttributeError`\\를 발생시킬 때마다 호출됩니다 (직접 또는 디스크립터 호출 중 하나에서)."

#: ../Doc/howto/descriptor.rst:750
msgid ""
"Also, if a user calls :meth:`object.__getattribute__` directly, the "
":meth:`__getattr__` hook is bypassed entirely."
msgstr ""
"또한, 사용자가 :meth:`object.__getattribute__`\\를 직접 호출하면, :meth:`__getattr__` "
"훅을 완전히 우회합니다."

#: ../Doc/howto/descriptor.rst:755
msgid "Invocation from a class"
msgstr "클래스에서 호출"

#: ../Doc/howto/descriptor.rst:757
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in "
":meth:`type.__getattribute__`.  The steps are similar to those for "
":meth:`object.__getattribute__` but the instance dictionary lookup is "
"replaced by a search through the class's :term:`method resolution order`."
msgstr ""
"``A.x`` 와 같은 점 조회에 대한 로직은 :meth:`type.__getattribute__`\\에 있습니다. 단계는 "
":meth:`object.__getattribute__`\\의 단계와 유사하지만, 인스턴스 딕셔너리 조회가 클래스의 "
":term:`메서드 결정 순서 <method resolution order>`\\를 통한 검색으로 대체됩니다."

#: ../Doc/howto/descriptor.rst:762
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr "디스크립터가 발견되면, ``desc.__get__(None, A)``\\로 호출됩니다."

#: ../Doc/howto/descriptor.rst:764
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and "
":c:func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""
"전체 C 구현은 :c:func:`type_getattro()`\\와 :source:`Objects/typeobject.c`\\의 "
":c:func:`_PyType_Lookup()`\\에서 찾을 수 있습니다."

#: ../Doc/howto/descriptor.rst:769
msgid "Invocation from super"
msgstr "super에서 호출"

#: ../Doc/howto/descriptor.rst:771
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr ""
"super의 점 조회에 대한 논리는 :class:`super()`\\가 반환한 객체의 :meth:`__getattribute__` "
"메서드에 있습니다."

#: ../Doc/howto/descriptor.rst:774
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches "
"``obj.__class__.__mro__`` for the base class ``B`` immediately following "
"``A`` and then returns ``B.__dict__['m'].__get__(obj, A)``.  If not a "
"descriptor, ``m`` is returned unchanged."
msgstr ""
"점 조회 ``super(A, obj).m``\\은 ``obj.__class__.__mro__``\\에서 ``A`` 바로 다음에 오는"
" 베이스 클래스 ``B``\\를 검색한 다음 ``B.__dict__['m'].__get__(obj, A)``\\를 반환합니다. "
"디스크립터가 아니면, ``m``\\이 변경되지 않은 상태로 반환됩니다. "

#: ../Doc/howto/descriptor.rst:779
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in "
":source:`Objects/typeobject.c`.  A pure Python equivalent can be found in"
" `Guido's Tutorial "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_."
msgstr ""
"전체 C 구현은 :source:`Objects/typeobject.c`\\의 :c:func:`super_getattro()`\\에 "
"있습니다. `Guido의 자습서 "
"<https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_\\에서"
" 순수한 파이썬 동등 물을 찾을 수 있습니다."

#: ../Doc/howto/descriptor.rst:786
msgid "Summary of invocation logic"
msgstr "호출 로직 요약"

#: ../Doc/howto/descriptor.rst:788
msgid ""
"The mechanism for descriptors is embedded in the "
":meth:`__getattribute__()` methods for :class:`object`, :class:`type`, "
"and :func:`super`."
msgstr ""
"디스크립터 메커니즘은 :class:`object`, :class:`type` 및 :func:`super`\\의 "
":meth:`__getattribute__()` 메서드에 포함되어 있습니다."

#: ../Doc/howto/descriptor.rst:791
msgid "The important points to remember are:"
msgstr "기억해야 할 중요한 사항은 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:793
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "디스크립터는 :meth:`__getattribute__` 메서드에 의해 호출됩니다."

#: ../Doc/howto/descriptor.rst:795
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or "
":func:`super`."
msgstr "클래스는 :class:`object`, :class:`type` 또는 :func:`super`\\로부터 이 절차를 상속합니다."

#: ../Doc/howto/descriptor.rst:798
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr "모든 디스크립터 로직이 들어있기 때문에 :meth:`__getattribute__`\\를 재정의하면 자동 디스크립터 호출이 방지됩니다"

#: ../Doc/howto/descriptor.rst:801
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and "
"may include the class.  The second puts in ``None`` for the instance and "
"always includes the class."
msgstr ""
":meth:`object.__getattribute__`\\와 :meth:`type.__getattribute__`\\는 "
":meth:`__get__`\\을 다르게 호출합니다. 첫 번째는 인스턴스를 포함하고 클래스를 포함할 수 있습니다. 두 번째는 "
"인스턴스에 대해 ``None``\\을 넣고 항상 클래스를 포함합니다."

#: ../Doc/howto/descriptor.rst:806
msgid "Data descriptors always override instance dictionaries."
msgstr "데이터 디스크립터는 항상 인스턴스 딕셔너리를 대체합니다."

#: ../Doc/howto/descriptor.rst:808
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "비 데이터 디스크립터는 인스턴스 딕셔너리로 대체될 수 있습니다."

#: ../Doc/howto/descriptor.rst:812
msgid "Automatic name notification"
msgstr "자동 이름 알림"

#: ../Doc/howto/descriptor.rst:814
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable "
"name it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries "
"are descriptors and if they define :meth:`__set_name__`, that method is "
"called with two arguments.  The *owner* is the class where the descriptor"
" is used, and the *name* is the class variable the descriptor was "
"assigned to."
msgstr ""
"때로는 디스크립터가 대입된 클래스 변수 이름을 아는 것이 바람직합니다. 새 클래스가 만들어질 때, :class:`type` 메타 "
"클래스는 새 클래스의 딕셔너리를 검색합니다. 항목 중 하나가 디스크립터이고 :meth:`__set_name__`\\을 정의하면, "
"해당 메서드는 두 개의 인자로 호출됩니다. *owner*\\는 디스크립터가 사용되는 클래스이고, *name*\\은 디스크립터가 "
"대입된 클래스 변수입니다."

#: ../Doc/howto/descriptor.rst:821
msgid ""
"The implementation details are in :c:func:`type_new()` and "
":c:func:`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""
"구현 세부 사항은 :source:`Objects/typeobject.c`\\의 :c:func:`type_new()`\\와 "
":c:func:`set_names()`\\에 있습니다."

#: ../Doc/howto/descriptor.rst:824
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only "
"take place at the time of class creation.  If descriptors are added to "
"the class afterwards, :meth:`__set_name__` will need to be called "
"manually."
msgstr ""
"갱신 로직이 :meth:`type.__new__`\\에 있기 때문에, 알림은 클래스 생성 시에만 발생합니다. 나중에 디스크립터가 "
"클래스에 추가되면, :meth:`__set_name__`\\을 수동으로 호출해야 합니다."

#: ../Doc/howto/descriptor.rst:830
msgid "ORM example"
msgstr "ORM 예제"

#: ../Doc/howto/descriptor.rst:832
#, python-format
msgid ""
"The following code is simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"다음 코드는 데이터 디스크립터를 사용하여 `객체 관계형 매핑 "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_\\을 "
"구현하는 방법을 보여주는 단순화 된 골격입니다."

#: ../Doc/howto/descriptor.rst:836
msgid ""
"The essential idea is that the data is stored in an external database.  "
"The Python instances only hold keys to the database's tables.  "
"Descriptors take care of lookups or updates:"
msgstr ""
"핵심 아이디어는 데이터가 외부 데이터베이스에 저장된다는 것입니다. 파이썬 인스턴스는 데이터베이스 테이블에 대한 키만 보유합니다. "
"디스크립터가 조회나 갱신을 처리합니다:"

#: ../Doc/howto/descriptor.rst:855
msgid ""
"We can use the :class:`Field` class to define `models "
"<https://en.wikipedia.org/wiki/Database_model>`_ that describe the schema"
" for each table in a database:"
msgstr ""
":class:`Field` 클래스를 사용하여 데이터베이스의 각 테이블에 대한 스키마를 기술하는 `모델 "
"<https://en.wikipedia.org/wiki/Database_model>`_\\을 정의 할 수 있습니다:"

#: ../Doc/howto/descriptor.rst:880
msgid "To use the models, first connect to the database::"
msgstr "모델을 사용하려면, 먼저 데이터베이스에 연결하십시오::"

#: ../Doc/howto/descriptor.rst:885
msgid ""
"An interactive session shows how data is retrieved from the database and "
"how it can be updated:"
msgstr "대화 형 세션은 데이터베이스에서 데이터를 꺼내는 방법과 데이터를 갱신하는 방법을 보여줍니다:"

#: ../Doc/howto/descriptor.rst:930
msgid "Pure Python Equivalents"
msgstr "순수한 파이썬 등가물"

#: ../Doc/howto/descriptor.rst:932
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into "
"built-in tools. Properties, bound methods, static methods, class methods,"
" and \\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"디스트립터 프로토콜은 간단하고 흥미로운 가능성을 제공합니다. 몇 가지 유스 케이스는 아주 흔해서 내장 도구에 미리 패키징되었습니다."
" 프로퍼티, 연결된 메서드, 정적 메서드, 클래스 메서드 및 \\_\\_slots\\_\\_\\는 모두 디스크립터 프로토콜을 "
"기반으로 합니다."

#: ../Doc/howto/descriptor.rst:939
msgid "Properties"
msgstr "프로퍼티"

#: ../Doc/howto/descriptor.rst:941
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature"
" is::"
msgstr ""
":func:`property` 호출은 어트리뷰트에 액세스할 때 함수 호출을 트리거 하는 데이터 디스크립터를 작성하는 간결한 "
"방법입니다. 서명은 다음과 같습니다::"

#: ../Doc/howto/descriptor.rst:946
msgid "The documentation shows a typical use to define a managed attribute ``x``:"
msgstr "설명(doc)은 관리되는 어트리뷰트 ``x``\\를 정의하는 일반적인 사용법을 보여줍니다:"

#: ../Doc/howto/descriptor.rst:956
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr ""
"디스크립터 프로토콜 측면에서 :func:`property`\\가 어떻게 구현되는지 확인하려면, 여기 순수한 파이썬 동등 물이 "
"있습니다:"

#: ../Doc/howto/descriptor.rst:1049
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of "
"a method."
msgstr ""
":func:`property` 내장은 사용자 인터페이스가 어트리뷰트 액세스를 허가한 후 후속 변경이 메서드의 개입을 요구할 때 "
"도움을 줍니다."

#: ../Doc/howto/descriptor.rst:1053
msgid ""
"For instance, a spreadsheet class may grant access to a cell value "
"through ``Cell('b10').value``. Subsequent improvements to the program "
"require the cell to be recalculated on every access; however, the "
"programmer does not want to affect existing client code accessing the "
"attribute directly.  The solution is to wrap access to the value "
"attribute in a property data descriptor:"
msgstr ""
"예를 들어, 스프레드시트 클래스는 ``Cell('b10').value``\\를 통해 셀 값에 대한 액세스를 허가할 수 있습니다. "
"프로그램에 대한 후속 개선은 액세스할 때마다 셀이 재계산될 것을 요구합니다; 하지만, 프로그래머는 어트리뷰트에 직접 액세스하는 기존"
" 클라이언트 코드에 영향을 미치고 싶지 않습니다. 해결책은 프로퍼티 데이터 디스크립터로 value 어트리뷰트에 대한 액세스를 감싸는"
" 것입니다:"

#: ../Doc/howto/descriptor.rst:1070
msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr "내장 :func:`property`\\나 우리의 :func:`Property` 등가물이 이 예제에서 작동합니다."

#: ../Doc/howto/descriptor.rst:1075
msgid "Functions and methods"
msgstr "함수와 메서드"

#: ../Doc/howto/descriptor.rst:1077
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "파이썬의 객체 지향 기능은 함수 기반 환경을 기반으로 합니다. 비 데이터 디스크립터를 사용하면, 두 개가 매끄럽게 병합됩니다."

#: ../Doc/howto/descriptor.rst:1080
msgid ""
"Functions stored in class dictionaries get turned into methods when "
"invoked. Methods only differ from regular functions in that the object "
"instance is prepended to the other arguments.  By convention, the "
"instance is called *self* but could be called *this* or any other "
"variable name."
msgstr ""
"클래스 딕셔너리에 저장된 함수는 호출될 때 메서드로 바뀝니다. 객체 인스턴스가 다른 인자들 앞에 추가된다는 점에서만 메서드가 일반 "
"함수와 다릅니다. 관례에 따라, 이 인스턴스는 *self*\\라고 하지만 *this*\\나 다른 어떤 변수 이름도 될 수 있습니다."

#: ../Doc/howto/descriptor.rst:1085
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr "대략 다음과 동등한 :class:`types.MethodType`\\을 사용하여 메서드를 수동으로 만들 수 있습니다:"

#: ../Doc/howto/descriptor.rst:1102
msgid ""
"To support automatic creation of methods, functions include the "
":meth:`__get__` method for binding methods during attribute access.  This"
" means that functions are non-data descriptors that return bound methods "
"during dotted lookup from an instance.  Here's how it works:"
msgstr ""
"메서드의 자동 생성을 지원하기 위해, 함수는 어트리뷰트 액세스 중에 메서드를 연결하기 위한 :meth:`__get__` 메서드를 "
"포함합니다. 이는 함수가 인스턴스에서 점 조회하는 동안 연결된 메서드를 반환하는 비 데이터 디스크립터 임을 뜻합니다. 작동 방식은 "
"다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:1118
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr "인터프리터에서 다음 클래스를 실행하면 실제로 함수 디스크립터가 작동하는 방식을 보여줍니다:"

#: ../Doc/howto/descriptor.rst:1127
msgid ""
"The function has a :term:`qualified name` attribute to support "
"introspection:"
msgstr "함수에는 내부 검사를 지원하는 :term:`정규화된 이름 <qualified name>` 어트리뷰트가 있습니다:"

#: ../Doc/howto/descriptor.rst:1134
msgid ""
"Accessing the function through the class dictionary does not invoke "
":meth:`__get__`.  Instead, it just returns the underlying function "
"object::"
msgstr ""
"클래스 딕셔너리를 통한 함수 액세스는 :meth:`__get__`\\을 호출하지 않습니다. 대신, 단지 하부 함수 객체를 "
"반환합니다::"

#: ../Doc/howto/descriptor.rst:1140
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr "클래스에서 점을 통해 액세스하면 단지 하부 함수를 변경 없이 반환하는 :meth:`__get__`\\을 호출합니다::"

#: ../Doc/howto/descriptor.rst:1146
msgid ""
"The interesting behavior occurs during dotted access from an instance.  "
"The dotted lookup calls :meth:`__get__` which returns a bound method "
"object::"
msgstr ""
"흥미로운 동작은 인스턴스에서 점 액세스하는 동안 발생합니다. 점 조회는 연결된 메서드 객체를 반환하는 "
":meth:`__get__`\\을 호출합니다::"

#: ../Doc/howto/descriptor.rst:1153
msgid ""
"Internally, the bound method stores the underlying function and the bound"
" instance::"
msgstr "내부적으로, 연결된 메서드는 하부 함수와 연결된 인스턴스를 저장합니다."

#: ../Doc/howto/descriptor.rst:1162
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"일반 메서드에서 *self*\\가 어디에서 오는지 또는 클래스 메서드에서 *cls*\\가 어디에서 오는지 궁금한 적이 있다면, 바로"
" 이겁니다!"

#: ../Doc/howto/descriptor.rst:1167
#, fuzzy
msgid "Kinds of methods"
msgstr "클래스 메서드"

#: ../Doc/howto/descriptor.rst:1169
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the "
"usual patterns of binding functions into methods."
msgstr "비 데이터 디스크립터는 함수에 메서드를 바인딩하는 일반적인 패턴을 변형하는 간단한 메커니즘을 제공합니다."

#: ../Doc/howto/descriptor.rst:1172
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"요약하면, 함수에는 :meth:`__get__` 메서드가 있어서 어트리뷰트로 액세스할 때 메서드로 변환될 수 있습니다. 비 데이터 "
"디스크립터는 ``obj.f(*args)`` 호출을 ``f(obj, *args)``\\로 변환합니다. ``cls.f(*args)`` "
"호출은 ``f(*args)``\\가 됩니다."

#: ../Doc/howto/descriptor.rst:1177
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "이 표는 연결과 가장 유용한 두 가지 변형을 요약합니다:"

#: ../Doc/howto/descriptor.rst:1180
msgid "Transformation"
msgstr "변환"

#: ../Doc/howto/descriptor.rst:1180
msgid "Called from an object"
msgstr "객체에서 호출"

#: ../Doc/howto/descriptor.rst:1180
msgid "Called from a class"
msgstr "클래스에서 호출"

#: ../Doc/howto/descriptor.rst:1183
msgid "function"
msgstr "함수"

#: ../Doc/howto/descriptor.rst:1183
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../Doc/howto/descriptor.rst:1183 ../Doc/howto/descriptor.rst:1185
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../Doc/howto/descriptor.rst:1185
msgid "staticmethod"
msgstr "staticmethod"

#: ../Doc/howto/descriptor.rst:1187
msgid "classmethod"
msgstr "classmethod"

#: ../Doc/howto/descriptor.rst:1187
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../Doc/howto/descriptor.rst:1187
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../Doc/howto/descriptor.rst:1192
msgid "Static methods"
msgstr "정적 메서드"

#: ../Doc/howto/descriptor.rst:1194
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into "
"``object.__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, "
"\"f\")``. As a result, the function becomes identically accessible from "
"either an object or a class."
msgstr ""
"정적 메서드는 변경 없이 하부 함수를 반환합니다. ``c.f``\\나 ``C.f`` 호출은 "
"``object.__getattribute__(c, \"f\")``\\나 ``object.__getattribute__(C, "
"\"f\")``\\를 직접 조회하는 것과 동등합니다. 결과적으로, 함수는 객체나 클래스에서 동일하게 액세스 할 수 있습니다."

#: ../Doc/howto/descriptor.rst:1200
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "정적 메서드에 적합한 후보는 ``self`` 변수를 참조하지 않는 메서드입니다."

#: ../Doc/howto/descriptor.rst:1203
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on "
"the data. However, there may be useful functions which are conceptually "
"related but do not depend on the data.  For instance, ``erf(x)`` is handy"
" conversion routine that comes up in statistical work but does not "
"directly depend on a particular dataset. It can be called either from an "
"object or the class:  ``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> "
".9332``."
msgstr ""
"예를 들어, 통계 패키지는 실험 데이터를 위한 컨테이너 클래스를 포함 할 수 있습니다. 이 클래스는 데이터에 의존하는 산술 평균, "
"평균, 중앙값 및 기타 기술 통계량을 계산하는 일반 메서드를 제공합니다. 그러나, 개념적으로 관련되어 있지만, 데이터에 의존하지 "
"않는 유용한 함수가 있을 수 있습니다. 예를 들어, ``erf(x)``\\는 통계 작업에서 등장하지만, 특정 데이터 집합에 직접 "
"의존하지 않는 편리한 변환 루틴입니다. 객체나 클래스에서 호출 할 수 있습니다: ``s.erf(1.5) --> .9332`` 또는 "
"``Sample.erf(1.5) --> .9332``"

#: ../Doc/howto/descriptor.rst:1212
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr "정적 메서드는 변경 없이 하부 함수를 반환하므로, 예제 호출은 흥미롭지 않습니다:"

#: ../Doc/howto/descriptor.rst:1229
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`staticmethod` would look like this:"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`staticmethod`\\는 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:1261
msgid "Class methods"
msgstr "클래스 메서드"

#: ../Doc/howto/descriptor.rst:1263
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"정적 메서드와 달리, 클래스 메서드는 함수를 호출하기 전에 클래스 참조를 인자 목록 앞에 추가합니다. 이 형식은 호출자가 객체나 "
"클래스일 때 같습니다:"

#: ../Doc/howto/descriptor.rst:1281
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One "
"use for class methods is to create alternate class constructors.  For "
"example, the classmethod :func:`dict.fromkeys` creates a new dictionary "
"from a list of keys.  The pure Python equivalent is:"
msgstr ""
"이 동작은 함수가 클래스 참조 만 필요하고 특정 인스턴스에 저장된 데이터에 의존하지 않을 때 유용합니다. 클래스 메서드의 한 가지 "
"용도는 대체 클래스 생성자를 만드는 것입니다. 예를 들어, 클래스 메서드 :func:`dict.fromkeys`\\는 키 리스트에서"
" 새 딕셔너리를 만듭니다. 순수한 파이썬 동등 물은 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:1298
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "이제 고유 키의 새로운 딕셔너리를 다음과 같이 구성 할 수 있습니다:"

#: ../Doc/howto/descriptor.rst:1308
msgid ""
"Using the non-data descriptor protocol, a pure Python version of "
":func:`classmethod` would look like this:"
msgstr "비 데이터 디스크립터 프로토콜을 사용하면, 순수 파이썬 버전의 :func:`classmethod`\\는 다음과 같습니다:"

#: ../Doc/howto/descriptor.rst:1346
msgid ""
"The code path for ``hasattr(obj, '__get__')`` was added in Python 3.9 and"
" makes it possible for :func:`classmethod` to support chained decorators."
" For example, a classmethod and property could be chained together:"
msgstr ""
"``hasattr(obj, '__get__')``\\의 코드 경로는 파이썬 3.9에 추가되었으며 "
":func:`classmethod`\\가 데코레이터 연쇄(chained decorators)를 지원할 수 있도록 합니다. 예를 "
"들어, classmethod와 property를 함께 연결할 수 있습니다:"

#: ../Doc/howto/descriptor.rst:1365
msgid "Member objects and __slots__"
msgstr "멤버 객체와 __slots__"

#: ../Doc/howto/descriptor.rst:1367
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries "
"with a fixed-length array of slot values.  From a user point of view that"
" has several effects:"
msgstr ""
"클래스가 ``__slots__``\\를 정의하면, 인스턴스 딕셔너리를 슬롯값의 고정 길이 배열로 바꿉니다. 사용자 관점에서 여러 "
"가지 효과가 있습니다:"

#: ../Doc/howto/descriptor.rst:1371
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are "
"allowed:"
msgstr ""
"1 - 철자가 잘못된 어트리뷰트 대입으로 인한 버그를 즉시 감지합니다. ``__slots__``\\에 지정된 어트리뷰트 이름 만 "
"허용됩니다:"

#: ../Doc/howto/descriptor.rst:1387
msgid ""
"2. Helps create immutable objects where descriptors manage access to "
"private attributes stored in ``__slots__``:"
msgstr ""
"2 - 디스크립터가 ``__slots__``\\에 저장된 개인 어트리뷰트에 대한 액세스를 관리하는 불변 객체를 만드는 데 도움이 "
"됩니다:"

#: ../Doc/howto/descriptor.rst:1422
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two "
"attributes takes 48 bytes with ``__slots__`` and 152 bytes without.  This"
" `flyweight design pattern "
"<https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely only matters "
"when a large number of instances are going to be created."
msgstr ""
"3 - 메모리를 절약합니다. 64비트 리눅스 빌드에서 두 개의 어트리뷰트가 있는 인스턴스는 ``__slots__``\\가 있으면 "
"48바이트, 없으면 152바이트를 사용합니다. 이 `플라이웨이트(flyweight) 디자인 패턴 "
"<https://en.wikipedia.org/wiki/Flyweight_pattern>`_\\은 많은 수의 인스턴스가 만들어질 "
"때만 중요합니다."

#: ../Doc/howto/descriptor.rst:1427
msgid ""
"4. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"4 - 인스턴스 딕셔너리가 올바르게 작동해야 하는 :func:`functools.cached_property`\\와 같은 도구를 "
"차단합니다:"

#: ../Doc/howto/descriptor.rst:1449
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and "
"control over object memory allocation.  However, we can build a mostly "
"faithful simulation where the actual C structure for slots is emulated by"
" a private ``_slotvalues`` list.  Reads and writes to that private "
"structure are managed by member descriptors:"
msgstr ""
"``__slots__``\\의 정확한 순수 파이썬 드롭인 버전을 만드는 것은 불가능합니다. C 구조체에 직접 액세스하고 객체 메모리"
" 할당을 제어해야 하기 때문입니다. 그러나, 슬롯에 대한 실제 C 구조체가 개인 ``_slotvalues`` 리스트에 의해 모사되는"
" 가장 충실한 시뮬레이션을 구축 할 수 있습니다. 해당 개인 구조체에 대한 읽기와 쓰기는 멤버 디스크립터에 의해 관리됩니다:"

#: ../Doc/howto/descriptor.rst:1492
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to "
"class variables:"
msgstr ":meth:`type.__new__` 메서드는 클래스 변수에 멤버 객체를 추가하는 것을 관리합니다:"

#: ../Doc/howto/descriptor.rst:1508
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that "
"have slots instead of an instance dictionary.  Here is a rough simulation"
" in pure Python:"
msgstr ""
":meth:`object.__new__` 메서드는 인스턴스 딕셔너리 대신 슬롯이 있는 인스턴스를 만드는 것을 관장합니다. 다음은 "
"순수 파이썬의 대략적인 시뮬레이션입니다:"

#: ../Doc/howto/descriptor.rst:1543
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` "
"and set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"실제 클래스에서 시뮬레이션을 사용하려면, :class:`Object`\\에서 상속하고 :term:`메타 클래스 "
"<metaclass>`\\를 :class:`Type`\\으로 설정하면 됩니다:"

#: ../Doc/howto/descriptor.rst:1557
msgid "At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr "이 시점에서, 메타 클래스는 *x* 와 *y*\\에 대한 멤버 객체를 로드했습니다::"

#: ../Doc/howto/descriptor.rst:1578
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr "인스턴스가 만들어질 때, 어트리뷰트가 저장되는 ``slot_values`` 리스트를 갖습니다:"

#: ../Doc/howto/descriptor.rst:1590
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "철자가 틀리거나 지정되지 않은 어트리뷰트는 예외를 발생시킵니다:"

