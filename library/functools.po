# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-08 03:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:2
msgid ""
":mod:`functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ":mod:`functools` --- 고차 함수와 콜러블 객체에 대한 연산"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:14
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**소스 코드:** :source:`Lib/functools.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:23
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that"
" act on or return other functions. In general, any callable object can be"
" treated as a function for the purposes of this module."
msgstr ""
":mod:`functools` 모듈은 고차 함수를 위한 것입니다: 다른 함수에 작용하거나 다른 함수를 반환하는 함수. 일반적으로, "
"모든 콜러블 객체는 이 모듈의 목적상 함수로 취급될 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:27
msgid "The :mod:`functools` module defines the following functions:"
msgstr ":mod:`functools` 모듈은 다음 함수를 정의합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:31
msgid ""
"Simple lightweight unbounded function cache.  Sometimes called "
"`\"memoize\" <https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:34
msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than "
":func:`lru_cache()` with a size limit."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:39
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:230
msgid "For example::"
msgstr "예를 들면::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:57
msgid ""
"Transform a method of a class into a property whose value is computed "
"once and then cached as a normal attribute for the life of the instance. "
"Similar to :func:`property`, with the addition of caching. Useful for "
"expensive computed properties of instances that are otherwise effectively"
" immutable."
msgstr ""
"클래스의 메서드를 값이 한 번 계산된 다음 인스턴스 수명 동안 일반 어트리뷰트로 캐시 되는 프로퍼티로 변환합니다. "
":func:`property`\\와 유사하고, 캐싱이 추가되었습니다. 비싸게 계산되고 그 외에는 사실상 불변인 인스턴스의 프로퍼티에"
" 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:62
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:102
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:315
msgid "Example::"
msgstr "예::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:80
msgid ""
"This decorator requires that the ``__dict__`` attribute on each instance "
"be a mutable mapping. This means it will not work with some types, such "
"as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots "
"(as such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"이 데코레이터는 각 인스턴스의 ``__dict__`` 어트리뷰트가 가변 매핑일 것을 요구합니다. 이는 메타 클래스(형 인스턴스의 "
"``__dict__`` 어트리뷰트가 클래스 이름 공간에 대한 읽기 전용 프락시이기 때문에)와 ``__dict__``\\를 정의된 "
"슬롯 중 하나로 포함하지 않고 ``__slots__``\\를 지정하는 것(이러한 클래스는 ``__dict__`` 어트리뷰트를 전혀 "
"제공하지 않기 때문에)과 같은 일부 형에서 작동하지 않음을 의미합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:90
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  "
"Used with tools that accept key functions (such as :func:`sorted`, "
":func:`min`, :func:`max`, :func:`heapq.nlargest`, "
":func:`heapq.nsmallest`, :func:`itertools.groupby`).  This function is "
"primarily used as a transition tool for programs being converted from "
"Python 2 which supported the use of comparison functions."
msgstr ""
"구식 비교 함수를 :term:`키 함수 <key function>`\\로 변환합니다. (:func:`sorted`, "
":func:`min`, :func:`max`, :func:`heapq.nlargest`, "
":func:`heapq.nsmallest`, :func:`itertools.groupby`\\와 같은) 키 함수를 받아들이는 도구와"
" 함께 사용됩니다. 이 함수는 주로 비교 함수 사용을 지원하는 파이썬 2에서 변환되는 프로그램의 전이 도구로 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:97
msgid ""
"A comparison function is any callable that accept two arguments, compares"
" them, and returns a negative number for less-than, zero for equality, or"
" a positive number for greater-than.  A key function is a callable that "
"accepts one argument and returns another value to be used as the sort "
"key."
msgstr ""
"비교 함수는 두 개의 인자를 받아들이고, 그들을 비교하여, 작으면 음수, 같으면 0, 크면 양수를 반환하는 콜러블입니다. 키 함수는"
" 하나의 인자를 받아들이고 정렬 키로 사용할 다른 값을 반환하는 콜러블입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:106
msgid ""
"For sorting examples and a brief sorting tutorial, see "
":ref:`sortinghowto`."
msgstr "정렬 예제와 간략한 정렬 자습서는 :ref:`sortinghowto`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:114
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to "
"the *maxsize* most recent calls.  It can save time when an expensive or "
"I/O bound function is periodically called with the same arguments."
msgstr ""
"가장 최근의 *maxsize* 호출까지 저장하는 기억하는(memoizing) 콜러블 함수를 감싸는 데코레이터. 비싸거나 I/O 병목"
" 함수가 같은 인자로 주기적으로 호출될 때 시간을 절약할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:118
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be hashable."
msgstr "결과를 캐시 하는 데 딕셔너리가 사용되기 때문에, 함수에 대한 위치와 키워드 인자는 해시 가능해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:121
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, `f(a=1, b=2)` and `f(b=2, a=1)` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"서도 다른 인자 패턴은 별도의 캐시 항목을 갖는 별개의 호출로 간주할 수 있습니다. 예를 들어, `f(a=1, b=2)`\\와 "
"`f(b=2, a=1)`\\은 키워드 인자 순서가 다르며 두 개의 개별 캐시 항목을 가질 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:126
msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving "
"the *maxsize* at its default value of 128::"
msgstr ""
"*user_function*\\이 지정되면, 콜러블이어야 합니다. 이는 *lru_cache* 데코레이터를 사용자 함수에 직접 적용 "
"할 수 있도록 하며, *maxsize*\\를 기본값 128로 유지합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:135
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the "
"cache can grow without bound."
msgstr "*maxsize*\\가 ``None``\\으로 설정되면, LRU 기능이 비활성화되고 캐시가 제한 없이 커질 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:138
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  For example, ``f(3)`` and ``f(3.0)`` will be treated "
"as distinct calls with distinct results."
msgstr ""
"*typed*\\가 참으로 설정되면, 다른 형의 함수 인자가 별도로 캐시 됩니다. 예를 들어, ``f(3)``\\과 "
"``f(3.0)``\\은 별개의 결과를 가진 별개의 호출로 취급됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:142
msgid ""
"The wrapped function is instrumented with a :func:`cache_parameters` "
"function that returns a new :class:`dict` showing the values for "
"*maxsize* and *typed*.  This is for information purposes only.  Mutating "
"the values has no effect."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:147
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info`"
" function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*.  In a multi-threaded environment, the hits and "
"misses are approximate."
msgstr ""
"캐시의 효과를 측정하고 *maxsize* 매개 변수를 조정하는 것을 돕기 위해, 래핑 된 함수는 *hits*, *misses*, "
"*maxsize* 및 *currsize*\\를 표시하는 :term:`네임드 튜플 <named tuple>`\\을 반환하는 "
":func:`cache_info` 함수로 인스트루먼트 됩니다. 다중 스레드 환경에서, hits와 misses는 "
"근사적(approximate)입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:153
msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing "
"or invalidating the cache."
msgstr "데코레이터는 캐시를 지우거나 무효로 하기 위한 :func:`cache_clear` 함수도 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:156
msgid ""
"The original underlying function is accessible through the "
":attr:`__wrapped__` attribute.  This is useful for introspection, for "
"bypassing the cache, or for rewrapping the function with a different "
"cache."
msgstr ""
"원래의 하부 함수는 :attr:`__wrapped__` 어트리뷰트를 통해 액세스 할 수 있습니다. 이것은 인트로스펙션, 캐시 우회 "
"또는 다른 캐시로 함수를 다시 래핑하는 데 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:160
#, fuzzy
msgid ""
"An `LRU (least recently used) cache "
"<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)>`_"
" works best when the most recent calls are the best predictors of "
"upcoming calls (for example, the most popular articles on a news server "
"tend to change each day).  The cache's size limit assures that the cache "
"does not grow without bound on long-running processes such as web "
"servers."
msgstr ""
"`LRU (least recently used) 캐시 "
"<https://en.wikipedia.org/wiki/Cache_algorithms#Examples>`_\\는 가장 최근 호출이 "
"향후 호출에 대한 최상의 예측일 때 가장 잘 작동합니다 (예를 들어, 뉴스 서버에서 가장 인기 있는 기사는 매일 바뀌는 경향이 "
"있습니다). 캐시의 크기 제한은 웹 서버와 같은 오래 실행되는 프로세스에서 제한 없이 캐시가 커지지 않도록 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:167
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct "
"mutable objects on each call, or impure functions such as time() or "
"random()."
msgstr ""
"일반적으로, LRU 캐시는 이전에 계산된 값을 재사용하려고 할 때만 사용해야 합니다. 따라서, 부작용이 있는 함수, 각 호출에서 "
"고유한 가변 객체를 만들어야 하는 함수, time()이나 random()과 같은 비순수(impure) 함수를 캐시 하는 것은 의미가"
" 없습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:172
msgid "Example of an LRU cache for static web content::"
msgstr "정적 웹 콘텐츠를 위한 LRU 캐시의 예::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:191
msgid ""
"Example of efficiently computing `Fibonacci numbers "
"<https://en.wikipedia.org/wiki/Fibonacci_number>`_ using a cache to "
"implement a `dynamic programming "
"<https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"`동적 프로그래밍(dynamic programming) "
"<https://en.wikipedia.org/wiki/Dynamic_programming>`_ 기법을 구현하기 위해 캐시를 "
"사용하여 `피보나치 수 <https://en.wikipedia.org/wiki/Fibonacci_number>`_\\를 효율적으로 "
"계산하는 예::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:211
msgid "Added the *typed* option."
msgstr "*typed* 옵션을 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:214
msgid "Added the *user_function* option."
msgstr "*user_function* 옵션을 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:217
msgid "Added the function :func:`cache_parameters`"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:222
msgid ""
"Given a class defining one or more rich comparison ordering methods, this"
" class decorator supplies the rest.  This simplifies the effort involved "
"in specifying all of the possible rich comparison operations:"
msgstr ""
"하나 이상의 풍부한 비교(rich comparison) 순서 메서드를 정의하는 클래스를 주면, 이 클래스 데코레이터가 나머지를 "
"제공합니다. 가능한 모든 풍부한 비교 연산을 지정하는 데 드는 노력이 단순화됩니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:226
msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, or :meth:`__ge__`. In addition, the class should supply "
"an :meth:`__eq__` method."
msgstr ""
"클래스는 :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__` 또는 :meth:`__ge__` 중 "
"하나를 정의해야 합니다. 또한, 클래스는 :meth:`__eq__` 메서드를 제공해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:250
msgid ""
"While this decorator makes it easy to create well behaved totally ordered"
" types, it *does* come at the cost of slower execution and more complex "
"stack traces for the derived comparison methods. If performance "
"benchmarking indicates this is a bottleneck for a given application, "
"implementing all six rich comparison methods instead is likely to provide"
" an easy speed boost."
msgstr ""
"이 데코레이터를 사용하면 올바르게 동작하는 전 순서(totally ordered) 형을 쉽게 만들 수 있지만, 파생된 비교 "
"메서드에서 실행 속도가 느려지고 스택 트레이스가 더 복잡해지는 대가를 지불합니다. 성능 벤치마킹이 이것이 특정 응용 프로그램의 "
"병목임을 가리키면, 6가지의 풍부한 비교 메서드를 모두 구현하여 속도를 쉽게 높일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:259
msgid ""
"Returning NotImplemented from the underlying comparison function for "
"unrecognised types is now supported."
msgstr "인식할 수 없는 형에 대해 하부 비교 함수에서 NotImplemented를 반환하는 것이 이제 지원됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:265
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called "
"will behave like *func* called with the positional arguments *args* and "
"keyword arguments *keywords*. If more arguments are supplied to the call,"
" they are appended to *args*. If additional keyword arguments are "
"supplied, they extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"호출될 때 위치 인자 *args*\\와 키워드 인자 *keywords*\\로 호출된 *func*\\처럼 동작하는 새 "
":ref:`partial 객체 <partial-objects>`\\를 반환합니다. 더 많은 인자가 호출에 제공되면, "
"*args*\\에 추가됩니다. 추가 키워드 인자가 제공되면, *keywords*\\를 확장하고 대체합니다. 대략 다음과 "
"동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:281
msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords "
"resulting in a new object with a simplified signature.  For example, "
":func:`partial` can be used to create a callable that behaves like the "
":func:`int` function where the *base* argument defaults to two:"
msgstr ""
":func:`partial`\\은 함수의 인자 및/또는 키워드의 일부를 \"고정\"하여 서명이 단순화된 새 객체를 생성하는 부분 "
"함수 응용에 사용됩니다. 예를 들어, :func:`partial`\\을 사용하여 *base* 인자의 기본값이 2이면서 "
":func:`int` 함수 같은 동작을 하는 콜러블을 만들 수 있습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:296
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like "
":class:`partial` except that it is designed to be used as a method "
"definition rather than being directly callable."
msgstr ""
"직접 호출하기보다는 메서드 정의로 사용되도록 설계된 것을 제외하고는 :class:`partial`\\과 같이 동작하는 새 "
":class:`partialmethod` 디스크립터를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:300
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are "
"both, like normal functions, are handled as descriptors)."
msgstr ""
"*func*\\는 :term:`디스크립터 <descriptor>`\\나 콜러블이어야 합니다 (일반 함수처럼 둘 모두인 객체는 "
"디스크립터로 처리됩니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:303
msgid ""
"When *func* is a descriptor (such as a normal Python function, "
":func:`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or "
"another instance of :class:`partialmethod`), calls to ``__get__`` are "
"delegated to the underlying descriptor, and an appropriate :ref:`partial "
"object<partial-objects>` returned as the result."
msgstr ""
"*func*\\가 디스크립터(가령 일반 파이썬 함수, :func:`classmethod`, :func:`staticmethod`, "
":func:`abstractmethod` 또는 :class:`partialmethod`\\의 다른 인스턴스)이면, "
"``__get__``\\에 대한 호출은 하부 디스크립터에 위임되고, 적절한 :ref:`partial 객체 <partial-"
"objects>`\\가 결과로 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:309
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used"
" as a method: the *self* argument will be inserted as the first "
"positional argument, even before the *args* and *keywords* supplied to "
"the :class:`partialmethod` constructor."
msgstr ""
"*func*\\가 디스크립터가 아닌 콜러블이면, 적절한 연결된 메서드가 동적으로 만들어집니다. 이것은 메서드로 사용될 때 일반 "
"파이썬 함수처럼 작동합니다: :class:`partialmethod` 생성자에 제공된 *args*\\와 *keywords*\\보다도"
" 전에 *self* 인자가 첫 번째 위치 인자로 삽입됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:340
msgid ""
"Apply *function* of two arguments cumulatively to the items of "
"*iterable*, from left to right, so as to reduce the iterable to a single "
"value.  For example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` "
"calculates ``((((1+2)+3)+4)+5)``. The left argument, *x*, is the "
"accumulated value and the right argument, *y*, is the update value from "
"the *iterable*.  If the optional *initializer* is present, it is placed "
"before the items of the iterable in the calculation, and serves as a "
"default when the iterable is empty.  If *initializer* is not given and "
"*iterable* contains only one item, the first item is returned."
msgstr ""
"두 인자의 *function*\\을 왼쪽에서 오른쪽으로 *iterable*\\의 항목에 누적적으로 적용해서, 이터러블을 단일 값으로"
" 줄입니다. 예를 들어, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])``\\는 "
"``((((1+2)+3)+4)+5)``\\를 계산합니다. 왼쪽 인자 *x*\\는 누적값이고 오른쪽 인자 *y*\\는 "
"*iterable*\\에서 온 갱신 값입니다. 선택적 *initializer*\\가 있으면, 계산에서 이터러블의 항목 앞에 "
"배치되고, 이터러블이 비어있을 때 기본값의 역할을 합니다. *initializer*\\가 제공되지 않고 *iterable*\\에 "
"하나의 항목만 포함되면, 첫 번째 항목이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:349
msgid "Roughly equivalent to::"
msgstr "대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:361
msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr "모든 중간값을 산출하는 이터레이터는 :func:`itertools.accumulate`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:366
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` "
":term:`generic function`."
msgstr ""
"함수를 :term:`싱글 디스패치 <single dispatch>` :term:`제네릭 함수 <generic "
"function>`\\로 변환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:369
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. Note that the dispatch happens on the type of the first "
"argument, create your function accordingly::"
msgstr ""
"제네릭 함수를 정의하려면, ``@singledispatch`` 데코레이터로 데코레이트 하십시오. 디스패치는 첫 번째 인자의 형으로 "
"일어납니다, 그에 따라 함수를 작성하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:380
msgid ""
"To add overloaded implementations to the function, use the "
":func:`register` attribute of the generic function.  It is a decorator.  "
"For functions annotated with types, the decorator will infer the type of "
"the first argument automatically::"
msgstr ""
"오버로드 된 구현을 함수에 추가하려면, 제네릭 함수의 :func:`register` 어트리뷰트를 사용하십시오. 데코레이터입니다. "
"형으로 어노테이트 된 함수의 경우, 데코레이터는 첫 번째 인자의 형을 자동으로 유추합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:398
msgid ""
"For code which doesn't use type annotations, the appropriate type "
"argument can be passed explicitly to the decorator itself::"
msgstr "형 어노테이션을 사용하지 않는 코드의 경우, 적절한 형 인자를 데코레이터 자체에 명시적으로 전달할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:409
msgid ""
"To enable registering lambdas and pre-existing functions, the "
":func:`register` attribute can be used in a functional form::"
msgstr ""
"람다와 사전에 존재하는 함수를 등록할 수 있도록, :func:`register` 어트리뷰트를 다음과 같은 함수적인 형태로 사용할 수"
" 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:417
msgid ""
"The :func:`register` attribute returns the undecorated function which "
"enables decorator stacking, pickling, as well as creating unit tests for "
"each variant independently::"
msgstr ""
":func:`register` 어트리뷰트는 데코레이트 되지 않은 함수를 반환해서 데코레이터 스태킹, 피클링 뿐만 아니라 각 변형에 "
"대한 단위 테스트를 독립적으로 만드는 것을 가능하게 합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:431
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "호출되면, 제네릭 함수는 첫 번째 인자의 형에 따라 디스패치 합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:451
msgid ""
"Where there is no registered implementation for a specific type, its "
"method resolution order is used to find a more generic implementation. "
"The original function decorated with ``@singledispatch`` is registered "
"for the base ``object`` type, which means it is used if no better "
"implementation is found."
msgstr ""
"특정 형에 대해 등록된 구현이 없으면, 더 일반적인 구현을 찾는 데 메서드 결정 순서가 사용됩니다. "
"``@singledispatch``\\로 데코레이트 된 원래 함수는 베이스 ``object`` 형으로 등록되어서, 더 나은 구현이 "
"발견되지 않으면 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:457
msgid ""
"If an implementation registered to :term:`abstract base class`, virtual "
"subclasses will be dispatched to that implementation::"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:471
msgid ""
"To check which implementation will the generic function choose for a "
"given type, use the ``dispatch()`` attribute::"
msgstr "제네릭 함수가 주어진 형에 대해 어떤 구현을 선택하는지 확인하려면 ``dispatch()`` 어트리뷰트를 사용하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:479
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr "등록된 모든 구현에 액세스하려면, 읽기 전용 ``registry`` 어트리뷰트를 사용하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:493
msgid "The :func:`register` attribute supports using type annotations."
msgstr ":func:`register` 어트리뷰트는 형 어노테이션 사용을 지원합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:499
msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` "
":term:`generic function`."
msgstr ""
"메서드를 :term:`싱글 디스패치 <single dispatch>` :term:`제네릭 함수 <generic "
"function>`\\로 변환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:502
msgid ""
"To define a generic method, decorate it with the "
"``@singledispatchmethod`` decorator. Note that the dispatch happens on "
"the type of the first non-self or non-cls argument, create your function "
"accordingly::"
msgstr ""
"제네릭 메서드를 정의하려면, ``@singledispatchmethod`` 데코레이터로 장식하십시오. 디스패치는 첫 번째 self가"
" 아니거나 cls가 아닌 인자의 형에 따라 일어납니다, 그에 따라 함수를 작성하십시오::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:519
msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as "
"``@classmethod``. Note that to allow for ``dispatcher.register``, "
"``singledispatchmethod`` must be the *outer most* decorator. Here is the "
"``Negator`` class with the ``neg`` methods being class bound::"
msgstr ""
"``@singledispatchmethod``\\는 ``@classmethod``\\와 같은 다른 데코레이터와의 중첩을 지원합니다."
" ``dispatcher.register``\\를 허용하기 위해, ``singledispatchmethod``\\는 *가장 바깥* "
"데코레이터이어야 함에 유의하십시오. 다음은 ``neg`` 메서드가 클래스에 연결되는 ``Negator`` 클래스입니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:540
msgid ""
"The same pattern can be used for other similar decorators: "
"``staticmethod``, ``abstractmethod``, and others."
msgstr ""
"다른 유사한 데코레이터에도 같은 패턴을 사용할 수 있습니다: ``staticmethod``, ``abstractmethod`` 및 "
"기타."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:548
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original"
" function are assigned directly to the matching attributes on the wrapper"
" function and which attributes of the wrapper function are updated with "
"the corresponding attributes from the original function. The default "
"values for these arguments are the module level constants "
"``WRAPPER_ASSIGNMENTS`` (which assigns to the wrapper function's "
"``__module__``, ``__name__``, ``__qualname__``, ``__annotations__`` and "
"``__doc__``, the documentation string) and ``WRAPPER_UPDATES`` (which "
"updates the wrapper function's ``__dict__``, i.e. the instance "
"dictionary)."
msgstr ""
"*wrapped* 함수처럼 보이도록 *wrapper* 함수를 갱신합니다. 선택적 인자는 원래 함수의 어떤 어트리뷰트가 wrapper"
" 함수의 일치하는 어트리뷰트에 직접 대입되고 wrapper 함수의 어떤 어트리뷰트가 원래 함수의 해당 어트리뷰트로 갱신되는지 "
"지정하는 튜플입니다. 이 인자들의 기본값은 모듈 수준 상수 ``WRAPPER_ASSIGNMENTS``\\(wrapper 함수의 "
"``__module__``, ``__name__``, ``__qualname__``, ``__annotations__`` 및 "
"``__doc__`` 독스트링에 대입합니다)와 ``WRAPPER_UPDATES``\\(wrapper 함수의 ``__dict__``,"
" 즉 인스턴스 딕셔너리를 갱신합니다)입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:558
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the "
"wrapper that refers to the function being wrapped."
msgstr ""
"내부 검사와 기타 목적(예를 들어 :func:`lru_cache`\\와 같은 캐싱 데코레이터 우회)을 위해 원래 함수에 액세스 할 "
"수 있도록, 이 함수는 래핑 되는 함수를 가리키는 ``__wrapped__`` 어트리뷰트를 wrapper에 자동으로 추가합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:563
msgid ""
"The main intended use for this function is in :term:`decorator` functions"
" which wrap the decorated function and return the wrapper. If the wrapper"
" function is not updated, the metadata of the returned function will "
"reflect the wrapper definition rather than the original function "
"definition, which is typically less than helpful."
msgstr ""
"이 함수의 주요 용도는 데코레이트 된 함수를 래핑하고 wrapper를 반환하는 :term:`데코레이터 <decorator>` "
"함수에서 사용하는 것입니다. wrapper 함수가 갱신되지 않으면, 반환된 함수의 메타 데이터는 원래 함수 정의가 아닌 "
"wrapper 정의를 반영하게 되어 일반적으로 도움이 되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:569
msgid ""
":func:`update_wrapper` may be used with callables other than functions. "
"Any attributes named in *assigned* or *updated* that are missing from the"
" object being wrapped are ignored (i.e. this function will not attempt to"
" set them on the wrapper function). :exc:`AttributeError` is still raised"
" if the wrapper function itself is missing any attributes named in "
"*updated*."
msgstr ""
":func:`update_wrapper`\\는 함수 이외의 콜러블과 함께 사용할 수 있습니다. 래핑 되는 객체에서 누락된 "
"*assigned*\\나 *updated*\\로 이름 지정된 어트리뷰트는 무시됩니다 (즉, 이 함수는 wrapper 함수에서 그 "
"어트리뷰트를 설정하려고 시도하지 않습니다). wrapper 함수 자체에 *updated*\\에 이름 지정된 어트리뷰트가 없으면 "
"여전히 :exc:`AttributeError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:575
msgid "Automatic addition of the ``__wrapped__`` attribute."
msgstr "``__wrapped__`` 어트리뷰트 자동 추가."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:578
msgid "Copying of the ``__annotations__`` attribute by default."
msgstr "기본적으로 ``__annotations__`` 어트리뷰트의 복사."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:581
msgid "Missing attributes no longer trigger an :exc:`AttributeError`."
msgstr "누락된 어트리뷰트는 더는 :exc:`AttributeError`\\를 발생시키지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:584
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see "
":issue:`17482`)"
msgstr ""
"``__wrapped__`` 어트리뷰트는 이제 해당 함수가 ``__wrapped__`` 어트리뷰트를 정의한 경우에도 항상 래핑 된 "
"함수를 참조합니다. (:issue:`17482`\\를 참조하십시오)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:592
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to"
" ``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"래퍼 함수를 정의할 때 함수 데코레이터로 :func:`update_wrapper`\\를 호출하기 위한 편의 함수입니다. "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``\\와 동등합니다. 예를 들면::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:618
msgid ""
"Without the use of this decorator factory, the name of the example "
"function would have been ``'wrapper'``, and the docstring of the original"
" :func:`example` would have been lost."
msgstr ""
"이 데코레이터 팩토리를 사용하지 않으면, example 함수의 이름은 ``'wrapper'``\\가 되고, 원래 "
":func:`example`\\의 독스트링은 잃어버리게 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:626
msgid ":class:`partial` Objects"
msgstr ":class:`partial` 객체"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:628
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`."
" They have three read-only attributes:"
msgstr ""
":class:`partial` 객체는 :func:`partial`\\이 만든 콜러블 객체입니다. 세 가지 읽기 전용 어트리뷰트가 "
"있습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:634
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will"
" be forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"콜러블 객체나 함수. :class:`partial` 객체에 대한 호출은 새로운 인자와 키워드와 함께 :attr:`func`\\로 "
"전달됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:640
msgid ""
"The leftmost positional arguments that will be prepended to the "
"positional arguments provided to a :class:`partial` object call."
msgstr ":class:`partial` 객체 호출에 제공되는 위치 인자 앞에 추가될 가장 왼쪽 위치 인자들입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:646
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` "
"object is called."
msgstr ":class:`partial` 객체가 호출될 때 제공될 키워드 인자들입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/functools.rst:649
msgid ""
":class:`partial` objects are like :class:`function` objects in that they "
"are callable, weak referencable, and can have attributes.  There are some"
" important differences.  For instance, the :attr:`~definition.__name__` "
"and :attr:`__doc__` attributes are not created automatically.  Also, "
":class:`partial` objects defined in classes behave like static methods "
"and do not transform into bound methods during instance attribute look-"
"up."
msgstr ""
":class:`partial` 객체는 콜러블이고, 약한 참조 가능하며, 어트리뷰트를 가질 수 있다는 점에서 "
":class:`function` 객체와 같습니다. 몇 가지 중요한 차이점이 있습니다. 예를 들어, "
":attr:`~definition.__name__`\\과 :attr:`__doc__` 어트리뷰트는 자동으로 만들어지지 않습니다. "
"또한, 클래스에 정의된 :class:`partial` 객체는 정적 메서드처럼 동작하며 인스턴스 어트리뷰트 조회 중에 연결된 메서드로"
" 변환되지 않습니다."

