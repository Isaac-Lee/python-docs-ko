# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-12 08:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/typing.rst:3
msgid ":mod:`typing` --- Support for type hints"
msgstr ":mod:`typing` --- 형 힌트 지원"

#: ../Doc/library/typing.rst:10
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**소스 코드:** :source:`Lib/typing.py`"

#: ../Doc/library/typing.rst:14
msgid ""
"The Python runtime does not enforce function and variable type "
"annotations. They can be used by third party tools such as type checkers,"
" IDEs, linters, etc."
msgstr ""
"파이썬 런타임은 함수와 변수 형 어노테이션을 강제하지 않습니다. 형 어노테이션은 형 검사기, IDE, 린터(linter) 등과 같은"
" 제삼자 도구에서 사용할 수 있습니다."

#: ../Doc/library/typing.rst:20
msgid ""
"This module provides runtime support for type hints as specified by "
":pep:`484`, :pep:`526`, :pep:`544`, :pep:`586`, :pep:`589`, and "
":pep:`591`. The most fundamental support consists of the types "
":data:`Any`, :data:`Union`, :data:`Tuple`, :data:`Callable`, "
":class:`TypeVar`, and :class:`Generic`.  For full specification please "
"see :pep:`484`.  For a simplified introduction to type hints see "
":pep:`483`."
msgstr ""
"이 모듈은 :pep:`484`, :pep:`526`, :pep:`544`, :pep:`586`, :pep:`589` 및 "
":pep:`591`\\로 지정된 형 힌트에 대한 런타임 지원을 제공합니다. 가장 기본적인 지원은 형 :data:`Any`, "
":data:`Union`, :data:`Tuple`, :data:`Callable`, :class:`TypeVar` 및 "
":class:`Generic`\\으로 구성됩니다. 전체 명세는 :pep:`484`\\를 참조하십시오. 형 힌트에 대한 간략한 소개는"
" :pep:`483`\\을 참조하십시오."

#: ../Doc/library/typing.rst:28
msgid ""
"The function below takes and returns a string and is annotated as "
"follows::"
msgstr "아래의 함수는 문자열을 취하고 반환하며 다음과 같이 어노테이트 되었습니다::"

#: ../Doc/library/typing.rst:33
msgid ""
"In the function ``greeting``, the argument ``name`` is expected to be of "
"type :class:`str` and the return type :class:`str`. Subtypes are accepted"
" as arguments."
msgstr ""
"함수 ``greeting``\\에서, 인자 ``name``\\은 형 :class:`str`\\로, 반환형은 "
":class:`str`\\로 기대됩니다. 서브 형은 인자로 허용됩니다."

#: ../Doc/library/typing.rst:38
msgid "Type aliases"
msgstr "형 에일리어스"

#: ../Doc/library/typing.rst:40
msgid ""
"A type alias is defined by assigning the type to the alias. In this "
"example, ``Vector`` and ``list[float]`` will be treated as "
"interchangeable synonyms::"
msgstr ""
"형 에일리어스는 별칭에 형을 대입하여 정의됩니다. 이 예에서, ``Vector``\\와 ``list[float]``\\는 교환 "
"가능한 동의어로 취급됩니다::"

#: ../Doc/library/typing.rst:51
msgid ""
"Type aliases are useful for simplifying complex type signatures. For "
"example::"
msgstr "형 에일리어스는 복잡한 형 서명을 단순화하는 데 유용합니다. 예를 들면::"

#: ../Doc/library/typing.rst:69
msgid ""
"Note that ``None`` as a type hint is a special case and is replaced by "
"``type(None)``."
msgstr "형 힌트로서의 ``None``\\은 특별한 경우이며 ``type(None)``\\으로 치환됨에 유의하십시오."

#: ../Doc/library/typing.rst:75
msgid "NewType"
msgstr "NewType"

#: ../Doc/library/typing.rst:77
msgid "Use the :func:`NewType` helper function to create distinct types::"
msgstr ":func:`NewType` 도우미 함수를 사용하여 다른 형을 만드십시오::"

#: ../Doc/library/typing.rst:84
msgid ""
"The static type checker will treat the new type as if it were a subclass "
"of the original type. This is useful in helping catch logical errors::"
msgstr "정적 형 검사기는 새 형을 원래 형의 서브 클래스인 것처럼 다룹니다. 논리 에러를 잡는 데 유용합니다::"

#: ../Doc/library/typing.rst:96
msgid ""
"You may still perform all ``int`` operations on a variable of type "
"``UserId``, but the result will always be of type ``int``. This lets you "
"pass in a ``UserId`` wherever an ``int`` might be expected, but will "
"prevent you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""
"``UserId`` 형의 변수에 대해 모든 ``int`` 연산을 여전히 수행할 수 있지만, 결과는 항상 ``int`` 형이 됩니다."
" 이것은 ``int``\\가 기대되는 모든 곳에 ``UserId``\\를 전달할 수 있지만, 잘못된 방식으로 의도하지 않게 "
"``UserId``\\를 만들지 않도록 합니다::"

#: ../Doc/library/typing.rst:104
msgid ""
"Note that these checks are enforced only by the static type checker. At "
"runtime, the statement ``Derived = NewType('Derived', Base)`` will make "
"``Derived`` a function that immediately returns whatever parameter you "
"pass it. That means the expression ``Derived(some_value)`` does not "
"create a new class or introduce any overhead beyond that of a regular "
"function call."
msgstr ""
"이러한 검사는 정적 형 검사기에서만 적용됨에 유의하십시오. 실행 시간에, 문장 ``Derived = "
"NewType('Derived', Base)``\\는 ``Derived``\\를 전달하는 매개 변수를 즉시 반환하는 함수로 "
"만듭니다. 이것은 ``Derived(some_value)`` 표현식이 새로운 클래스를 만들거나 일반 함수 호출을 넘어서는 오버헤드를"
" 발생시키지 않음을 의미합니다."

#: ../Doc/library/typing.rst:110
msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is "
"always true at runtime."
msgstr "더욱 정확하게, 표현식 ``some_value is Derived(some_value)``\\는 실행 시간에 항상 참입니다."

#: ../Doc/library/typing.rst:113
msgid ""
"This also means that it is not possible to create a subtype of "
"``Derived`` since it is an identity function at runtime, not an actual "
"type::"
msgstr ""
"이것은 또한 ``Derived``\\의 서브 형을 만들 수 없다는 것을 의미하는데, 실행 시간에 항등함수(identity "
"function)일 뿐 실제 형이 아니기 때문입니다::"

#: ../Doc/library/typing.rst:123
msgid ""
"However, it is possible to create a :func:`NewType` based on a 'derived' "
"``NewType``::"
msgstr "그러나, '파생된' ``NewType``\\을 기반으로 :func:`NewType`\\을 만들 수 있습니다::"

#: ../Doc/library/typing.rst:131
msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "그리고 ``ProUserId``\\에 대한 형 검사는 예상대로 작동합니다."

#: ../Doc/library/typing.rst:133
msgid "See :pep:`484` for more details."
msgstr "자세한 내용은 :pep:`484`\\를 참조하십시오."

#: ../Doc/library/typing.rst:137
msgid ""
"Recall that the use of a type alias declares two types to be *equivalent*"
" to one another. Doing ``Alias = Original`` will make the static type "
"checker treat ``Alias`` as being *exactly equivalent* to ``Original`` in "
"all cases. This is useful when you want to simplify complex type "
"signatures."
msgstr ""
"형 에일리어스를 사용하면 두 형이 서로 *동등한* 것으로 선언됨을 상기하십시오. ``Alias = Original``\\은 모든 "
"경우 정적 형 검사기가 ``Alias``\\를 ``Original``\\과 *정확히 동등한* 것으로 취급하게 합니다. 이것은 복잡한"
" 형 서명을 단순화하려는 경우에 유용합니다."

#: ../Doc/library/typing.rst:142
msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. "
"Doing ``Derived = NewType('Derived', Original)`` will make the static "
"type checker treat ``Derived`` as a *subclass* of ``Original``, which "
"means a value of type ``Original`` cannot be used in places where a value"
" of type ``Derived`` is expected. This is useful when you want to prevent"
" logic errors with minimal runtime cost."
msgstr ""
"반면에, ``NewType``\\은 한 형을 다른 형의 *서브 형*\\으로 선언합니다. ``Derived = "
"NewType('Derived', Original)``\\은 정적 형 검사기가 ``Derived``\\를 "
"``Original``\\의 *서브 클래스*\\로 취급하게 합니다. 이는 ``Original`` 형의 값이 ``Derived`` "
"형의 값이 예상되는 위치에서 사용될 수 없음을 의미합니다. 실행 시간 비용을 최소화하면서 논리 에러를 방지하려는 경우에 유용합니다."

#: ../Doc/library/typing.rst:152
msgid "Callable"
msgstr "Callable"

#: ../Doc/library/typing.rst:154
msgid ""
"Frameworks expecting callback functions of specific signatures might be "
"type hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""
"특정 서명의 콜백 함수를 기대하는 프레임워크는 ``Callable[[Arg1Type, Arg2Type], "
"ReturnType]``\\을 사용하여 형 힌트를 제공할 수 있습니다."

#: ../Doc/library/typing.rst:157
msgid "For example::"
msgstr "예를 들면::"

#: ../Doc/library/typing.rst:168
msgid ""
"It is possible to declare the return type of a callable without "
"specifying the call signature by substituting a literal ellipsis for the "
"list of arguments in the type hint: ``Callable[..., ReturnType]``."
msgstr ""
"형 힌트에서 인자 리스트를 리터럴 줄임표(ellipsis)로 대체하여 호출 서명을 지정하지 않고 콜러블의 반환 값을 선언할 수 "
"있습니다: ``Callable[..., ReturnType]``."

#: ../Doc/library/typing.rst:175
msgid "Generics"
msgstr "제네릭"

#: ../Doc/library/typing.rst:177
msgid ""
"Since type information about objects kept in containers cannot be "
"statically inferred in a generic way, abstract base classes have been "
"extended to support subscription to denote expected types for container "
"elements."
msgstr ""
"컨테이너에 보관된 객체에 대한 형 정보는 일반적인 방식으로 정적으로 유추될 수 없기 때문에, 컨테이너 요소에 대해 기대되는 형을 "
"나타내는 서명을 지원하도록 추상 베이스 클래스가 확장되었습니다."

#: ../Doc/library/typing.rst:188
msgid ""
"Generics can be parameterized by using a new factory available in typing "
"called :class:`TypeVar`."
msgstr "제네릭은 :class:`TypeVar`\\라는 typing에서 제공되는 새로운 팩토리를 사용하여 매개 변수화될 수 있습니다."

#: ../Doc/library/typing.rst:203
msgid "User-defined generic types"
msgstr "사용자 정의 제네릭 형"

#: ../Doc/library/typing.rst:205
msgid "A user-defined class can be defined as a generic class."
msgstr "사용자 정의 클래스는 제네릭 클래스로 정의 할 수 있습니다."

#: ../Doc/library/typing.rst:231
msgid ""
"``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes"
" a single type parameter ``T`` . This also makes ``T`` valid as a type "
"within the class body."
msgstr ""
"베이스 클래스로서의 ``Generic[T]``\\는 클래스 ``LoggedVar``\\가 단일한 형 매개 변수 ``T``\\를 "
"취한다는 것을 정의합니다. 이는 또한 ``T``\\를 클래스 바디 내에서 형으로 유효하게 만듭니다."

#: ../Doc/library/typing.rst:235
msgid ""
"The :class:`Generic` base class defines :meth:`__class_getitem__` so that"
" ``LoggedVar[t]`` is valid as a type::"
msgstr ""
":class:`Generic` 베이스 클래스는 ``LoggedVar[t]``\\가 형으로 유효하도록 "
":meth:`__class_getitem__`\\을 정의합니다::"

#: ../Doc/library/typing.rst:244
msgid ""
"A generic type can have any number of type variables, and type variables "
"may be constrained::"
msgstr "제네릭 형은 임의 개수의 형 변수를 가질 수 있으며, 형 변수는 제한될 수 있습니다::"

#: ../Doc/library/typing.rst:256
msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is"
" thus invalid::"
msgstr ":class:`Generic`\\에 대한 각 형 변수 인자는 달라야 합니다. 그래서 이것은 잘못되었습니다::"

#: ../Doc/library/typing.rst:267
msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr ":class:`Generic`\\으로 다중 상속을 사용할 수 있습니다::"

#: ../Doc/library/typing.rst:277
msgid "When inheriting from generic classes, some type variables could be fixed::"
msgstr "제네릭 클래스에서 상속할 때, 일부 형 변수를 고정할 수 있습니다::"

#: ../Doc/library/typing.rst:287
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "이 경우 ``MyDict``\\는 단일 매개 변수 ``T``\\를 갖습니다."

#: ../Doc/library/typing.rst:289
msgid ""
"Using a generic class without specifying type parameters assumes "
":data:`Any` for each position. In the following example, ``MyIterable`` "
"is not generic but implicitly inherits from ``Iterable[Any]``::"
msgstr ""
"형 매개 변수를 지정하지 않고 제네릭 클래스를 사용하는 것은 각 위치에 대해 :data:`Any`\\를 가정합니다. 다음 예제에서,"
" ``MyIterable``\\은 제네릭이 아니지만 ``Iterable[Any]``\\를 묵시적으로 상속합니다::"

#: ../Doc/library/typing.rst:297
msgid "User defined generic type aliases are also supported. Examples::"
msgstr "사용자 정의 제네릭 형 에일리어스도 지원됩니다. 예::"

#: ../Doc/library/typing.rst:314
msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ":class:`Generic`\\에는 더는 사용자 정의 메타 클래스가 없습니다."

#: ../Doc/library/typing.rst:317
msgid ""
"A user-defined generic class can have ABCs as base classes without a "
"metaclass conflict. Generic metaclasses are not supported. The outcome of"
" parameterizing generics is cached, and most types in the typing module "
"are hashable and comparable for equality."
msgstr ""
"사용자 정의 제네릭 클래스는 메타 클래스 충돌 없이 베이스 클래스로 ABC를 가질 수 있습니다. 제네릭 메타 클래스는 지원되지 "
"않습니다. 제네릭을 매개 변수화한 결과가 캐시 되며, typing 모듈의 대부분 형이 해시 가능하고 동등성을 비교할 수 있습니다."

#: ../Doc/library/typing.rst:324
msgid "The :data:`Any` type"
msgstr ":data:`Any` 형"

#: ../Doc/library/typing.rst:326
msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat "
"every type as being compatible with :data:`Any` and :data:`Any` as being "
"compatible with every type."
msgstr ""
"특수한 종류의 형은 :data:`Any`\\입니다. 정적 형 검사기는 모든 형을 :data:`Any`\\와 호환되는 것으로, "
":data:`Any`\\를 모든 형과 호환되는 것으로 취급합니다."

#: ../Doc/library/typing.rst:330
msgid ""
"This means that it is possible to perform any operation or method call on"
" a value of type :data:`Any` and assign it to any variable::"
msgstr ""
"이것은 :data:`Any` 형의 값에 대해 어떤 연산이나 메서드 호출을 수행하고, 그것을 임의의 변수에 대입할 수 있다는 것을 "
"의미합니다::"

#: ../Doc/library/typing.rst:348
msgid ""
"Notice that no typechecking is performed when assigning a value of type "
":data:`Any` to a more precise type. For example, the static type checker "
"did not report an error when assigning ``a`` to ``s`` even though ``s`` "
"was declared to be of type :class:`str` and receives an :class:`int` "
"value at runtime!"
msgstr ""
":data:`Any` 형의 값을 보다 구체적인 형에 대입할 때 형 검사가 수행되지 않음에 유의하십시오. 예를 들어, 정적 형 "
"검사기는 ``s``\\가 형 :class:`str`\\로 선언되고 실행 시간에 :class:`int` 값을 수신하더라도 "
"``a``\\를 ``s``\\에 대입할 때 에러를 보고하지 않았습니다!"

#: ../Doc/library/typing.rst:354
msgid ""
"Furthermore, all functions without a return type or parameter types will "
"implicitly default to using :data:`Any`::"
msgstr "또한, 반환형이나 매개 변수 형이 없는 모든 함수는 묵시적으로 :data:`Any` 기본값을 사용합니다::"

#: ../Doc/library/typing.rst:367
msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you"
" need to mix dynamically and statically typed code."
msgstr ""
"이 동작은 여러분이 동적으로 형이 지정되는 코드와 정적으로 형이 지정되는 코드를 혼합해야 할 때 :data:`Any`\\를 "
"*탈출구*\\로 사용할 수 있도록 합니다."

#: ../Doc/library/typing.rst:370
msgid ""
"Contrast the behavior of :data:`Any` with the behavior of "
":class:`object`. Similar to :data:`Any`, every type is a subtype of "
":class:`object`. However, unlike :data:`Any`, the reverse is not true: "
":class:`object` is *not* a subtype of every other type."
msgstr ""
":data:`Any`\\의 동작과 :class:`object`\\의 동작을 대조하십시오. :data:`Any`\\와 유사하게, 모든"
" 형은 :class:`object`\\의 서브 형입니다. 그러나, :data:`Any`\\와는 달리, 그 반대는 사실이 아닙니다: "
":class:`object`\\는 다른 모든 형의 서브 형이 *아닙*\\니다."

#: ../Doc/library/typing.rst:375
msgid ""
"That means when the type of a value is :class:`object`, a type checker "
"will reject almost all operations on it, and assigning it to a variable "
"(or using it as a return value) of a more specialized type is a type "
"error. For example::"
msgstr ""
"이것은 값의 형이 :class:`object`\\일 때, 형 검사기가 그것에 대한 거의 모든 연산을 거부하고, 그것을 더 특수한 "
"형의 변수에 대입(또는 그것을 반환 값으로 사용)하는 것이 형 에러임을 의미합니다. 예를 들면::"

#: ../Doc/library/typing.rst:397
msgid ""
"Use :class:`object` to indicate that a value could be any type in a "
"typesafe manner. Use :data:`Any` to indicate that a value is dynamically "
"typed."
msgstr ""
"값이 형 안전한 방식으로 모든 형이 될 수 있음을 표시하려면 :class:`object`\\를 사용하십시오. 값이 동적으로 형이 "
"지정됨을 표시하려면 :data:`Any`\\를 사용하십시오."

#: ../Doc/library/typing.rst:402
msgid "Nominal vs structural subtyping"
msgstr "명목적 대 구조적 서브 타이핑"

#: ../Doc/library/typing.rst:404
msgid ""
"Initially :pep:`484` defined Python static type system as using *nominal "
"subtyping*. This means that a class ``A`` is allowed where a class ``B`` "
"is expected if and only if ``A`` is a subclass of ``B``."
msgstr ""
"처음에는 :pep:`484`\\가 파이썬 정적 형 시스템을 *명목적 서브 타이핑(nominal subtyping)*\\을 사용하는 "
"것으로 정의했습니다. 이것은 오직 ``A``\\가 ``B``\\의 서브 클래스일 때만 클래스 ``B``\\가 기대되는 곳에 클래스 "
"``A``\\가 허용됨을 의미합니다."

#: ../Doc/library/typing.rst:408
msgid ""
"This requirement previously also applied to abstract base classes, such "
"as :class:`~collections.abc.Iterable`. The problem with this approach is "
"that a class had to be explicitly marked to support them, which is "
"unpythonic and unlike what one would normally do in idiomatic dynamically"
" typed Python code. For example, this conforms to :pep:`484`::"
msgstr ""
"이 요구 사항은 이전에 :class:`~collections.abc.Iterable`\\과 같은 추상 베이스 클래스에도 "
"적용되었습니다. 이 접근 방식의 문제점은 이것을 지원하려면 클래스를 명시적으로 표시해야만 한다는 점입니다. 이는 파이썬답지 않고 "
"관용적인 동적으로 형이 지정된 파이썬 코드에서 일반적으로 수행하는 것과는 다릅니다. 예를 들어, 이것은 :pep:`484`\\를 "
"만족합니다::"

#: ../Doc/library/typing.rst:421
msgid ""
":pep:`544` allows to solve this problem by allowing users to write the "
"above code without explicit base classes in the class definition, "
"allowing ``Bucket`` to be implicitly considered a subtype of both "
"``Sized`` and ``Iterable[int]`` by static type checkers. This is known as"
" *structural subtyping* (or static duck-typing)::"
msgstr ""
":pep:`544`\\는 사용자가 클래스 정의에서 명시적인 베이스 클래스 없이 위의 코드를 작성할 수 있게 함으로써 이 문제를 "
"풀도록 합니다. 정적 형 검사기가 ``Bucket``\\을 ``Sized``\\와 ``Iterable[int]``\\의 서브 형으로"
" 묵시적으로 취급하도록 합니다. 이것은 *구조적 서브 타이핑(structural subtyping)*\\(또는 정적 덕 타이핑)으로"
" 알려져 있습니다::"

#: ../Doc/library/typing.rst:437
msgid ""
"Moreover, by subclassing a special class :class:`Protocol`, a user can "
"define new custom protocols to fully enjoy structural subtyping (see "
"examples below)."
msgstr ""
"또한, 특별한 클래스 :class:`Protocol`\\을 서브 클래싱 함으로써, 사용자는 새로운 사용자 정의 프로토콜을 정의하여 "
"구조적 서브 타이핑을 완전히 누릴 수 있습니다 (아래 예를 참조하십시오)."

#: ../Doc/library/typing.rst:442
msgid "Module contents"
msgstr "모듈 내용"

#: ../Doc/library/typing.rst:444
msgid "The module defines the following classes, functions and decorators."
msgstr "모듈은 다음 클래스, 함수 및 데코레이터를 정의합니다."

#: ../Doc/library/typing.rst:448
msgid ""
"This module defines several types that are subclasses of pre-existing "
"standard library classes which also extend :class:`Generic` to support "
"type variables inside ``[]``. These types became redundant in Python 3.9 "
"when the corresponding pre-existing classes were enhanced to support "
"``[]``."
msgstr ""
"이 모듈은 ``[]`` 내부의 형 변수를 지원하도록 :class:`Generic`\\를 확장하기도 하는 기존 표준 라이브러리 "
"클래스의 서브 클래스인 여러 형을 정의합니다. 이러한 형은 해당하는 기존 클래스가 ``[]``\\를 지원하도록 개선되었을 때 파이썬"
" 3.9에서 중복되었습니다."

#: ../Doc/library/typing.rst:454
msgid ""
"The redundant types are deprecated as of Python 3.9 but no deprecation "
"warnings will be issued by the interpreter. It is expected that type "
"checkers will flag the deprecated types when the checked program targets "
"Python 3.9 or newer."
msgstr ""
"중복된 형은 파이썬 3.9부터 폐지되었지만, 인터프리터에서 폐지 경고가 발생하지 않습니다. 검사되는 프로그램이 파이썬 3.9 이상을"
" 대상으로 할 때 형 검사기가 폐지된 형을 표시할 것으로 예상됩니다."

#: ../Doc/library/typing.rst:459
msgid ""
"The deprecated types will be removed from the :mod:`typing` module in the"
" first Python version released 5 years after the release of Python 3.9.0."
" See details in :pep:`585`—*Type Hinting Generics In Standard "
"Collections*."
msgstr ""
"폐지된 형은 파이썬 3.9.0 릴리스 5년 후에 릴리스 되는 첫 번째 파이썬 버전의 :mod:`typing` 모듈에서 제거됩니다. "
"자세한 내용은 :pep:`585`-*표준 컬렉션의 형 힌트 제네릭*\\을 참조하십시오."

#: ../Doc/library/typing.rst:465
msgid "Special typing primitives"
msgstr "특수 타이핑 프리미티브"

#: ../Doc/library/typing.rst:468
msgid "Special types"
msgstr "특수형"

#: ../Doc/library/typing.rst:470
msgid "These can be used as types in annotations and do not support ``[]``."
msgstr "이들은 어노테이션에서 형으로 사용할 수 있으며 ``[]``\\를 지원하지 않습니다."

#: ../Doc/library/typing.rst:474
msgid "Special type indicating an unconstrained type."
msgstr "제한되지 않는 형을 나타내는 특수형."

#: ../Doc/library/typing.rst:476
msgid "Every type is compatible with :data:`Any`."
msgstr "모든 형은 :data:`Any`\\와 호환됩니다."

#: ../Doc/library/typing.rst:477
msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any`\\는 모든 형과 호환됩니다."

#: ../Doc/library/typing.rst:481
msgid "Special type indicating that a function never returns. For example::"
msgstr "함수가 절대 반환하지 않는 것을 나타내는 특수한 형. 예를 들면::"

#: ../Doc/library/typing.rst:493
msgid "Special forms"
msgstr "특수 형태"

#: ../Doc/library/typing.rst:495
msgid ""
"These can be used as types in annotations using ``[]``, each having a "
"unique syntax."
msgstr "이들은 ``[]``\\를 사용하여 어노테이션에서 형으로 사용할 수 있는데, 각기 고유한 문법을 가집니다."

#: ../Doc/library/typing.rst:499
msgid ""
"Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items with the "
"first item of type X and the second of type Y. The type of the empty "
"tuple can be written as ``Tuple[()]``."
msgstr ""
"튜플 형; ``Tuple[X, Y]``\\는 첫 번째 항목의 형이 X이고 두 번째 항목의 형이 Y인 두 항목의 튜플 형입니다. 빈 "
"튜플의 형은 ``Tuple[()]``\\로 쓸 수 있습니다."

#: ../Doc/library/typing.rst:503
msgid ""
"Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to "
"type variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an "
"int, a float and a string."
msgstr ""
"예: ``Tuple[T1, T2]``\\는 각각 형 변수 T1과 T2에 해당하는 두 요소의 튜플입니다. ``Tuple[int, "
"float, str]``\\은 int, float 및 문자열의 튜플입니다."

#: ../Doc/library/typing.rst:507
msgid ""
"To specify a variable-length tuple of homogeneous type, use literal "
"ellipsis, e.g. ``Tuple[int, ...]``. A plain :data:`Tuple` is equivalent "
"to ``Tuple[Any, ...]``, and in turn to :class:`tuple`."
msgstr ""
"같은 형의 가변 길이 튜플을 지정하려면 리터럴 생략 부호(ellipsis)를 사용하십시오, 예를 들어 ``Tuple[int, "
"...]``. 단순한 :data:`Tuple`\\은 ``Tuple[Any, ...]``\\와 동등하고, 이는 다시 "
":class:`tuple`\\과 동등합니다."

#: ../Doc/library/typing.rst:511
msgid ""
":class:`builtins.tuple <tuple>` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`builtins.tuple <tuple>`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:517
msgid "Union type; ``Union[X, Y]`` means either X or Y."
msgstr "공용체 형; ``Union[X, Y]``\\는 X나 Y를 의미합니다."

#: ../Doc/library/typing.rst:519
msgid "To define a union, use e.g. ``Union[int, str]``.  Details:"
msgstr "공용체를 정의하려면, 예를 들어 ``Union[int, str]``\\을 사용하십시오. 세부 사항:"

#: ../Doc/library/typing.rst:521
msgid "The arguments must be types and there must be at least one."
msgstr "인자는 형이어야 하며 적어도 하나 있어야 합니다."

#: ../Doc/library/typing.rst:523
msgid "Unions of unions are flattened, e.g.::"
msgstr "공용체의 공용체는 펼쳐집니다, 예를 들어::"

#: ../Doc/library/typing.rst:527
msgid "Unions of a single argument vanish, e.g.::"
msgstr "단일 인자의 공용체는 사라집니다. 예를 들어::"

#: ../Doc/library/typing.rst:531
msgid "Redundant arguments are skipped, e.g.::"
msgstr "중복 인자는 건너뜁니다. 예를 들어::"

#: ../Doc/library/typing.rst:535
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr "공용체를 비교할 때, 인자 순서가 무시됩니다, 예를 들어::"

#: ../Doc/library/typing.rst:539
msgid "You cannot subclass or instantiate a union."
msgstr "공용체를 서브 클래스 화하거나 인스턴스 화할 수 없습니다."

#: ../Doc/library/typing.rst:541
msgid "You cannot write ``Union[X][Y]``."
msgstr "``Union[X][Y]``\\라고 쓸 수 없습니다."

#: ../Doc/library/typing.rst:543
msgid "You can use ``Optional[X]`` as a shorthand for ``Union[X, None]``."
msgstr "``Optional[X]``\\를 ``Union[X, None]``\\의 줄임 표현으로 사용할 수 있습니다."

#: ../Doc/library/typing.rst:545
msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "실행 시간에 공용체의 명시적 서브 클래스를 제거하지 않습니다."

#: ../Doc/library/typing.rst:550
msgid "Optional type."
msgstr "선택적 형."

#: ../Doc/library/typing.rst:552
msgid "``Optional[X]`` is equivalent to ``Union[X, None]``."
msgstr "``Optional[X]``\\는 ``Union[X, None]``\\과 동등합니다."

#: ../Doc/library/typing.rst:554
msgid ""
"Note that this is not the same concept as an optional argument, which is "
"one that has a default.  An optional argument with a default does not "
"require the ``Optional`` qualifier on its type annotation just because it"
" is optional. For example::"
msgstr ""
"이는 기본값을 갖는 선택적 인자와 같은 개념이 아님에 유의하십시오. 단지 선택적이기 때문에 기본값을 갖는 선택적 인자가 형 "
"어노테이션에 ``Optional`` 한정자가 필요하지는 않습니다. 예를 들면::"

#: ../Doc/library/typing.rst:562
msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use "
"of ``Optional`` is appropriate, whether the argument is optional or not. "
"For example::"
msgstr ""
"한편, 명시적인 ``None`` 값이 허용되면, 인자가 선택적인지와 관계없이 ``Optional``\\을 사용하는 것이 적합합니다."
" 예를 들면::"

#: ../Doc/library/typing.rst:571
msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr "콜러블 형; ``Callable[[int], str]``\\은 (int) -> str 인 함수입니다."

#: ../Doc/library/typing.rst:573
msgid ""
"The subscription syntax must always be used with exactly two values: the "
"argument list and the return type.  The argument list must be a list of "
"types or an ellipsis; the return type must be a single type."
msgstr ""
"서브스크립션 문법은 항상 정확히 두 개의 값으로 사용되어야 합니다: 인자 리스트와 반환형. 인자 리스트는 형의 리스트거나 생략 "
"부호(ellipsis)여야 합니다. 반환형은 단일한 형이어야 합니다."

#: ../Doc/library/typing.rst:578
msgid ""
"There is no syntax to indicate optional or keyword arguments; such "
"function types are rarely used as callback types. ``Callable[..., "
"ReturnType]`` (literal ellipsis) can be used to type hint a callable "
"taking any number of arguments and returning ``ReturnType``.  A plain "
":data:`Callable` is equivalent to ``Callable[..., Any]``, and in turn to "
":class:`collections.abc.Callable`."
msgstr ""
"선택적이나 키워드 인자를 나타내는 문법은 없습니다; 그런 함수 형은 거의 콜백 형으로 사용되지 않습니다. "
"``Callable[..., ReturnType]``\\(리터럴 생략 부호)은 임의의 수의 인자를 취하고 "
"``ReturnType``\\을 반환하는 콜러블에 형 힌트를 주는 데 사용할 수 있습니다. 단순한 "
":data:`Callable`\\은 ``Callable[..., Any]``\\와 동등하며, 이는 다시 "
":class:`collections.abc.Callable`\\과 동등합니다."

#: ../Doc/library/typing.rst:586
msgid ""
":class:`collections.abc.Callable` now supports ``[]``. See :pep:`585` and"
" :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Callable`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:592
msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In "
"contrast, a variable annotated with ``Type[C]`` may accept values that "
"are classes themselves -- specifically, it will accept the *class object*"
" of ``C``. For example::"
msgstr ""
"``C``\\로 어노테이트 된 변수는 ``C`` 형의 값을 받아들일 수 있습니다. 대조적으로, ``Type[C]``\\로 어노테이트"
" 된 변수는 클래스 자신인 값을 받아들일 수 있습니다 -- 구체적으로, ``C``\\의 *클래스 객체*\\를 허용합니다. 예를 "
"들면::"

#: ../Doc/library/typing.rst:601
msgid "Note that ``Type[C]`` is covariant::"
msgstr "``Type[C]``\\는 공변적(covariant)입니다::"

#: ../Doc/library/typing.rst:613
msgid ""
"The fact that ``Type[C]`` is covariant implies that all subclasses of "
"``C`` should implement the same constructor signature and class method "
"signatures as ``C``. The type checker should flag violations of this, but"
" should also allow constructor calls in subclasses that match the "
"constructor calls in the indicated base class. How the type checker is "
"required to handle this particular case may change in future revisions of"
" :pep:`484`."
msgstr ""
"``Type[C]``\\가 공변적(covariant)이라는 사실은 ``C``\\의 모든 서브 클래스가 ``C``\\와 같은 생성자 "
"서명과 클래스 메서드 서명을 구현해야 함을 의미합니다. 형 검사기는 이 위반을 표시해야 하지만, 표시된 베이스 클래스의 생성자 "
"호출과 일치하는 서브 클래스의 생성자 호출을 허용해야 합니다. 이 특별한 경우를 처리하기 위한 형 검사기의 요구 사항은 향후 "
":pep:`484` 개정판에서 변경될 수 있습니다."

#: ../Doc/library/typing.rst:621
msgid ""
"The only legal parameters for :class:`Type` are classes, :data:`Any`, "
":ref:`type variables <generics>`, and unions of any of these types. For "
"example::"
msgstr ""
":class:`Type`\\의 합법적인 매개 변수는 클래스, :data:`Any`, :ref:`형 변수 <generics>` 및 "
"이러한 형들의 공용체(union)뿐입니다. 예를 들면::"

#: ../Doc/library/typing.rst:627
msgid ""
"``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent to "
"``type``, which is the root of Python's metaclass hierarchy."
msgstr ""
"``Type[Any]``\\는 ``Type``\\과 동등하며, 이는 다시 파이썬의 메타 클래스 계층 구조의 루트인 "
"``type``\\과 동등합니다."

#: ../Doc/library/typing.rst:632
msgid ""
":class:`builtins.type <type>` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`builtins.type <type>`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:638
msgid ""
"A type that can be used to indicate to type checkers that the "
"corresponding variable or function parameter has a value equivalent to "
"the provided literal (or one of several literals). For example::"
msgstr ""
"대응하는 변수나 함수 매개 변수가 제공된 리터럴(또는 여러 리터럴 중 하나)과 동등한 값을 가짐을 형 검사기에 알리는 데 사용할 수"
" 있는 형. 예를 들면::"

#: ../Doc/library/typing.rst:652
msgid ""
"``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is "
"allowed as type argument to ``Literal[...]``, but type checkers may "
"impose restrictions. See :pep:`586` for more details about literal types."
msgstr ""
"``Literal[...]``\\은 서브 클래싱 될 수 없습니다. 실행 시간에는, 임의의 값이 ``Literal[...]``\\에 "
"대한 형 인자로 허용되지만, 형 검사기는 제한을 부과할 수 있습니다. 리터럴 형에 대한 자세한 내용은 :pep:`586`\\을 "
"참조하십시오."

#: ../Doc/library/typing.rst:658
msgid ""
"``Literal`` now de-duplicates parameters.  Equality comparison of "
"``Literal`` objects are no longer order dependent. ``Literal`` objects "
"will now raise a :exc:`TypeError` exception during equality comparisons "
"if one of their parameters are not :term:`immutable`."
msgstr ""
"``Literal``\\은 이제 매개 변수를 중복 제거합니다. ``Literal`` 객체의 동등 비교는 더는 순서에 종속되지 "
"않습니다. ``Literal`` 객체는 매개 변수 중 하나가 :term:`불변 <immutable>`\\이 아니면 동등성 비교 중에"
" :exc:`TypeError` 예외를 발생시킵니다."

#: ../Doc/library/typing.rst:666
msgid "Special type construct to mark class variables."
msgstr "클래스 변수를 표시하기 위한 특수 형 구조물."

#: ../Doc/library/typing.rst:668
msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar "
"indicates that a given attribute is intended to be used as a class "
"variable and should not be set on instances of that class. Usage::"
msgstr ""
":pep:`526`\\에서 소개된 것처럼, ClassVar로 감싼 변수 어노테이션은 주어진 어트리뷰트가 클래스 변수로 사용되도록 "
"의도되었으며 해당 클래스의 인스턴스에 설정되어서는 안 됨을 나타냅니다. 용법::"

#: ../Doc/library/typing.rst:676
msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ":data:`ClassVar`\\는 형만 받아들이며 더는 서브 스크립트 할 수 없습니다."

#: ../Doc/library/typing.rst:678
msgid ""
":data:`ClassVar` is not a class itself, and should not be used with "
":func:`isinstance` or :func:`issubclass`. :data:`ClassVar` does not "
"change Python runtime behavior, but it can be used by third-party type "
"checkers. For example, a type checker might flag the following code as an"
" error::"
msgstr ""
":data:`ClassVar`\\는 클래스 자체가 아니므로, :func:`isinstance`\\나 "
":func:`issubclass`\\와 함께 사용하면 안 됩니다. :data:`ClassVar`\\는 파이썬 실행 시간 동작을 "
"변경하지 않지만, 제삼자 형 검사기에서 사용할 수 있습니다. 예를 들어, 형 검사기는 다음 코드를 에러로 표시 할 수 있습니다::"

#: ../Doc/library/typing.rst:692
msgid ""
"A special typing construct to indicate to type checkers that a name "
"cannot be re-assigned or overridden in a subclass. For example::"
msgstr "형 검사기에 이름이 다시 대입되거나 서브 클래스에서 재정의될 수 없다는 것을 나타내는 특수한 typing 구조물. 예를 들면::"

#: ../Doc/library/typing.rst:704 ../Doc/library/typing.rst:1616
msgid ""
"There is no runtime checking of these properties. See :pep:`591` for more"
" details."
msgstr "이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 :pep:`591`\\을 참조하십시오."

#: ../Doc/library/typing.rst:711
msgid ""
"A type, introduced in :pep:`593` (``Flexible function and variable "
"annotations``), to decorate existing types with context-specific metadata"
" (possibly multiple pieces of it, as ``Annotated`` is variadic). "
"Specifically, a type ``T`` can be annotated with metadata ``x`` via the "
"typehint ``Annotated[T, x]``. This metadata can be used for either static"
" analysis or at runtime. If a library (or tool) encounters a typehint "
"``Annotated[T, x]`` and has no special logic for metadata ``x``, it "
"should ignore it and simply treat the type as ``T``. Unlike the "
"``no_type_check`` functionality that currently exists in the ``typing`` "
"module which completely disables typechecking annotations on a function "
"or a class, the ``Annotated`` type allows for both static typechecking of"
" ``T`` (e.g., via mypy or Pyre, which can safely ignore ``x``) together "
"with runtime access to ``x`` within a specific application."
msgstr ""
":pep:`593`\\(``Flexible function and variable annotations``)에 도입된, 기존 형을 "
"문맥 별 메타 데이터(``Annotated``\\가 가변적(variadic)이므로 여러 개가 가능합니다)로 데코레이트하는 형. "
"구체적으로, 형 ``T``\\는 형 힌트 ``Annotated[T, x]``\\를 통해 메타 데이터 ``x``\\로 어노테이트될 수"
" 있습니다. 이 메타 데이터는 정적 분석이나 실행 시간에 사용할 수 있습니다. 라이브러리(또는 도구)가 형 힌트 "
"``Annotated[T, x]``\\를 만나고 메타 데이터 ``x``\\에 대한 특별한 논리가 없으면, 이를 무시하고 단순히 형을"
" ``T``\\로 처리해야 합니다. 현재 ``typing`` 모듈에 존재하는, 함수나 클래스에서 형 검사 어노테이션을 완전히 "
"비활성화하는 ``no_type_check`` 기능과 달리, ``Annotated`` 형은 ``T``\\의 정적 형 검사(예를 들어,"
" 안전하게 ``x``\\를 무시할 수 있는, mypy나 Pyre를 통해)와 특정 응용프로그램에서 ``x``\\에 실행 시간 "
"액세스하는 것을 동시에 허용합니다."

#: ../Doc/library/typing.rst:725
msgid ""
"Ultimately, the responsibility of how to interpret the annotations (if at"
" all) is the responsibility of the tool or library encountering the "
"``Annotated`` type. A tool or library encountering an ``Annotated`` type "
"can scan through the annotations to determine if they are of interest "
"(e.g., using ``isinstance()``)."
msgstr ""
"궁극적으로, 어노테이션을 해석하는 방법에 대한 책임은 (있기는 하다면) ``Annotated`` 형을 만나는 도구나 라이브러리의 "
"책임입니다. ``Annotated`` 형을 만나는 도구나 라이브러리는 어노테이션을 통해 스캔하여 관심이 있는 것인지 판별합니다 "
"(예를 들어, ``isinstance()``\\를 사용하여)."

#: ../Doc/library/typing.rst:731
msgid ""
"When a tool or a library does not support annotations or encounters an "
"unknown annotation it should just ignore it and treat annotated type as "
"the underlying type."
msgstr ""
"도구나 라이브러리가 어노테이션을 지원하지 않거나 알 수 없는 어노테이션을 만나면, 이를 무시하고 어노테이트 된 형을 하부 형으로 "
"처리해야 합니다."

#: ../Doc/library/typing.rst:735
msgid ""
"It's up to the tool consuming the annotations to decide whether the "
"client is allowed to have several annotations on one type and how to "
"merge those annotations."
msgstr ""
"클라이언트가 한 형에 여러 어노테이션을 갖도록 허용되는지와 해당 어노테이션들을 병합하는 방법을 결정하는 것은 어노테이션을 소비하는 "
"도구에 달려 있습니다."

#: ../Doc/library/typing.rst:739
msgid ""
"Since the ``Annotated`` type allows you to put several annotations of the"
" same (or different) type(s) on any node, the tools or libraries "
"consuming those annotations are in charge of dealing with potential "
"duplicates. For example, if you are doing value range analysis you might "
"allow this::"
msgstr ""
"``Annotated`` 형을 사용하면 임의의 노드에 같은 (또는 다른) 형의 여러 어노테이션을 넣을 수 있도록 하므로, 이 "
"어노테이션을 소비하는 도구나 라이브러리는 잠재적 중복을 처리해야 합니다. 예를 들어, 값 범위 분석을 수행하는 경우 다음처럼 허용할"
" 수 있습니다::"

#: ../Doc/library/typing.rst:748
msgid ""
"Passing ``include_extras=True`` to :func:`get_type_hints` lets one access"
" the extra annotations at runtime."
msgstr ""
"``include_extras=True``\\를 :func:`get_type_hints`\\로 전달하면 실행 시간에 추가 "
"어노테이션에 액세스 할 수 있습니다."

#: ../Doc/library/typing.rst:751
msgid "The details of the syntax:"
msgstr "문법의 세부 사항:"

#: ../Doc/library/typing.rst:753
msgid "The first argument to ``Annotated`` must be a valid type"
msgstr "``Annotated``\\의 첫 번째 인자는 유효한 형이어야 합니다"

#: ../Doc/library/typing.rst:755
msgid ""
"Multiple type annotations are supported (``Annotated`` supports variadic "
"arguments)::"
msgstr "여러 개의 형 주석이 지원됩니다 (``Annotated``\\는 가변 인자를 지원합니다)::"

#: ../Doc/library/typing.rst:760
msgid ""
"``Annotated`` must be called with at least two arguments ( "
"``Annotated[int]`` is not valid)"
msgstr "``Annotated``\\는 최소한 두 개의 인자로 호출해야 합니다 (``Annotated[int]``\\는 유효하지 않습니다)"

#: ../Doc/library/typing.rst:763
msgid ""
"The order of the annotations is preserved and matters for equality "
"checks::"
msgstr "어노테이션의 순서는 유지되며 동등(equality) 검사의 경우 중요합니다::"

#: ../Doc/library/typing.rst:770
msgid ""
"Nested ``Annotated`` types are flattened, with metadata ordered starting "
"with the innermost annotation::"
msgstr "중첩된 ``Annotated`` 형은 가장 안쪽 주석으로 시작하는 메타 데이터로 평탄화됩니다::"

#: ../Doc/library/typing.rst:777
msgid "Duplicated annotations are not removed::"
msgstr "중복된 어노테이션은 제거되지 않습니다::"

#: ../Doc/library/typing.rst:783
msgid "``Annotated`` can be used with nested and generic aliases::"
msgstr "``Annotated``\\는 중첩되고 제네릭한 에일리어스와 함께 사용할 수 있습니다::"

#: ../Doc/library/typing.rst:794
msgid "Building generic types"
msgstr "제네릭 형 구축하기"

#: ../Doc/library/typing.rst:796
msgid ""
"These are not used in annotations. They are building blocks for creating "
"generic types."
msgstr "이들은 어노테이션에는 사용되지 않습니다. 제네릭 형을 만들기 위한 빌딩 블록입니다."

#: ../Doc/library/typing.rst:800
msgid "Abstract base class for generic types."
msgstr "제네릭 형을 위한 추상 베이스 클래스."

#: ../Doc/library/typing.rst:802
msgid ""
"A generic type is typically declared by inheriting from an instantiation "
"of this class with one or more type variables. For example, a generic "
"mapping type might be defined as::"
msgstr ""
"제네릭 형은 일반적으로 이 클래스를 하나 이상의 형 변수로 인스턴스 화한 것을 상속하여 선언됩니다. 예를 들어, 제네릭 매핑형은 "
"다음과 같이 정의할 수 있습니다::"

#: ../Doc/library/typing.rst:811
msgid "This class can then be used as follows::"
msgstr "이 클래스는 다음과 같이 사용할 수 있습니다::"

#: ../Doc/library/typing.rst:824
msgid "Type variable."
msgstr "형 변수."

#: ../Doc/library/typing.rst:826 ../Doc/library/typing.rst:942
msgid "Usage::"
msgstr "용법::"

#: ../Doc/library/typing.rst:831
msgid ""
"Type variables exist primarily for the benefit of static type checkers.  "
"They serve as the parameters for generic types as well as for generic "
"function definitions.  See :class:`Generic` for more information on "
"generic types.  Generic functions work as follows::"
msgstr ""
"형 변수는 주로 정적 형 검사기를 위해 존재합니다. 이들은 제네릭 함수 정의뿐만 아니라 제네릭 형의 매개 변수 역할을 합니다. "
"제네릭 형에 대한 자세한 내용은 :class:`Generic`\\을 참조하십시오. 제네릭 함수는 다음과 같이 작동합니다::"

#: ../Doc/library/typing.rst:844
msgid ""
"The latter example's signature is essentially the overloading of ``(str, "
"str) -> str`` and ``(bytes, bytes) -> bytes``.  Also note that if the "
"arguments are instances of some subclass of :class:`str`, the return type"
" is still plain :class:`str`."
msgstr ""
"후자의 예의 서명은 기본적으로 ``(str, str) -> str``\\과 ``(bytes, bytes) -> bytes``\\의 "
"오버로딩입니다. 또한 인자가 :class:`str`\\의 어떤 서브 클래스의 인스턴스면 반환형은 여전히 일반 "
":class:`str`\\임에 유의하십시오."

#: ../Doc/library/typing.rst:849
msgid ""
"At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In "
"general, :func:`isinstance` and :func:`issubclass` should not be used "
"with types."
msgstr ""
"실행 시간에, ``isinstance(x, T)``\\는 :exc:`TypeError`\\를 발생시킵니다. 일반적으로, "
":func:`isinstance`\\와 :func:`issubclass`\\는 형과 함께 사용하면 안 됩니다."

#: ../Doc/library/typing.rst:852
msgid ""
"Type variables may be marked covariant or contravariant by passing "
"``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more "
"details.  By default type variables are invariant.  Alternatively, a type"
" variable may specify an upper bound using ``bound=<type>``. This means "
"that an actual type substituted (explicitly or implicitly) for the type "
"variable must be a subclass of the boundary type, see :pep:`484`."
msgstr ""
"형 변수는 ``covariant=True``\\나 ``contravariant=True``\\를 전달하여 "
"공변적(covariant)이나 반변적(contravariant)으로 표시될 수 있습니다. 자세한 내용은 :pep:`484`\\를 "
"참조하십시오. 기본적으로 형 변수는 불변적(invariant)입니다. 대안적으로, 형 변수는 ``bound=<type>``\\을 "
"사용하여 상한을 지정할 수 있습니다. 이것은 형 변수에 (명시적으로나 묵시적으로) 치환되는 실제 형이 상한 형의 서브 클래스여야 "
"함을 의미합니다, :pep:`484`\\를 참조하십시오."

#: ../Doc/library/typing.rst:862
msgid ""
"``AnyStr`` is a type variable defined as ``AnyStr = TypeVar('AnyStr', "
"str, bytes)``."
msgstr "``AnyStr``\\은 ``AnyStr = TypeVar('AnyStr', str, bytes)``\\로 정의된 형 변수입니다."

#: ../Doc/library/typing.rst:865
msgid ""
"It is meant to be used for functions that may accept any kind of string "
"without allowing different kinds of strings to mix. For example::"
msgstr "다른 종류의 문자열을 섞지 않고 모든 종류의 문자열을 받아들일 수 있는 함수에 사용하기 위한 것입니다. 예를 들면::"

#: ../Doc/library/typing.rst:877
msgid "Base class for protocol classes. Protocol classes are defined like this::"
msgstr "프로토콜 클래스의 베이스 클래스. 프로토콜 클래스는 다음과 같이 정의됩니다::"

#: ../Doc/library/typing.rst:883
msgid ""
"Such classes are primarily used with static type checkers that recognize "
"structural subtyping (static duck-typing), for example::"
msgstr "이러한 클래스는 주로 구조적 서브 타이핑(정적 덕 타이핑)을 인식하는 정적 형 검사기와 함께 사용됩니다, 예를 들어::"

#: ../Doc/library/typing.rst:895
msgid ""
"See :pep:`544` for details. Protocol classes decorated with "
":func:`runtime_checkable` (described later) act as simple-minded runtime "
"protocols that check only the presence of given attributes, ignoring "
"their type signatures."
msgstr ""
"자세한 내용은 :pep:`544`\\를 참조하십시오. :func:`runtime_checkable`\\(아래에서 설명합니다)로 "
"데코레이트 된 프로토콜 클래스는 주어진 어트리뷰트의 존재 여부만 확인하고 형 서명을 무시하는 단순한 실행 시간 프로토콜로 "
"작동합니다."

#: ../Doc/library/typing.rst:900
msgid "Protocol classes can be generic, for example::"
msgstr "프로토콜 클래스는 제네릭일 수 있습니다, 예를 들어::"

#: ../Doc/library/typing.rst:910
msgid "Mark a protocol class as a runtime protocol."
msgstr "프로토콜 클래스를 실행 시간 프로토콜로 표시합니다."

#: ../Doc/library/typing.rst:912
msgid ""
"Such a protocol can be used with :func:`isinstance` and "
":func:`issubclass`. This raises :exc:`TypeError` when applied to a non-"
"protocol class.  This allows a simple-minded structural check, very "
"similar to \"one trick ponies\" in :mod:`collections.abc` such as "
":class:`~collections.abc.Iterable`.  For example::"
msgstr ""
"이러한 프로토콜은 :func:`isinstance`\\와 :func:`issubclass`\\와 함께 사용할 수 있습니다. 이것은 "
"비 프로토콜 클래스에 적용될 때 :exc:`TypeError`\\를 발생시킵니다. 이것은 "
":mod:`collections.abc`\\에 있는 :class:`~collections.abc.Iterable`\\처럼 \"한 "
"가지만 잘하는\" 것과 매우 유사한 단순한 구조적 검사를 허용합니다. 예를 들면::"

#: ../Doc/library/typing.rst:925
msgid ""
":func:`runtime_checkable` will check only the presence of the required "
"methods, not their type signatures! For example, :class:`builtins.complex"
" <complex>` implements :func:`__float__`, therefore it passes an "
":func:`issubclass` check against :class:`SupportsFloat`. However, the "
"``complex.__float__`` method exists only to raise a :class:`TypeError` "
"with a more informative message."
msgstr ""
":func:`runtime_checkable`\\은 필요한 메서드의 존재만 검사할 뿐, 그것들의 형 서명은 검사하지 않습니다! 예를"
" 들어, :class:`builtins.complex <complex>`\\는 :func:`__float__`\\를 구현하므로, "
":class:`SupportsFloat`\\에 대해 :func:`issubclass` 검사를 통과합니다. 그러나, "
"``complex.__float__`` 메서드는 더 많은 정보를 제공하는 메시지와 함께 :class:`TypeError`\\를 "
"발생시키기 위해서만 존재합니다."

#: ../Doc/library/typing.rst:934
msgid "Other special directives"
msgstr "기타 특수 지시자"

#: ../Doc/library/typing.rst:936
msgid ""
"These are not used in annotations. They are building blocks for declaring"
" types."
msgstr "이들은 어노테이션에는 사용되지 않습니다. 형 선언을 위한 빌딩 블록입니다."

#: ../Doc/library/typing.rst:940
msgid "Typed version of :func:`collections.namedtuple`."
msgstr "형 지정된(typed) :func:`collections.namedtuple` 버전."

#: ../Doc/library/typing.rst:948
msgid "This is equivalent to::"
msgstr "이것은 다음과 동등합니다::"

#: ../Doc/library/typing.rst:952
msgid "To give a field a default value, you can assign to it in the class body::"
msgstr "필드에 기본값을 부여하려면, 클래스 바디에서 그 값을 대입할 수 있습니다::"

#: ../Doc/library/typing.rst:961
msgid "Fields with a default value must come after any fields without a default."
msgstr "기본값이 있는 필드는 기본값이 없는 모든 필드 뒤에 와야 합니다."

#: ../Doc/library/typing.rst:963
msgid ""
"The resulting class has an extra attribute ``__annotations__`` giving a "
"dict that maps the field names to the field types.  (The field names are "
"in the ``_fields`` attribute and the default values are in the "
"``_field_defaults`` attribute both of which are part of the namedtuple "
"API.)"
msgstr ""
"결과 클래스에는 필드 이름을 필드형에 매핑하는 딕셔너리를 제공하는 추가 어트리뷰트 ``__annotations__``\\가 "
"있습니다. (필드 이름은 ``_fields`` 어트리뷰트에 있고 기본값은 ``_field_defaults`` 어트리뷰트에 있는데, "
"모두 namedtuple API의 일부입니다.)"

#: ../Doc/library/typing.rst:969
msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr "``NamedTuple`` 서브 클래스는 독스트링과 메서드도 가질 수 있습니다::"

#: ../Doc/library/typing.rst:979
msgid "Backward-compatible usage::"
msgstr "이전 버전과 호환되는 사용법::"

#: ../Doc/library/typing.rst:983
msgid "Added support for :pep:`526` variable annotation syntax."
msgstr ":pep:`526` 변수 어노테이션 문법 지원을 추가했습니다."

#: ../Doc/library/typing.rst:986
msgid "Added support for default values, methods, and docstrings."
msgstr "기본값, 메서드 및 독스트링에 대한 지원을 추가했습니다."

#: ../Doc/library/typing.rst:989
msgid ""
"The ``_field_types`` and ``__annotations__`` attributes are now regular "
"dictionaries instead of instances of ``OrderedDict``."
msgstr ""
"``_field_types``\\와 ``__annotations__`` 어트리뷰트는 이제 ``OrderedDict`` 인스턴스가 "
"아닌 일반 딕셔너리입니다."

#: ../Doc/library/typing.rst:993
msgid ""
"Removed the ``_field_types`` attribute in favor of the more standard "
"``__annotations__`` attribute which has the same information."
msgstr ""
"``_field_types`` 어트리뷰트를 제거하고, 같은 정보를 가지는 더 표준적인 ``__annotations__`` "
"어트리뷰트로 대체했습니다."

#: ../Doc/library/typing.rst:999
msgid ""
"A helper function to indicate a distinct type to a typechecker, see "
":ref:`distinct`. At runtime it returns a function that returns its "
"argument. Usage::"
msgstr ""
"형 검사기에 구별되는 형을 가리키는 도우미 함수, :ref:`distinct`\\을 참조하십시오. 실행 시간에 인자를 반환하는 "
"함수를 반환합니다. 용법::"

#: ../Doc/library/typing.rst:1010
msgid ""
"Special construct to add type hints to a dictionary. At runtime it is a "
"plain :class:`dict`."
msgstr "딕셔너리에 형 힌트를 추가하는 특수 구조. 실행 시간에 일반 :class:`dict`\\입니다."

#: ../Doc/library/typing.rst:1013
msgid ""
"``TypedDict`` declares a dictionary type that expects all of its "
"instances to have a certain set of keys, where each key is associated "
"with a value of a consistent type. This expectation is not checked at "
"runtime but is only enforced by type checkers. Usage::"
msgstr ""
"``TypedDict``\\는 모든 인스턴스가 각 키가 일관된 형의 값에 연관되는, 특정한 키 집합을 갖도록 기대되는 딕셔너리 형을"
" 선언합니다. 이 기대는 실행 시간에는 검사되지 않고, 형 검사기에서만 강제됩니다. 사용법::"

#: ../Doc/library/typing.rst:1029
msgid ""
"The type info for introspection can be accessed via "
"``Point2D.__annotations__`` and ``Point2D.__total__``.  To allow using "
"this feature with older versions of Python that do not support "
":pep:`526`, ``TypedDict`` supports two additional equivalent syntactic "
"forms::"
msgstr ""
"인트로스펙션을 위한 형 정보는 ``Point2D.__annotations__``\\와 ``Point2D.__total__``\\을 "
"통해 액세스할 수 있습니다. :pep:`526`\\을 지원하지 않는 이전 버전의 파이썬에서 이 기능을 사용하도록 하기 위해, "
"``TypedDict``\\는 두 개의 추가 문법 형식을 지원합니다::"

#: ../Doc/library/typing.rst:1037
msgid ""
"By default, all keys must be present in a TypedDict. It is possible to "
"override this by specifying totality. Usage::"
msgstr "기본적으로 모든 키는 TypedDict에 있어야 합니다. total을 지정하여 이를 재정의할 수 있습니다. 용법::"

#: ../Doc/library/typing.rst:1045
msgid ""
"This means that a point2D TypedDict can have any of the keys omitted. A "
"type checker is only expected to support a literal False or True as the "
"value of the total argument. True is the default, and makes all items "
"defined in the class body be required."
msgstr ""
"이것은 point2D TypedDict는 모든 키를 생략 할 수 있다는 뜻입니다. 형 검사기는 total 인자의 값으로 리터럴 "
"False나 True만 지원해야 합니다. 기본값은 True이며, 클래스 본문에 정의된 모든 항목이 필수가 되도록 합니다."

#: ../Doc/library/typing.rst:1050
msgid ""
"See :pep:`589` for more examples and detailed rules of using "
"``TypedDict``."
msgstr "추가 예제와 ``TypedDict``\\를 사용하는 자세한 규칙은 :pep:`589`\\를 참조하십시오."

#: ../Doc/library/typing.rst:1055
msgid "Generic concrete collections"
msgstr "제네릭 구상 컬렉션"

#: ../Doc/library/typing.rst:1058
msgid "Corresponding to built-in types"
msgstr "내장형에 해당하는 것들"

#: ../Doc/library/typing.rst:1062
msgid ""
"A generic version of :class:`dict`. Useful for annotating return types. "
"To annotate arguments it is preferred to use an abstract collection type "
"such as :class:`Mapping`."
msgstr ""
":class:`dict`\\의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 "
":class:`Mapping`\\과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다."

#: ../Doc/library/typing.rst:1066
msgid "This type can be used as follows::"
msgstr "이 형은 다음과 같이 사용할 수 있습니다::"

#: ../Doc/library/typing.rst:1071
msgid ""
":class:`builtins.dict <dict>` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`builtins.dict <dict>`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1077
msgid ""
"Generic version of :class:`list`. Useful for annotating return types. To "
"annotate arguments it is preferred to use an abstract collection type "
"such as :class:`Sequence` or :class:`Iterable`."
msgstr ""
":class:`list`\\의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 "
":class:`Sequence`\\나 :class:`Iterable`\\과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다."

#: ../Doc/library/typing.rst:1082
msgid "This type may be used as follows::"
msgstr "이 형은 다음과 같이 사용될 수 있습니다::"

#: ../Doc/library/typing.rst:1092
msgid ""
":class:`builtins.list <list>` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`builtins.list <list>`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1098
msgid ""
"A generic version of :class:`builtins.set <set>`. Useful for annotating "
"return types. To annotate arguments it is preferred to use an abstract "
"collection type such as :class:`AbstractSet`."
msgstr ""
":class:`builtins.set <set>`\\의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 "
"하려면 :class:`AbstractSet`\\과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다."

#: ../Doc/library/typing.rst:1102
msgid ""
":class:`builtins.set <set>` now supports ``[]``. See :pep:`585` and :ref"
":`types-genericalias`."
msgstr ""
":class:`builtins.set <set>`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1108
msgid "A generic version of :class:`builtins.frozenset <frozenset>`."
msgstr ":class:`builtins.frozenset <frozenset>`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1110
msgid ""
":class:`builtins.frozenset <frozenset>` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.frozenset <frozenset>`\\은 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1114
msgid ":data:`Tuple` is a special form."
msgstr ":data:`Tuple`\\은 특수 형태입니다."

#: ../Doc/library/typing.rst:1117
msgid "Corresponding to types in :mod:`collections`"
msgstr ":mod:`collections`\\의 형에 해당하는 것들"

#: ../Doc/library/typing.rst:1121
msgid "A generic version of :class:`collections.defaultdict`."
msgstr ":class:`collections.defaultdict`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1125
msgid ""
":class:`collections.defaultdict` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`collections.defaultdict`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1131
msgid "A generic version of :class:`collections.OrderedDict`."
msgstr ":class:`collections.OrderedDict`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1135
msgid ""
":class:`collections.OrderedDict` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`collections.OrderedDict`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1141
msgid "A generic version of :class:`collections.ChainMap`."
msgstr ":class:`collections.ChainMap`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1146
msgid ""
":class:`collections.ChainMap` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`collections.ChainMap`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1152
msgid "A generic version of :class:`collections.Counter`."
msgstr ":class:`collections.Counter`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1157
msgid ""
":class:`collections.Counter` now supports ``[]``. See :pep:`585` and :ref"
":`types-genericalias`."
msgstr ""
":class:`collections.Counter`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1163
msgid "A generic version of :class:`collections.deque`."
msgstr ":class:`collections.deque`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1168
msgid ""
":class:`collections.deque` now supports ``[]``. See :pep:`585` and :ref"
":`types-genericalias`."
msgstr ""
":class:`collections.deque`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1173
msgid "Other concrete types"
msgstr "기타 구상형"

#: ../Doc/library/typing.rst:1179
msgid ""
"Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as "
"returned by :func:`open`. These types are also in the ``typing.io`` "
"namespace."
msgstr ""
"제네릭 형 ``IO[AnyStr]``\\와 서브 클래스 ``TextIO(IO[str])`` 및 "
"``BinaryIO(IO[bytes])``\\는 :func:`open`\\에 의해 반환되는 것과 같은 I/O 스트림 형을 "
"나타냅니다. 이러한 형들은 ``typing.io`` 이름 공간에도 있습니다."

#: ../Doc/library/typing.rst:1187
msgid ""
"These type aliases correspond to the return types from :func:`re.compile`"
" and :func:`re.match`.  These types (and the corresponding functions) are"
" generic in ``AnyStr`` and can be made specific by writing "
"``Pattern[str]``, ``Pattern[bytes]``, ``Match[str]``, or "
"``Match[bytes]``. These types are also in the ``typing.re`` namespace."
msgstr ""
"이 형 에일리어스는 :func:`re.compile`\\과 :func:`re.match`\\의 반환형에 해당합니다. 이러한 형(및 "
"해당 함수)은 ``AnyStr``\\로 제네릭하며 ``Pattern[str]``, ``Pattern[bytes]``, "
"``Match[str]`` 또는 ``Match[bytes]``\\로 써서 구체적으로 만들 수 있습니다. 이러한 형들은 "
"``typing.re`` 이름 공간에도 있습니다."

#: ../Doc/library/typing.rst:1194
msgid ""
"Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":mod:`re`\\의 클래스 ``Pattern``\\과 ``Match``\\는 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1200
msgid ""
"``Text`` is an alias for ``str``. It is provided to supply a forward "
"compatible path for Python 2 code: in Python 2, ``Text`` is an alias for "
"``unicode``."
msgstr ""
"``Text``\\는 ``str``\\의 별칭입니다. 파이썬 2 코드를 위한 상위 호환 경로를 제공하기 위해 제공됩니다: 파이썬 "
"2에서, ``Text``\\는 ``unicode``\\의 별칭입니다."

#: ../Doc/library/typing.rst:1204
msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a "
"manner that is compatible with both Python 2 and Python 3::"
msgstr "``Text``\\를 사용하여 값이 파이썬 2와 파이썬 3 모두와 호환되는 방식으로 유니코드 문자열을 포함해야 함을 나타내십시오::"

#: ../Doc/library/typing.rst:1213
msgid "Abstract Base Classes"
msgstr "추상 베이스 클래스"

#: ../Doc/library/typing.rst:1216
msgid "Corresponding to collections in :mod:`collections.abc`"
msgstr ":mod:`collections.abc`\\의 컬렉션에 해당하는 것들"

#: ../Doc/library/typing.rst:1220
msgid "A generic version of :class:`collections.abc.Set`."
msgstr ":class:`collections.abc.Set`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1222
msgid ""
":class:`collections.abc.Set` now supports ``[]``. See :pep:`585` and :ref"
":`types-genericalias`."
msgstr ""
":class:`collections.abc.Set`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 :ref"
":`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1228
msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr ":class:`collections.abc.ByteString`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1230
msgid ""
"This type represents the types :class:`bytes`, :class:`bytearray`, and "
":class:`memoryview` of byte sequences."
msgstr ""
"이 형은 :class:`bytes`, :class:`bytearray` 및 바이트 시퀀스의 :class:`memoryview` 형을"
" 나타냅니다."

#: ../Doc/library/typing.rst:1233
msgid ""
"As a shorthand for this type, :class:`bytes` can be used to annotate "
"arguments of any of the types mentioned above."
msgstr "이 형의 줄임 표현으로, :class:`bytes`\\는 위에 언급된 모든 형의 인자를 어노테이트하는 데 사용될 수 있습니다."

#: ../Doc/library/typing.rst:1236
msgid ""
":class:`collections.abc.ByteString` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ByteString`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1242
msgid "A generic version of :class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`\\의 제네릭 버전"

#: ../Doc/library/typing.rst:1246
msgid ""
":class:`collections.abc.Collection` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Collection`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1252
msgid "A generic version of :class:`collections.abc.Container`."
msgstr ":class:`collections.abc.Container`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1254
msgid ""
":class:`collections.abc.Container` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Container`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1260
msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr ":class:`collections.abc.ItemsView`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1262
msgid ""
":class:`collections.abc.ItemsView` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ItemsView`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1268
msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr ":class:`collections.abc.KeysView`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1270
msgid ""
":class:`collections.abc.KeysView` now supports ``[]``. See :pep:`585` and"
" :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.KeysView`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1276
msgid ""
"A generic version of :class:`collections.abc.Mapping`. This type can be "
"used as follows::"
msgstr ":class:`collections.abc.Mapping`\\의 제네릭 버전. 이 형은 다음과 같이 사용할 수 있습니다::"

#: ../Doc/library/typing.rst:1282
msgid ""
":class:`collections.abc.Mapping` now supports ``[]``. See :pep:`585` and "
":ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Mapping`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1288
msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr ":class:`collections.abc.MappingView`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1290
msgid ""
":class:`collections.abc.MappingView` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MappingView`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와"
" :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1296
msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr ":class:`collections.abc.MutableMapping`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1298
msgid ""
":class:`collections.abc.MutableMapping` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableMapping`\\은 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1304
msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr ":class:`collections.abc.MutableSequence`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1306
msgid ""
":class:`collections.abc.MutableSequence` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSequence`\\는 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1312
msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr ":class:`collections.abc.MutableSet`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1314
msgid ""
":class:`collections.abc.MutableSet` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSet`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1320
msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr ":class:`collections.abc.Sequence`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1322
msgid ""
":class:`collections.abc.Sequence` now supports ``[]``. See :pep:`585` and"
" :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Sequence`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1328
msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr ":class:`collections.abc.ValuesView`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1330
msgid ""
":class:`collections.abc.ValuesView` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ValuesView`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1335
msgid "Corresponding to other types in :mod:`collections.abc`"
msgstr ":mod:`collections.abc`\\의 기타 형에 해당하는 것들"

#: ../Doc/library/typing.rst:1339
msgid "A generic version of :class:`collections.abc.Iterable`."
msgstr ":class:`collections.abc.Iterable`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1341
msgid ""
":class:`collections.abc.Iterable` now supports ``[]``. See :pep:`585` and"
" :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterable`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1347
msgid "A generic version of :class:`collections.abc.Iterator`."
msgstr ":class:`collections.abc.Iterator`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1349
msgid ""
":class:`collections.abc.Iterator` now supports ``[]``. See :pep:`585` and"
" :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterator`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1355
msgid ""
"A generator can be annotated by the generic type ``Generator[YieldType, "
"SendType, ReturnType]``. For example::"
msgstr ""
"제너레이터는 제네릭 형 ``Generator[YieldType, SendType, ReturnType]``\\으로 어노테이트할 수 "
"있습니다. 예를 들면::"

#: ../Doc/library/typing.rst:1364
msgid ""
"Note that unlike many other generics in the typing module, the "
"``SendType`` of :class:`Generator` behaves contravariantly, not "
"covariantly or invariantly."
msgstr ""
"typing 모듈의 다른 많은 제네릭과 달리 :class:`Generator`\\의 ``SendType``\\은 "
"공변적(covariant)이거나 불변적(invariant)이 아니라 반변적(contravariant)으로 행동함에 유의하십시오."

#: ../Doc/library/typing.rst:1368
msgid ""
"If your generator will only yield values, set the ``SendType`` and "
"``ReturnType`` to ``None``::"
msgstr ""
"제너레이터가 값을 일드(yield)하기만 하면, ``SendType``\\과 ``ReturnType``\\을 ``None``\\으로"
" 설정하십시오::"

#: ../Doc/library/typing.rst:1376
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""
"또는, ``Iterable[YieldType]``\\이나 ``Iterator[YieldType]`` 중 하나의 반환형을 갖는 것으로"
" 제너레이터를 어노테이트 하십시오::"

#: ../Doc/library/typing.rst:1384
msgid ""
":class:`collections.abc.Generator` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Generator`\\는 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1390
msgid "An alias to :class:`collections.abc.Hashable`"
msgstr ":class:`collections.abc.Hashable`\\에 대한 별칭"

#: ../Doc/library/typing.rst:1394
msgid "A generic version of :class:`collections.abc.Reversible`."
msgstr ":class:`collections.abc.Reversible`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1396
msgid ""
":class:`collections.abc.Reversible` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Reversible`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1402
msgid "An alias to :class:`collections.abc.Sized`"
msgstr ":class:`collections.abc.Sized`\\에 대한 별칭"

#: ../Doc/library/typing.rst:1405
msgid "Asynchronous programming"
msgstr "비동기 프로그래밍"

#: ../Doc/library/typing.rst:1409
msgid ""
"A generic version of :class:`collections.abc.Coroutine`. The variance and"
" order of type variables correspond to those of :class:`Generator`, for "
"example::"
msgstr ""
":class:`collections.abc.Coroutine`\\의 제네릭 버전. 형 변수의 변화와 순서는 "
":class:`Generator`\\의 것과 같습니다, 예를 들어::"

#: ../Doc/library/typing.rst:1422
msgid ""
":class:`collections.abc.Coroutine` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Coroutine`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1428
msgid ""
"An async generator can be annotated by the generic type "
"``AsyncGenerator[YieldType, SendType]``. For example::"
msgstr ""
"비동기 제너레이터는 제네릭 형 ``AsyncGenerator[YieldType, SendType]``\\으로 어노테이트할 수 "
"있습니다. 예를 들면::"

#: ../Doc/library/typing.rst:1437
msgid ""
"Unlike normal generators, async generators cannot return a value, so "
"there is no ``ReturnType`` type parameter. As with :class:`Generator`, "
"the ``SendType`` behaves contravariantly."
msgstr ""
"일반 제너레이터와 달리, 비동기 제너레이터는 값을 반환할 수 없기 때문에, ``ReturnType`` 형 매개 변수가 없습니다. "
":class:`Generator`\\와 마찬가지로, ``SendType``\\은 반변적(contravariant)으로 행동합니다."

#: ../Doc/library/typing.rst:1441
msgid ""
"If your generator will only yield values, set the ``SendType`` to "
"``None``::"
msgstr "제너레이터가 값을 일드(yield)하기만 하면, ``SendType``\\을 ``None``\\으로 설정하십시오::"

#: ../Doc/library/typing.rst:1449
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""
"또는, ``AsyncIterable[YieldType]``\\이나 ``AsyncIterator[YieldType]`` 중 하나의 "
"반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오::"

#: ../Doc/library/typing.rst:1459
msgid ""
":class:`collections.abc.AsyncGenerator` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncGenerator`\\는 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1465
msgid "A generic version of :class:`collections.abc.AsyncIterable`."
msgstr ":class:`collections.abc.AsyncIterable`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1469
msgid ""
":class:`collections.abc.AsyncIterable` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterable`\\은 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1475
msgid "A generic version of :class:`collections.abc.AsyncIterator`."
msgstr ":class:`collections.abc.AsyncIterator`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1479
msgid ""
":class:`collections.abc.AsyncIterator` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterator`\\는 이제 ``[]``\\를 지원합니다. "
":pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1485
msgid "A generic version of :class:`collections.abc.Awaitable`."
msgstr ":class:`collections.abc.Awaitable`\\의 제네릭 버전."

#: ../Doc/library/typing.rst:1489
msgid ""
":class:`collections.abc.Awaitable` now supports ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Awaitable`\\은 이제 ``[]``\\를 지원합니다. :pep:`585`\\와 "
":ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1495
msgid "Context manager types"
msgstr "컨텍스트 관리자 형"

#: ../Doc/library/typing.rst:1499
msgid "A generic version of :class:`contextlib.AbstractContextManager`."
msgstr ":class:`contextlib.AbstractContextManager` 의 제네릭 버전."

#: ../Doc/library/typing.rst:1504
msgid ""
":class:`contextlib.AbstractContextManager` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.contextlib.AbstractContextManager`\\는 이제 ``[]``\\를 "
"지원합니다. :pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1510
msgid "A generic version of :class:`contextlib.AbstractAsyncContextManager`."
msgstr ":class:`contextlib.AbstractAsyncContextManager` 의 제네릭 버전."

#: ../Doc/library/typing.rst:1515
msgid ""
":class:`contextlib.AbstractAsyncContextManager` now supports ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.contextlib.AbstractAsyncContextManager`\\는 이제 "
"``[]``\\를 지원합니다. :pep:`585`\\와 :ref:`types-genericalias`\\을 참조하십시오."

#: ../Doc/library/typing.rst:1520
msgid "Protocols"
msgstr "프로토콜"

#: ../Doc/library/typing.rst:1522
msgid "These protocols are decorated with :func:`runtime_checkable`."
msgstr "이 프로토콜은 :func:`runtime_checkable`\\로 데코레이트 되어 있습니다."

#: ../Doc/library/typing.rst:1526
msgid ""
"An ABC with one abstract method ``__abs__`` that is covariant in its "
"return type."
msgstr "반환형이 공변적(covariant)인 하나의 추상 메서드 ``__abs__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1531
msgid "An ABC with one abstract method ``__bytes__``."
msgstr "하나의 추상 메서드 ``__bytes__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1535
msgid "An ABC with one abstract method ``__complex__``."
msgstr "하나의 추상 메서드 ``__complex__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1539
msgid "An ABC with one abstract method ``__float__``."
msgstr "하나의 추상 메서드 ``__float__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1543
msgid "An ABC with one abstract method ``__index__``."
msgstr "하나의 추상 메서드 ``__index__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1549
msgid "An ABC with one abstract method ``__int__``."
msgstr "하나의 추상 메서드 ``__int__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1553
msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its "
"return type."
msgstr "반환형이 공변적(covariant)인 하나의 추상 메서드 ``__round__``\\를 가진 ABC."

#: ../Doc/library/typing.rst:1557
msgid "Functions and decorators"
msgstr "함수와 데코레이터"

#: ../Doc/library/typing.rst:1561
msgid "Cast a value to a type."
msgstr "값을 형으로 변환합니다."

#: ../Doc/library/typing.rst:1563
msgid ""
"This returns the value unchanged.  To the type checker this signals that "
"the return value has the designated type, but at runtime we intentionally"
" don't check anything (we want this to be as fast as possible)."
msgstr ""
"값을 변경하지 않고 반환합니다. 형 검사기에서는 반환 값이 지정된 형임을 나타내지만, 실행 시간에는 의도적으로 아무것도 확인하지 "
"않습니다 (우리는 이것이 가능한 한 빠르기를 원합니다)."

#: ../Doc/library/typing.rst:1570
msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types. A series of "
"``@overload``-decorated definitions must be followed by exactly one "
"non-``@overload``-decorated definition (for the same function/method). "
"The ``@overload``-decorated definitions are for the benefit of the type "
"checker only, since they will be overwritten by the "
"non-``@overload``-decorated definition, while the latter is used at "
"runtime but should be ignored by a type checker.  At runtime, calling a "
"``@overload``-decorated function directly will raise "
":exc:`NotImplementedError`. An example of overload that gives a more "
"precise type than can be expressed using a union or a type variable::"
msgstr ""
"``@overload`` 데코레이터는 여러 가지 다양한 인자형의 조합을 지원하는 함수와 메서드를 기술할 수 있도록 합니다. "
"``@overload``\\로 데코레이트 된 일련의 정의에는 (같은 함수/메서드에 대해) 정확히 하나의 "
"``@overload``\\로 데코레이트 되지 않은 정의가 뒤따라야 합니다. ``@overload``\\로 데코레이트 된 정의는 "
"``@overload``\\로 데코레이트 되지 않은 정의에 의해 덮어 쓰이기 때문에 형 검사기만을 위한 것입니다. 후자는 실행 "
"시간에 사용되지만, 형 검사기에서는 무시되어야 합니다. 실행 시간에, ``@overload``\\로 데코레이트 된 함수를 직접 "
"호출하면 :exc:`NotImplementedError` 가 발생합니다. 공용체(union)나 형 변수를 사용하여 표현할 수 있는 "
"것보다 더 정밀한 형을 제공하는 오버로드의 예::"

#: ../Doc/library/typing.rst:1594
msgid "See :pep:`484` for details and comparison with other typing semantics."
msgstr "자세한 내용과 다른 typing 의미와의 비교는 :pep:`484`\\를 참조하십시오."

#: ../Doc/library/typing.rst:1598
msgid ""
"A decorator to indicate to type checkers that the decorated method cannot"
" be overridden, and the decorated class cannot be subclassed. For "
"example::"
msgstr ""
"데코레이트 된 메서드가 재정의될 수 없고, 데코레이트 된 클래스가 서브 클래싱 될 수 없음을 형 검사기에 알리는 데코레이터. 예를 "
"들면::"

#: ../Doc/library/typing.rst:1623
msgid "Decorator to indicate that annotations are not type hints."
msgstr "어노테이션이 형 힌트가 아님을 나타내는 데코레이터."

#: ../Doc/library/typing.rst:1625
msgid ""
"This works as class or function :term:`decorator`.  With a class, it "
"applies recursively to all methods defined in that class (but not to "
"methods defined in its superclasses or subclasses)."
msgstr ""
"이것은 클래스나 함수 :term:`데코레이터 <decorator>`\\로 작동합니다. 클래스일 때, 해당 클래스에 정의된 모든 "
"메서드에 재귀적으로 적용됩니다 (하지만 슈퍼 클래스나 서브 클래스에 정의된 메서드에는 적용되지 않습니다)."

#: ../Doc/library/typing.rst:1629
msgid "This mutates the function(s) in place."
msgstr "함수가 제자리에서(in place) 변경됩니다."

#: ../Doc/library/typing.rst:1633
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr "다른 데코레이터에 :func:`no_type_check` 효과를 주는 데코레이터."

#: ../Doc/library/typing.rst:1635
msgid ""
"This wraps the decorator with something that wraps the decorated function"
" in :func:`no_type_check`."
msgstr "이것은 데코레이트 된 함수를 :func:`no_type_check`\\로 감싸는 무언가로 데코레이터를 감쌉니다."

#: ../Doc/library/typing.rst:1640
msgid "Decorator to mark a class or function to be unavailable at runtime."
msgstr "실행 시간에 클래스나 함수를 사용할 수 없도록 표시하는 데코레이터."

#: ../Doc/library/typing.rst:1642
msgid ""
"This decorator is itself not available at runtime. It is mainly intended "
"to mark classes that are defined in type stub files if an implementation "
"returns an instance of a private class::"
msgstr ""
"이 데코레이터 자체는 실행 시간에 사용할 수 없습니다. 주로, 구현이 비공개 클래스의 인스턴스를 반환할 때, 형 스텁 파일에 정의된"
" 클래스를 표시하기 위한 용도입니다::"

#: ../Doc/library/typing.rst:1653
msgid ""
"Note that returning instances of private classes is not recommended. It "
"is usually preferable to make such classes public."
msgstr "비공개 클래스의 인스턴스를 반환하는 것은 좋지 않음에 유의하십시오. 일반적으로 그러한 클래스를 공개로 만드는 것이 바람직합니다."

#: ../Doc/library/typing.rst:1657
msgid "Introspection helpers"
msgstr "인트로스펙션 도우미"

#: ../Doc/library/typing.rst:1661
msgid ""
"Return a dictionary containing type hints for a function, method, module "
"or class object."
msgstr "함수, 메서드, 모듈 또는 클래스 객체에 대한 형 힌트가 포함된 딕셔너리를 반환합니다."

#: ../Doc/library/typing.rst:1664
msgid ""
"This is often the same as ``obj.__annotations__``. In addition, forward "
"references encoded as string literals are handled by evaluating them in "
"``globals`` and ``locals`` namespaces. If necessary, ``Optional[t]`` is "
"added for function and method annotations if a default value equal to "
"``None`` is set. For a class ``C``, return a dictionary constructed by "
"merging all the ``__annotations__`` along ``C.__mro__`` in reverse order."
msgstr ""
"이것은 종종 ``obj.__annotations__``\\와 같습니다. 또한, 문자열 리터럴로 인코딩된 전방 참조는 "
"``globals``\\와 ``locals`` 이름 공간에서 이를 평가하여 처리됩니다. 필요하면, 기본값이 ``None``\\으로 "
"설정되면 함수와 메서드 어노테이션에 ``Optional[t]``\\가 추가됩니다. 클래스 ``C``\\에 대해, "
"``C.__mro__``\\의 역순으로 모든 ``__annotations__``\\를 병합하여 만든 딕셔너리를 반환합니다."

#: ../Doc/library/typing.rst:1672
msgid ""
"The function recursively replaces all ``Annotated[T, ...]`` with ``T``, "
"unless ``include_extras`` is set to ``True`` (see :class:`Annotated` for "
"more information). For example::"
msgstr ""
"``include_extras``\\가 ``True``\\로 설정되어 있지 않은 한, 이 함수는 모든 ``Annotated[T, "
"...]``\\를 ``T``\\로 재귀적으로 치환합니다 (자세한 내용은 :class:`Annotated`\\를 참조하십시오). 예를"
" 들면::"

#: ../Doc/library/typing.rst:1685
msgid "Added ``include_extras`` parameter as part of :pep:`593`."
msgstr ":pep:`593`\\의 일부로 ``include_extras`` 매개 변수를 추가했습니다."

#: ../Doc/library/typing.rst:1691
msgid "Provide basic introspection for generic types and special typing forms."
msgstr "제네릭 형과 특수 typing 형식에 대한 기본적인 인트로스펙션을 제공합니다."

#: ../Doc/library/typing.rst:1693
msgid ""
"For a typing object of the form ``X[Y, Z, ...]`` these functions return "
"``X`` and ``(Y, Z, ...)``. If ``X`` is a generic alias for a builtin or "
":mod:`collections` class, it gets normalized to the original class. If "
"``X`` is a :class:`Union` or :class:`Literal` contained in another "
"generic type, the order of ``(Y, Z, ...)`` may be different from the "
"order of the original arguments ``[Y, Z, ...]`` due to type caching. For "
"unsupported objects return ``None`` and ``()`` correspondingly. "
"Examples::"
msgstr ""
"``X[Y, Z, ...]`` 형식의 typing 객체의 경우, 이 함수는 ``X``\\와 ``(Y, Z, ...)``\\를 "
"반환합니다. ``X``\\가 내장이나 :mod:`collections` 클래스의 제네릭 에일리어스인 경우, 원래 클래스로 "
"정규화됩니다. ``X``\\가 다른 제네릭 형에 포함된 :class:`Union`\\이나 :class:`Literal`\\이면, "
"``(Y, Z, ...)``\\의 순서는 형 캐싱으로 인해 원래 인자 ``[Y, Z, ...]``\\의 순서와 다를 수 있습니다. "
"지원되지 않는 객체의 경우 각각 ``None``\\과 ``()``\\를 반환합니다. 예::"

#: ../Doc/library/typing.rst:1712
msgid ""
"A class used for internal typing representation of string forward "
"references. For example, ``list[\"SomeClass\"]`` is implicitly "
"transformed into ``list[ForwardRef(\"SomeClass\")]``.  This class should "
"not be instantiated by a user, but may be used by introspection tools."
msgstr ""
"문자열 전방 참조의 내부 typing 표현에 사용되는 클래스. 예를 들어, ``list[\"SomeClass\"]``\\는 "
"묵시적으로 ``list[ForwardRef(\"SomeClass\")]``\\로 변환됩니다. 이 클래스는 사용자가 인스턴스 화해서는"
" 안 되지만, 인트로스펙션 도구에서 사용할 수 있습니다."

#: ../Doc/library/typing.rst:1718
msgid "Constant"
msgstr "상수"

#: ../Doc/library/typing.rst:1722
msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static "
"type checkers. It is ``False`` at runtime. Usage::"
msgstr ""
"제삼자 정적 형 검사기에 의해 ``True``\\로 설정될 것으로 가정되는 특수 상수. 실행 시간에는 ``False``\\입니다. "
"용법::"

#: ../Doc/library/typing.rst:1731
msgid ""
"The first type annotation must be enclosed in quotes, making it a "
"\"forward reference\", to hide the ``expensive_mod`` reference from the "
"interpreter runtime.  Type annotations for local variables are not "
"evaluated, so the second annotation does not need to be enclosed in "
"quotes."
msgstr ""
"첫 번째 어노테이션은 따옴표로 묶여야 합니다, \"전방 참조\"로 만들어서 인터프리터 실행 시간에 ``expensive_mod`` "
"참조를 숨깁니다. 지역 변수에 대한 형 어노테이션은 평가되지 않기 때문에, 두 번째 어노테이션을 따옴표로 묶을 필요는 없습니다."

#: ../Doc/library/typing.rst:1738
msgid ""
"If ``from __future__ import annotations`` is used in Python 3.7 or later,"
" annotations are not evaluated at function definition time. Instead, they"
" are stored as strings in ``__annotations__``, This makes it unnecessary "
"to use quotes around the annotation. (see :pep:`563`)."
msgstr ""
"파이썬 3.7 이상에서 ``from __future__ import annotations``\\이 사용되면, 함수 정의 시점에 "
"어노테이션이 평가되지 않습니다. 대신, ``__annotations__``\\에 문자열로 저장되어서, 어노테이션 주위에 따옴표를 "
"사용할 필요가 없습니다. (:pep:`563`\\을 참조하십시오)."

