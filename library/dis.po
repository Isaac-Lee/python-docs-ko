# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-08 03:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:2
msgid ":mod:`dis` --- Disassembler for Python bytecode"
msgstr ":mod:`dis` --- 파이썬 바이트 코드 역 어셈블러"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:7
msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**소스 코드:** :source:`Lib/dis.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:11
msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` "
"by disassembling it. The CPython bytecode which this module takes as an "
"input is defined in the file :file:`Include/opcode.h` and used by the "
"compiler and the interpreter."
msgstr ""
":mod:`dis` 모듈은 CPython :term:`바이트 코드 <bytecode>`\\를 역 어셈블 하여 분석을 지원합니다. 이"
" 모듈이 입력으로 취하는 CPython 바이트 코드는 파일 :file:`Include/opcode.h`\\에 정의되어 있으며 "
"컴파일러와 인터프리터에서 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:18
msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered "
"to work across Python VMs or Python releases."
msgstr ""
"바이트 코드는 CPython 인터프리터의 구현 세부 사항입니다. 파이썬 버전 간에 바이트 코드가 추가, 제거 또는 변경되지 않을 "
"것이라는 보장은 없습니다. 이 모듈을 사용하는 것이 파이썬 VM이나 파이썬 릴리스에 걸쳐 작동할 것으로 생각하지 말아야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:23
msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied "
"by instruction."
msgstr "명령어마다 2바이트를 사용합니다. 이전에는 바이트 수가 명령어에 따라 달랐습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:28
msgid "Example: Given the function :func:`myfunc`::"
msgstr "예: 주어진 함수 :func:`myfunc`\\에 대해::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:33
msgid ""
"the following command can be used to display the disassembly of "
":func:`myfunc`::"
msgstr "다음 명령을 사용하여 :func:`myfunc`\\의 역 어셈블리를 표시할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:42
msgid "(The \"2\" is a line number)."
msgstr "(\"2\"는 줄 번호입니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:45
msgid "Bytecode analysis"
msgstr "바이트 코드 분석"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:49
msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a"
" :class:`Bytecode` object that provides easy access to details of the "
"compiled code."
msgstr ""
"바이트 코드 분석 API는 컴파일된 코드의 세부 사항에 쉽게 액세스 할 수 있도록 하는 :class:`Bytecode` 객체로 "
"파이썬 코드 조각을 감쌀 수 있도록 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:56
msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous"
" generator, coroutine, method, string of source code, or a code object "
"(as returned by :func:`compile`)."
msgstr ""
"함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자열 또는 (:func:`compile`\\에서 반환된) 코드"
" 객체에 해당하는 바이트 코드를 분석합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:60
msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a "
":class:`Bytecode` instance yields the bytecode operations as "
":class:`Instruction` instances."
msgstr ""
"이것은 아래에 나열된 많은 함수, 특히 :func:`get_instructions`\\를 둘러싼 편리한 래퍼입니다, "
":class:`Bytecode` 인스턴스를 이터레이트 하면 바이트 코드 연산이 :class:`Instruction` 인스턴스로 "
"산출되기 때문입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:64
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:225
msgid ""
"If *first_line* is not ``None``, it indicates the line number that should"
" be reported for the first source line in the disassembled code.  "
"Otherwise, the source line information (if any) is taken directly from "
"the disassembled code object."
msgstr ""
"*first_line*\\이 ``None``\\이 아니면, 역 어셈블 된 코드에서 첫 번째 소스 줄에 대해 보고해야 하는 줄 번호를"
" 나타냅니다. 그렇지 않으면, 소스 줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:69
msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset "
"in the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"*current_offset*\\이 ``None``\\이 아니면, 역 어셈블 된 코드의 명령어 오프셋을 나타냅니다. 이를 설정하면,"
" :meth:`.dis`\\가 지정된 옵코드(opcode)에 대해 \"현재 명령어\" 마커를 표시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:75
msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"주어진 트레이스백에서 :class:`Bytecode` 인스턴스를 구성하고, *current_offset*\\을 예외를 일으킨 "
"명령어로 설정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:80
msgid "The compiled code object."
msgstr "컴파일된 코드 객체."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:84
msgid "The first source line of the code object (if available)"
msgstr "코드 객체의 첫 번째 소스 줄 (사용 가능하다면)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:88
msgid ""
"Return a formatted view of the bytecode operations (the same as printed "
"by :func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"바이트 코드 연산의 포맷된 보기를 반환합니다 (:func:`dis.dis`\\가 인쇄하는 것과 같지만, 여러 줄 문자열로 "
"반환됩니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:93
msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ":func:`code_info`\\처럼, 코드 객체에 대한 자세한 정보가 포함된 포맷된 여러 줄 문자열을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:96
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:130
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:176
msgid "This can now handle coroutine and asynchronous generator objects."
msgstr "이제 코루틴과 비동기 제너레이터 객체를 처리할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:99
msgid "Example::"
msgstr "예::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:112
msgid "Analysis functions"
msgstr "분석 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:114
msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if "
"only a single operation is being performed, so the intermediate analysis "
"object isn't useful:"
msgstr ""
":mod:`dis` 모듈은 또한 입력을 원하는 출력으로 직접 변환하는 다음 분석 함수를 정의합니다. 단일 작업만 수행해서, 중간 "
"분석 객체가 유용하지 않을 때 유용할 수 있습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:120
msgid ""
"Return a formatted multi-line string with detailed code object "
"information for the supplied function, generator, asynchronous generator,"
" coroutine, method, source code string or code object."
msgstr ""
"제공된 함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보가 "
"포함된 포맷된 여러 줄 문자열을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:124
msgid ""
"Note that the exact contents of code info strings are highly "
"implementation dependent and they may change arbitrarily across Python "
"VMs or Python releases."
msgstr "코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 파이썬 VM이나 파이썬 릴리스에 걸쳐 임의로 변경될 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:136
msgid ""
"Print detailed code object information for the supplied function, method,"
" source code string or code object to *file* (or ``sys.stdout`` if *file*"
" is not specified)."
msgstr ""
"제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보를 *file*\\(또는 *file*\\이 "
"지정되지 않으면 ``sys.stdout``)로 인쇄합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:140
msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"이것은 ``print(code_info(x), file=file)``\\의 편리한 축약 형으로, 인터프리터 프롬프트에서의 대화식 "
"탐색을 위한 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:145
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:170
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:189
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:213
msgid "Added *file* parameter."
msgstr "*file* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:151
msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, "
"a code object, a string of source code or a byte sequence of raw "
"bytecode. For a module, it disassembles all functions. For a class, it "
"disassembles all methods (including class and static methods). For a code"
" object or sequence of raw bytecode, it prints one line per bytecode "
"instruction. It also recursively disassembles nested code objects (the "
"code of comprehensions, generator expressions and nested functions, and "
"the code used for building nested classes). Strings are first compiled to"
" code objects with the :func:`compile` built-in function before being "
"disassembled.  If no object is provided, this function disassembles the "
"last traceback."
msgstr ""
"*x* 객체를 역 어셈블 합니다. *x*\\는 모듈, 클래스, 메서드, 함수, 제너레이터, 비동기 제너레이터, 코루틴, 코드 객체,"
" 소스 코드 문자열 또는 원시 바이트 코드의 바이트 시퀀스를 나타낼 수 있습니다. 모듈의 경우, 모든 함수를 역 어셈블 합니다. "
"클래스의 경우, 모든 메서드(클래스와 정적 메서드를 포함합니다)를 역 어셈블 합니다. 코드 객체나 원시 바이트 코드 시퀀스의 경우,"
" 바이트 코드 명령어 당 한 줄을 인쇄합니다. 또한 중첩 코드 객체(컴프리헨션, 제너레이터 표현식 및 중첩 함수의 코드와 중첩 "
"클래스를 만드는 데 사용된 코드)를 재귀적으로 역 어셈블 합니다. 문자열은 역 어셈블 되기 전에 먼저 :func:`compile` "
"내장 함수를 사용하여 코드 객체로 컴파일됩니다. 객체가 제공되지 않으면, 이 함수는 마지막 트레이스백을 역 어셈블 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:164
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:186
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:210
msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr "역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면 ``sys.stdout``\\에 텍스트로 기록됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:167
msgid ""
"The maximal depth of recursion is limited by *depth* unless it is "
"``None``. ``depth=0`` means no recursion."
msgstr ""
"재귀의 최대 깊이는 ``None``\\이 아닌 한 *depth*\\에 의해 제한됩니다. ``depth=0``\\은 재귀가 없음을 "
"의미합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:173
msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "재귀 역 어셈블을 구현하고 *depth* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:182
msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr "트레이스백의 최상단 함수를 역 어셈블 합니다. 전달되지 않으면 마지막 트레이스백을 사용합니다. 예외를 일으키는 명령어가 표시됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:196
msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was"
" provided.  The output is divided in the following columns:"
msgstr "코드 객체를 역 어셈블 하고, *lasti*\\가 제공되면 마지막 명령어를 표시합니다. 출력은 다음 열로 나뉩니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:199
msgid "the line number, for the first instruction of each line"
msgstr "줄 번호, 각 줄의 첫 번째 명령어에 표시됩니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:200
msgid "the current instruction, indicated as ``-->``,"
msgstr "현재 명령어, ``-->``\\로 표시됩니다,"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:201
msgid "a labelled instruction, indicated with ``>>``,"
msgstr "레이블이 있는 명령어, ``>>``\\로 표시됩니다,"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:202
msgid "the address of the instruction,"
msgstr "명령어의 주소,"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:203
msgid "the operation code name,"
msgstr "연산 코드 이름,"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:204
msgid "operation parameters, and"
msgstr "연산 매개 변수, 그리고"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:205
msgid "interpretation of the parameters in parentheses."
msgstr "괄호 안에 있는 매개 변수의 해석."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:207
msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr "매개 변수 해석은 지역과 전역 변수 이름, 상숫값, 분기 대상 및 비교 연산자를 인식합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:219
msgid ""
"Return an iterator over the instructions in the supplied function, "
"method, source code string or code object."
msgstr "제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체의 명령어들에 대한 이터레이터를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:222
msgid ""
"The iterator generates a series of :class:`Instruction` named tuples "
"giving the details of each operation in the supplied code."
msgstr ""
"이터레이터는 제공된 코드의 각 연산에 대한 세부 정보를 제공하는 :class:`Instruction` 네임드 튜플의 연속을 "
"생성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:235
msgid ""
"This generator function uses the ``co_firstlineno`` and ``co_lnotab`` "
"attributes of the code object *code* to find the offsets which are starts"
" of lines in the source code.  They are generated as ``(offset, lineno)``"
" pairs. See :source:`Objects/lnotab_notes.txt` for the ``co_lnotab`` "
"format and how to decode it."
msgstr ""
"이 제너레이터 함수는 코드 객체 *code*\\의 ``co_firstlineno``\\와 ``co_lnotab`` 어트리뷰트를 "
"사용하여 소스 코드에서 줄의 시작을 가리키는 오프셋을 찾습니다. ``(offset, lineno)`` 쌍으로 생성됩니다. "
"``co_lnotab`` 형식과 디코딩 방법은 :source:`Objects/lnotab_notes.txt`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:241
msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr "줄 번호가 줄어들 수 있습니다. 전에는, 언제나 증가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:247
msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are "
"jump targets, and return a list of these offsets."
msgstr "원시 컴파일된 바이트 코드 문자열 *code*\\에서 점프 대상인 모든 오프셋을 감지하고, 이러한 오프셋의 리스트를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:253
msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "인자 *oparg*\\를 갖는 *opcode*\\의 스택 효과를 계산합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:255
msgid ""
"If the code has a jump target and *jump* is ``True``, "
":func:`~stack_effect` will return the stack effect of jumping.  If *jump*"
" is ``False``, it will return the stack effect of not jumping. And if "
"*jump* is ``None`` (default), it will return the maximal stack effect of "
"both cases."
msgstr ""
"코드에 점프 대상이 있고 *jump*\\가 ``True``\\이면, :func:`~stack_effect`\\는 점프의 스택 효과를"
" 반환합니다. *jump*\\가 ``False``\\이면, 점프하지 않는 스택 효과를 반환합니다. *jump*\\가 "
"``None``\\(기본값)이면, 두 경우의 최대 스택 효과를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:262
msgid "Added *jump* parameter."
msgstr "*jump* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:269
msgid "Python Bytecode Instructions"
msgstr "파이썬 바이트 코드 명령어"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:271
msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide"
" details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
":func:`get_instructions` 함수와 :class:`Bytecode` 클래스는 바이트 코드 명령어의 세부 사항을 "
":class:`Instruction` 인스턴스로 제공합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:276
msgid "Details for a bytecode operation"
msgstr "바이트 코드 연산에 대한 세부 사항"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:280
msgid ""
"numeric code for operation, corresponding to the opcode values listed "
"below and the bytecode values in the :ref:`opcode_collections`."
msgstr "연산의 숫자 코드, 아래 나열된 옵코드 값과 :ref:`opcode_collections`\\에 있는 바이트 코드 값에 해당합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:286
msgid "human readable name for operation"
msgstr "연산의 사람이 읽을 수 있는 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:291
msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr "연산에 대한 숫자 인자 (있다면), 그렇지 않으면 ``None``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:296
msgid "resolved arg value (if known), otherwise same as arg"
msgstr "해석된(resolved) arg 값 (알고 있다면), 그렇지 않으면 arg와 같습니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:301
msgid "human readable description of operation argument"
msgstr "연산 인자에 대한 사람이 읽을 수 있는 설명"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:306
msgid "start index of operation within bytecode sequence"
msgstr "바이트 코드 시퀀스 내에서 연산의 시작 인덱스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:311
msgid "line started by this opcode (if any), otherwise ``None``"
msgstr "이 옵코드에 의해 시작된 줄 (있다면), 그렇지 않으면 ``None``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:316
msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "다른 코드가 여기로 점프하면 ``True``, 그렇지 않으면 ``False``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:321
msgid ""
"The Python compiler currently generates the following bytecode "
"instructions."
msgstr "파이썬 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:324
msgid "**General instructions**"
msgstr "**일반 명령어**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:328
msgid "Do nothing code.  Used as a placeholder by the bytecode optimizer."
msgstr "아무것도 하지 않는 코드. 바이트 코드 최적화기에서 자리 표시자로 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:333
msgid "Removes the top-of-stack (TOS) item."
msgstr "스택 최상단 (TOS) 항목을 제거합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:338
msgid "Swaps the two top-most stack items."
msgstr "두 개의 최상위 스택 항목을 자리바꿈합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:343
msgid ""
"Lifts second and third stack item one position up, moves top down to "
"position three."
msgstr "두 번째와 세 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 세 번째 자리로 내립니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:349
msgid ""
"Lifts second, third and forth stack items one position up, moves top down"
" to position four."
msgstr "두 번째, 세 번째 및 네 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 네 번째 자리로 내립니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:357
msgid "Duplicates the reference on top of the stack."
msgstr "스택 최상단의 참조를 복제합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:364
msgid ""
"Duplicates the two references on top of the stack, leaving them in the "
"same order."
msgstr "같은 순서를 유지하면서, 스택 최상단의 두 참조를 복제합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:370
msgid "**Unary operations**"
msgstr "**단항 연산**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:372
msgid ""
"Unary operations take the top of the stack, apply the operation, and push"
" the result back on the stack."
msgstr "단항 연산은 스택의 최상단을 취하고, 연산을 적용한 다음, 결과를 스택에 다시 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:377
msgid "Implements ``TOS = +TOS``."
msgstr "``TOS = +TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:382
msgid "Implements ``TOS = -TOS``."
msgstr "``TOS = -TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:387
msgid "Implements ``TOS = not TOS``."
msgstr "``TOS = not TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:392
msgid "Implements ``TOS = ~TOS``."
msgstr "``TOS = ~TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:397
msgid "Implements ``TOS = iter(TOS)``."
msgstr "``TOS = iter(TOS)``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:402
msgid ""
"If ``TOS`` is a :term:`generator iterator` or :term:`coroutine` object it"
" is left as is.  Otherwise, implements ``TOS = iter(TOS)``."
msgstr ""
"``TOS``\\가 :term:`제너레이터 이터레이터 <generator iterator>`\\나 :term:`코루틴 "
"<coroutine>` 객체이면 그대로 둡니다. 그렇지 않으면, ``TOS = iter(TOS)``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:408
msgid "**Binary operations**"
msgstr "**이항 연산**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:410
msgid ""
"Binary operations remove the top of the stack (TOS) and the second top-"
"most stack item (TOS1) from the stack.  They perform the operation, and "
"put the result back on the stack."
msgstr ""
"이항 연산은 스택에서 스택 최상단(TOS)과 두 번째 최상단 스택 항목(TOS1)을 제거합니다. 연산을 수행하고, 결과를 다시 "
"스택에 넣습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:416
msgid "Implements ``TOS = TOS1 ** TOS``."
msgstr "``TOS = TOS1 ** TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:421
msgid "Implements ``TOS = TOS1 * TOS``."
msgstr "``TOS = TOS1 * TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:426
msgid "Implements ``TOS = TOS1 @ TOS``."
msgstr "``TOS = TOS1 @ TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:433
msgid "Implements ``TOS = TOS1 // TOS``."
msgstr "``TOS = TOS1 // TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:438
msgid "Implements ``TOS = TOS1 / TOS``."
msgstr "``TOS = TOS1 / TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:443
msgid "Implements ``TOS = TOS1 % TOS``."
msgstr "``TOS = TOS1 % TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:448
msgid "Implements ``TOS = TOS1 + TOS``."
msgstr "``TOS = TOS1 + TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:453
msgid "Implements ``TOS = TOS1 - TOS``."
msgstr "``TOS = TOS1 - TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:458
msgid "Implements ``TOS = TOS1[TOS]``."
msgstr "``TOS = TOS1[TOS]``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:463
msgid "Implements ``TOS = TOS1 << TOS``."
msgstr "``TOS = TOS1 << TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:468
msgid "Implements ``TOS = TOS1 >> TOS``."
msgstr "``TOS = TOS1 >> TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:473
msgid "Implements ``TOS = TOS1 & TOS``."
msgstr "``TOS = TOS1 & TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:478
msgid "Implements ``TOS = TOS1 ^ TOS``."
msgstr "``TOS = TOS1 ^ TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:483
msgid "Implements ``TOS = TOS1 | TOS``."
msgstr "``TOS = TOS1 | TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:486
msgid "**In-place operations**"
msgstr "**제자리 연산**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:488
msgid ""
"In-place operations are like binary operations, in that they remove TOS "
"and TOS1, and push the result back on the stack, but the operation is "
"done in-place when TOS1 supports it, and the resulting TOS may be (but "
"does not have to be) the original TOS1."
msgstr ""
"제자리(in-place) 연산은 TOS와 TOS1을 제거하고, 스택에 결과를 다시 푸시한다는 점에서 이항 연산과 같습니다. 그러나 "
"TOS1이 이를 지원하면 연산이 제자리에서 수행되며, 결과 TOS는 원래 TOS1일 수 있습니다 (하지만 꼭 그럴 필요는 "
"없습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:495
msgid "Implements in-place ``TOS = TOS1 ** TOS``."
msgstr "제자리 ``TOS = TOS1 ** TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:500
msgid "Implements in-place ``TOS = TOS1 * TOS``."
msgstr "제자리 ``TOS = TOS1 * TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:505
msgid "Implements in-place ``TOS = TOS1 @ TOS``."
msgstr "제자리 ``TOS = TOS1 @ TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:512
msgid "Implements in-place ``TOS = TOS1 // TOS``."
msgstr "제자리 ``TOS = TOS1 // TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:517
msgid "Implements in-place ``TOS = TOS1 / TOS``."
msgstr "제자리 ``TOS = TOS1 / TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:522
msgid "Implements in-place ``TOS = TOS1 % TOS``."
msgstr "제자리 ``TOS = TOS1 % TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:527
msgid "Implements in-place ``TOS = TOS1 + TOS``."
msgstr "제자리 ``TOS = TOS1 + TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:532
msgid "Implements in-place ``TOS = TOS1 - TOS``."
msgstr "제자리 ``TOS = TOS1 - TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:537
msgid "Implements in-place ``TOS = TOS1 << TOS``."
msgstr "제자리 ``TOS = TOS1 << TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:542
msgid "Implements in-place ``TOS = TOS1 >> TOS``."
msgstr "제자리 ``TOS = TOS1 >> TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:547
msgid "Implements in-place ``TOS = TOS1 & TOS``."
msgstr "제자리 ``TOS = TOS1 & TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:552
msgid "Implements in-place ``TOS = TOS1 ^ TOS``."
msgstr "제자리 ``TOS = TOS1 ^ TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:557
msgid "Implements in-place ``TOS = TOS1 | TOS``."
msgstr "제자리 ``TOS = TOS1 | TOS``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:562
msgid "Implements ``TOS1[TOS] = TOS2``."
msgstr "``TOS1[TOS] = TOS2``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:567
msgid "Implements ``del TOS1[TOS]``."
msgstr "``del TOS1[TOS]``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:570
msgid "**Coroutine opcodes**"
msgstr "**코루틴 옵코드**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:574
msgid ""
"Implements ``TOS = get_awaitable(TOS)``, where ``get_awaitable(o)`` "
"returns ``o`` if ``o`` is a coroutine object or a generator object with "
"the CO_ITERABLE_COROUTINE flag, or resolves ``o.__await__``."
msgstr ""
"``TOS = get_awaitable(TOS)``\\를 구현합니다. 여기서 ``o``\\가 코루틴 객체나 "
"CO_ITERABLE_COROUTINE 플래그를 가진 제너레이터 객체이면 ``get_awaitable(o)``\\는 ``o``\\를"
" 반환합니다, 또는 ``o.__await__``\\를 해석(resolve)합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:584
msgid "Implements ``TOS = TOS.__aiter__()``."
msgstr "``TOS = TOS.__aiter__()``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:587
msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "``__aiter__``\\로부터 어웨이터블 객체를 반환하는 것은 더는 지원되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:594
msgid ""
"Implements ``PUSH(get_awaitable(TOS.__anext__()))``.  See "
"``GET_AWAITABLE`` for details about ``get_awaitable``"
msgstr ""
"``PUSH(get_awaitable(TOS.__anext__()))``\\를 구현합니다. ``get_awaitable``\\에 "
"대한 자세한 내용은 ``GET_AWAITABLE``\\을 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:602
msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised "
"when awaiting a next item.  If TOS is :exc:`StopAsyncIteration` pop 7 "
"values from the stack and restore the exception state using the second "
"three of them.  Otherwise re-raise the exception using the three values "
"from the stack.  An exception handler block is removed from the block "
"stack."
msgstr ""
":keyword:`async for` 루프를 종료합니다. 다음 항목을 어웨이트 할 때 발생하는 예외를 처리합니다. TOS가 "
":exc:`StopAsyncIteration` 이면 스택에서 7개의 값을 팝하고 두 번째 세 개를 사용하여 예외 상태를 복원합니다."
" 그렇지 않으면 스택에서 세 값을 사용하여 예외를 다시 발생시킵니다. 예외 처리기 블록이 블록 스택에서 제거됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:613
msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from the object on top of the "
"stack.  Pushes ``__aexit__`` and result of ``__aenter__()`` to the stack."
msgstr ""
"스택 최상단의 객체에서 ``__aenter__``\\와 ``__aexit__``\\를 해석(resolve)합니다. "
"``__aexit__``\\와 ``__aenter__()``\\의 결과를 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:621
msgid "Creates a new frame object."
msgstr "새 프레임 객체를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:627
msgid "**Miscellaneous opcodes**"
msgstr "**기타 옵코드**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:631
msgid ""
"Implements the expression statement for the interactive mode.  TOS is "
"removed from the stack and printed.  In non-interactive mode, an "
"expression statement is terminated with :opcode:`POP_TOP`."
msgstr ""
"대화식 모드를 위한 표현식 문을 구현합니다. 스택에서 TOS가 제거되고 인쇄됩니다. 비 대화식 모드에서, 표현식 문은 "
":opcode:`POP_TOP`\\으로 종료됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:638
msgid "Calls ``set.add(TOS1[-i], TOS)``.  Used to implement set comprehensions."
msgstr "``set.add(TOS1[-i], TOS)``\\를 호출합니다. 집합 컴프리헨션을 구현하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:643
msgid ""
"Calls ``list.append(TOS1[-i], TOS)``.  Used to implement list "
"comprehensions."
msgstr "``list.append(TOS1[-i], TOS)``\\를 호출합니다. 리스트 컴프리헨션을 구현하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:648
msgid ""
"Calls ``dict.__setitem__(TOS1[-i], TOS1, TOS)``.  Used to implement dict "
"comprehensions."
msgstr ""
"``dict.__setitem__(TOS1[-i], TOS1, TOS)``\\를 호출합니다. 딕셔너리 컴프리헨션을 구현하는 데 "
"사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:652
msgid "Map value is TOS and map key is TOS1. Before, those were reversed."
msgstr "맵 값은 TOS이고 맵 키는 TOS1입니다. 전에는, 이것들이 반대였습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:655
msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and "
":opcode:`MAP_ADD` instructions, while the added value or key/value pair "
"is popped off, the container object remains on the stack so that it is "
"available for further iterations of the loop."
msgstr ""
"모든 :opcode:`SET_ADD`, :opcode:`LIST_APPEND` 및 :opcode:`MAP_ADD` 명령어에 대해, "
"추가된 값이나 키/값 쌍이 팝 되지만, 컨테이너 객체는 스택에 남아 있어서 루프의 추가 이터레이션에 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:663
msgid "Returns with TOS to the caller of the function."
msgstr "TOS를 함수 호출자에게 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:668
msgid "Pops TOS and yields it from a :term:`generator`."
msgstr "TOS를 팝하고 :term:`제너레이터 <generator>`\\에서 그것을 산출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:673
msgid "Pops TOS and delegates to it as a subiterator from a :term:`generator`."
msgstr "TOS를 팝하고 :term:`제너레이터 <generator>`\\에서 서브 이터레이터로 그것에 위임합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:680
msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it "
"is set up to an empty ``dict``. This opcode is only emitted if a class or"
" module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"``locals()``\\에 ``__annotations__``\\가 정의되어 있는지 확인합니다, 그렇지 않으면 비어있는 "
"``dict``\\로 설정됩니다. 이 옵코드는 클래스나 모듈 본문에 :term:`변수 어노테이션 <variable "
"annotation>`\\이 정적으로 포함될 때만 생성됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:690
msgid ""
"Loads all symbols not starting with ``'_'`` directly from the module TOS "
"to the local namespace. The module is popped after loading all names. "
"This opcode implements ``from module import *``."
msgstr ""
"``'_'``\\로 시작하지 않는 모든 심볼을 모듈 TOS에서 지역 이름 공간으로 직접 로드합니다. 모든 이름을 로드한 후 모듈이 "
"팝 됩니다. 이 옵코드는 ``from module import *``\\를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:697
msgid ""
"Removes one block from the block stack.  Per frame, there is a stack of "
"blocks, denoting :keyword:`try` statements, and such."
msgstr ""
"블록 스택에서 하나의 블록을 제거합니다. 프레임마다, 블록 스택이 있습니다, :keyword:`try` 문을 나타내는 것과 같은 "
"것들입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:703
msgid ""
"Removes one block from the block stack. The popped block must be an "
"exception handler block, as implicitly created when entering an except "
"handler.  In addition to popping extraneous values from the frame stack, "
"the last three popped values are used to restore the exception state."
msgstr ""
"블록 스택에서 하나의 블록을 제거합니다. 팝 된 블록은 예외 처리기에 진입할 때 묵시적으로 만들어진 예외 처리기 블록이어야 합니다."
" 프레임 스택에서 추가적인 값들을 팝 하는 것에 더해, 마지막 3개의 팝 된 값이 예외 상태를 복원하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:711
#, fuzzy
msgid "Re-raises the exception currently on top of the stack."
msgstr "스택 최상단의 참조를 복제합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:718
msgid ""
"Calls the function in position 7 on the stack with the top three items on"
" the stack as arguments. Used to implement the call "
"``context_manager.__exit__(*exc_info())`` when an exception has occurred "
"in a :keyword:`with` statement."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:728
msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the "
":keyword:`assert` statement."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:736
msgid ""
"Pushes :func:`builtins.__build_class__` onto the stack.  It is later "
"called by :opcode:`CALL_FUNCTION` to construct a class."
msgstr ""
":func:`builtins.__build_class__`\\를 스택으로 푸시합니다. 나중에 클래스를 생성하기 위해 "
":opcode:`CALL_FUNCTION`\\에 의해 호출됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:742
msgid ""
"This opcode performs several operations before a with block starts.  "
"First, it loads :meth:`~object.__exit__` from the context manager and "
"pushes it onto the stack for later use by :opcode:`WITH_CLEANUP_START`.  "
"Then, :meth:`~object.__enter__` is called, and a finally block pointing "
"to *delta* is pushed.  Finally, the result of calling the ``__enter__()``"
" method is pushed onto the stack.  The next opcode will either ignore it "
"(:opcode:`POP_TOP`), or store it in (a) variable(s) "
"(:opcode:`STORE_FAST`, :opcode:`STORE_NAME`, or "
":opcode:`UNPACK_SEQUENCE`)."
msgstr ""
"이 옵코드는 with 블록이 시작되기 전에 여러 연산을 수행합니다. 먼저 컨텍스트 관리자에서 "
":meth:`~object.__exit__`\\를 로드하고 나중에 :opcode:`WITH_CLEANUP_START`\\에서 사용할"
" 수 있도록 스택으로 푸시합니다. 그런 다음, :meth:`~object.__enter__`\\가 호출되고, *delta*\\를 "
"가리키는 finally 블록이 푸시 됩니다. 마지막으로, ``__enter__()`` 메서드 호출 결과가 스택으로 푸시 됩니다. "
"다음 옵코드는 이를 무시하거나 (:opcode:`POP_TOP`), 변수에 저장합니다 (:opcode:`STORE_FAST`, "
":opcode:`STORE_NAME` 또는 :opcode:`UNPACK_SEQUENCE`)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:754
msgid "All of the following opcodes use their arguments."
msgstr "다음 옵코드는 모두 인자를 사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:758
msgid ""
"Implements ``name = TOS``. *namei* is the index of *name* in the "
"attribute :attr:`co_names` of the code object. The compiler tries to use "
":opcode:`STORE_FAST` or :opcode:`STORE_GLOBAL` if possible."
msgstr ""
"``name = TOS``\\를 구현합니다. *namei*\\는 코드 객체의 :attr:`co_names` 어트리뷰트에서 "
"*name*\\의 인덱스입니다. 컴파일러는 가능하면 :opcode:`STORE_FAST`\\나 "
":opcode:`STORE_GLOBAL`\\을 사용하려고 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:765
msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`co_names`"
" attribute of the code object."
msgstr ""
"``del name``\\을 구현합니다. 여기서 *namei*\\는 코드 객체의 :attr:`co_names` 어트리뷰트에서의 "
"인덱스입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:771
msgid ""
"Unpacks TOS into *count* individual values, which are put onto the stack "
"right-to-left."
msgstr "TOS를 *count* 개 개별 값으로 언팩합니다. 이 값들은 오른쪽에서 왼쪽으로 스택에 넣습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:777
msgid ""
"Implements assignment with a starred target: Unpacks an iterable in TOS "
"into individual values, where the total number of values can be smaller "
"than the number of items in the iterable: one of the new values will be a"
" list of all leftover items."
msgstr ""
"스타드 타깃(starred target)으로의 대입을 구현합니다: TOS의 이터러블을 개별 값으로 언팩합니다. 여기서 값의 총수는 "
"이터러블의 항목 수보다 적을 수 있습니다: 새 값 중 하나는 남은 모든 항목의 리스트입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:782
msgid ""
"The low byte of *counts* is the number of values before the list value, "
"the high byte of *counts* the number of values after it.  The resulting "
"values are put onto the stack right-to-left."
msgstr ""
"*counts*\\의 하위 바이트는 리스트값 이전의 값의 개수이고, *counts*\\의 상위 바이트는 그 이후의 값의 개수입니다."
" 결괏값들은 오른쪽에서 왼쪽으로 스택에 넣습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:789
msgid ""
"Implements ``TOS.name = TOS1``, where *namei* is the index of name in "
":attr:`co_names`."
msgstr ""
"``TOS.name = TOS1``\\을 구현합니다. 여기서 *namei*\\는 :attr:`co_names`\\에서 name의 "
"인덱스입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:795
msgid "Implements ``del TOS.name``, using *namei* as index into :attr:`co_names`."
msgstr "*namei*\\를 :attr:`co_names`\\에서의 인덱스로 사용하여, ``del TOS.name``\\을 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:800
msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ":opcode:`STORE_NAME`\\처럼 작동하지만, 이름을 전역으로 저장합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:805
msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr ":opcode:`DELETE_NAME`\\처럼 작동하지만, 전역 이름을 삭제합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:810
msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "``co_consts[consti]``\\를 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:815
msgid "Pushes the value associated with ``co_names[namei]`` onto the stack."
msgstr "``co_names[namei]``\\와 연관된 값을 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:820
msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack."
msgstr "스택에서 *count* 개의 항목을 소비하는 튜플을 만들고, 결과 튜플을 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:826
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr ":opcode:`BUILD_TUPLE`\\처럼 작동하지만, 리스트를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:831
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr ":opcode:`BUILD_TUPLE`\\처럼 작동하지만, 집합을 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:836
msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items "
"so that the dictionary holds *count* entries: ``{..., TOS3: TOS2, TOS1: "
"TOS}``."
msgstr ""
"새 딕셔너리 객체를 스택으로 푸시합니다. 딕셔너리가 *count* 항목을 갖도록 ``2 * count`` 항목을 팝 합니다: "
"``{..., TOS3: TOS2, TOS1: TOS}``."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:840
msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr "딕셔너리는 *count* 항목을 갖도록 미리 크기가 조정된 빈 딕셔너리를 만드는 대신 스택 항목에서 만들어집니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:847
msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops "
"the top element on the stack which contains a tuple of keys, then "
"starting from ``TOS1``, pops *count* values to form values in the built "
"dictionary."
msgstr ""
"상수 키에 특화된 :opcode:`BUILD_MAP` 버전. 키의 튜플이 포함된 스택의 맨 위 요소를 팝 한 다음, "
"``TOS1``\\에서 시작하여, *count* 개의 값을 팝 하여 만들어지는 딕셔너리의 값을 형성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:856
msgid ""
"Concatenates *count* strings from the stack and pushes the resulting "
"string onto the stack."
msgstr "스택에서 *count* 문자열을 이어붙이고 결과 문자열을 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:864
msgid "Pops a list from the stack and pushes a tuple containing the same values."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:871
#, fuzzy
msgid "Calls ``list.extend(TOS1[-i], TOS)``.  Used to build lists."
msgstr "``list.append(TOS1[-i], TOS)``\\를 호출합니다. 리스트 컴프리헨션을 구현하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:878
#, fuzzy
msgid "Calls ``set.update(TOS1[-i], TOS)``.  Used to build sets."
msgstr "``set.add(TOS1[-i], TOS)``\\를 호출합니다. 집합 컴프리헨션을 구현하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:885
msgid "Calls ``dict.update(TOS1[-i], TOS)``.  Used to build dicts."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:892
msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:899
msgid "Replaces TOS with ``getattr(TOS, co_names[namei])``."
msgstr "TOS를 ``getattr(TOS, co_names[namei])``\\로 바꿉니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:904
msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname]``."
msgstr "불리언 연산을 수행합니다. 연산 이름은 ``cmp_op[opname]``\\에서 찾을 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:910
msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:917
msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:924
msgid ""
"Imports the module ``co_names[namei]``.  TOS and TOS1 are popped and "
"provide the *fromlist* and *level* arguments of :func:`__import__`.  The "
"module object is pushed onto the stack.  The current namespace is not "
"affected: for a proper import statement, a subsequent "
":opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""
"모듈 ``co_names[namei]``\\를 임포트 합니다. TOS와 TOS1이 팝 되고 :func:`__import__`\\의 "
"*fromlist*\\와 *level* 인자를 제공합니다. 모듈 객체가 스택으로 푸시 됩니다. 현재 이름 공간은 영향을 받지 "
"않습니다: 올바른 import 문을 위해, 후속 :opcode:`STORE_FAST` 명령어가 이름 공간을 수정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:933
msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in TOS. The"
" resulting object is pushed onto the stack, to be subsequently stored by "
"a :opcode:`STORE_FAST` instruction."
msgstr ""
"TOS에서 발견된 모듈에서 어트리뷰트 ``co_names[namei]``\\를 로드합니다. 결과 객체는 스택에 푸시 되어, 뒤따르는"
" :opcode:`STORE_FAST` 명령어로 저장됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:940
msgid "Increments bytecode counter by *delta*."
msgstr "바이트 코드 카운터를 *delta*\\만큼 증가시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:945
msgid "If TOS is true, sets the bytecode counter to *target*.  TOS is popped."
msgstr "TOS가 참이면, 바이트 코드 카운터를 *target*\\으로 설정합니다. TOS가 팝 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:952
msgid "If TOS is false, sets the bytecode counter to *target*.  TOS is popped."
msgstr "TOS가 거짓이면, 바이트 코드 카운터를 *target*\\으로 설정합니다. TOS가 팝 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:958
msgid ""
"Tests whether the second value on the stack is an exception matching TOS,"
" and jumps if it is not. Pops two values from the stack."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:966
msgid ""
"If TOS is true, sets the bytecode counter to *target* and leaves TOS on "
"the stack.  Otherwise (TOS is false), TOS is popped."
msgstr ""
"TOS가 참이면, 바이트 코드 카운터를 *target*\\으로 설정하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS가 "
"거짓이면), TOS가 팝 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:974
msgid ""
"If TOS is false, sets the bytecode counter to *target* and leaves TOS on "
"the stack.  Otherwise (TOS is true), TOS is popped."
msgstr ""
"TOS가 거짓이면, 바이트 코드 카운터를 *target*\\으로 설정하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS가 "
"참이면), TOS가 팝 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:982
msgid "Set bytecode counter to *target*."
msgstr "바이트 코드 카운터를 *target*\\으로 설정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:987
#, fuzzy
msgid ""
"TOS is an :term:`iterator`.  Call its :meth:`~iterator.__next__` method."
"  If this yields a new value, push it on the stack (leaving the iterator "
"below it).  If the iterator indicates it is exhausted, TOS is popped, and"
" the byte code counter is incremented by *delta*."
msgstr ""
"TOS는 :term:`이터레이터 <iterator>`\\입니다. 그것의 :meth:`~iterator.__next__` 메서드를 "
"호출합니다. 이것이 새로운 값을 산출하면, 스택에 푸시합니다 (그 밑에 이터레이터를 남겨둡니다). 이터레이터가 소진되었음을 표시하면"
" TOS가 팝 되고, 바이트 코드 카운터가 *delta*\\만큼 증가합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:995
msgid "Loads the global named ``co_names[namei]`` onto the stack."
msgstr "``co_names[namei]``\\라는 이름의 전역을 스택에 로드합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1000
msgid ""
"Pushes a try block from a try-finally or try-except clause onto the block"
" stack.  *delta* points to the finally block or the first except block."
msgstr ""
"try-finally나 try-except 절의 try 블록을 블록 스택으로 푸시합니다. *delta*\\는 finally 블록이나"
" 첫 번째 except 블록을 가리킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1006
msgid "Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr "지역 ``co_varnames[var_num]``\\에 대한 참조를 스택으로 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1011
msgid "Stores TOS into the local ``co_varnames[var_num]``."
msgstr "TOS를 지역 ``co_varnames[var_num]``\\에 저장합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1016
msgid "Deletes local ``co_varnames[var_num]``."
msgstr "지역 ``co_varnames[var_num]``\\을 삭제합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1021
msgid ""
"Pushes a reference to the cell contained in slot *i* of the cell and free"
" variable storage.  The name of the variable is ``co_cellvars[i]`` if *i*"
" is less than the length of *co_cellvars*.  Otherwise it is "
"``co_freevars[i - len(co_cellvars)]``."
msgstr ""
"셀과 자유 변수 스토리지의 슬롯 *i*\\에 포함된 셀에 대한 참조를 푸시합니다. *i*\\가 *co_cellvars*\\의 "
"길이보다 작으면 변수 이름은 ``co_cellvars[i]``\\입니다. 그렇지 않으면 ``co_freevars[i - "
"len(co_cellvars)]``\\입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1029
msgid ""
"Loads the cell contained in slot *i* of the cell and free variable "
"storage. Pushes a reference to the object the cell contains on the stack."
msgstr "셀과 자유 변수 스토리지의 슬롯 *i*\\에 포함된 셀을 로드합니다. 스택에 포함된 셀 객체에 대한 참조를 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1035
msgid ""
"Much like :opcode:`LOAD_DEREF` but first checks the locals dictionary "
"before consulting the cell.  This is used for loading free variables in "
"class bodies."
msgstr ""
":opcode:`LOAD_DEREF`\\와 비슷하지만, 셀을 참조하기 전에 먼저 지역 딕셔너리를 확인합니다. 이것은 클래스 본문에서"
" 자유 변수를 로드하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1044
msgid ""
"Stores TOS into the cell contained in slot *i* of the cell and free "
"variable storage."
msgstr "TOS를 셀과 자유 변수 스토리지의 슬롯 *i*\\에 포함된 셀에 저장합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1050
msgid ""
"Empties the cell contained in slot *i* of the cell and free variable "
"storage. Used by the :keyword:`del` statement."
msgstr "셀과 자유 변수 스토리지의 슬롯 *i*\\에 포함된 셀을 비웁니다. :keyword:`del` 문에서 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1058
msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr "*argc*\\의 값에 따라, ``raise`` 문의 3가지 형식 중 하나를 사용하여 예외를 발생시킵니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1061
msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (이전 예외를 다시 발생시킵니다)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1062
msgid "1: ``raise TOS`` (raise exception instance or type at ``TOS``)"
msgstr "1: ``raise TOS`` (``TOS``\\에 있는 예외 인스턴스나 형을 발생시킵니다)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1063
msgid ""
"2: ``raise TOS1 from TOS`` (raise exception instance or type at ``TOS1`` "
"with ``__cause__`` set to ``TOS``)"
msgstr ""
"2: ``raise TOS1 from TOS`` (``__cause__``\\가 ``TOS``\\로 설정된 ``TOS1``\\에 "
"있는 예외 인스턴스나 형을 발생시킵니다)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1069
msgid ""
"Calls a callable object with positional arguments. *argc* indicates the "
"number of positional arguments. The top of the stack contains positional "
"arguments, with the right-most argument on top.  Below the arguments is a"
" callable object to call. ``CALL_FUNCTION`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"위치 인자를 사용하여 콜러블 객체를 호출합니다. *argc*\\는 위치 인자의 수를 나타냅니다. 스택의 맨 위에는 위치 인자가 "
"포함되는데, 가장 오른쪽 인자가 맨 위에 있습니다. 인자 아래에는 호출할 콜러블 객체가 있습니다. "
"``CALL_FUNCTION``\\은 모든 인자와 콜러블 객체를 스택에서 팝하고, 해당 인자로 콜러블 객체를 호출한 다음 콜러블 "
"객체가 반환한 반환 값을 푸시 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1077
msgid "This opcode is used only for calls with positional arguments."
msgstr "이 옵코드는 위치 인자가 있는 호출에만 사용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1083
#, fuzzy
msgid ""
"Calls a callable object with positional (if any) and keyword arguments. "
"*argc* indicates the total number of positional and keyword arguments. "
"The top element on the stack contains a tuple with the names of the "
"keyword arguments, which must be strings. Below that are the values for "
"the keyword arguments, in the order corresponding to the tuple. Below "
"that are positional arguments, with the right-most parameter on top.  "
"Below the arguments is a callable object to call. ``CALL_FUNCTION_KW`` "
"pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value "
"returned by the callable object."
msgstr ""
"위치(있다면)와 키워드 인자를 사용하여 콜러블 객체를 호출합니다. *argc*\\는 위치와 키워드 인자의 총수를 나타냅니다. 스택의"
" 최상위 요소에는 키워드 인자 이름의 튜플이 포함되어 있습니다. 그 아래에는 튜플에 해당하는 순서로 키워드 인자가 옵니다. 그 "
"아래는 위치 인자인데, 가장 오른쪽 매개 변수가 맨 위에 옵니다. 인자 아래에는 호출할 콜러블 객체가 있습니다. "
"``CALL_FUNCTION_KW``\\는 모든 인자와 콜러블 객체를 스택에서 팝하고, 해당 인자로 콜러블 객체를 호출한 다음, "
"콜러블 객체가 반환한 반환 값을 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1095
msgid ""
"Keyword arguments are packed in a tuple instead of a dictionary, *argc* "
"indicates the total number of arguments."
msgstr "키워드 인자는 딕셔너리 대신 튜플에 담기며, *argc*\\는 전체 인자 수를 나타냅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1102
#, fuzzy
msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before"
" the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"위치와 키워드 인자의 변수 집합으로 콜러블 객체를 호출합니다. *flags*\\의 최하위 비트가 설정되면, 스택의 맨 위에 추가 "
"키워드 인자가 포함된 매핑 객체가 포함됩니다. 그 아래에는 위치 인자와 호출할 콜러블 객체가 포함된 이터러블 객체가 있습니다. "
":opcode:`BUILD_MAP_UNPACK_WITH_CALL`\\과 "
":opcode:`BUILD_TUPLE_UNPACK_WITH_CALL`\\은 인자를 포함하는 여러 매핑 객체와 이터러블을 병합하는 데"
" 사용할 수 있습니다. 콜러블이 호출되기 전에, 매핑 객체와 이터러블 객체는 각각 \"언팩\" 되고 그 내용이 각각 키워드와 위치 "
"인자로 전달됩니다. ``CALL_FUNCTION_EX``\\는 모든 인자와 콜러블 객체를 스택에서 팝하고, 해당 인자로 콜러블 "
"객체를 호출한 다음, 콜러블 객체가 반환한 반환 값을 푸시합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1117
msgid ""
"Loads a method named ``co_names[namei]`` from the TOS object. TOS is "
"popped. This bytecode distinguishes two cases: if TOS has a method with "
"the correct name, the bytecode pushes the unbound method and TOS. TOS "
"will be used as the first argument (``self``) by :opcode:`CALL_METHOD` "
"when calling the unbound method. Otherwise, ``NULL`` and the object "
"return by the attribute lookup are pushed."
msgstr ""
"TOS 객체에서 ``co_names[namei]``\\라는 이름의 메서드를 로드합니다. TOS가 팝 됩니다. 이 바이트 코드는 두 "
"가지 경우를 구별합니다: TOS에 올바른 이름의 메서드가 있으면, 바이트 코드는 연결되지 않은 메서드와 TOS를 푸시합니다. "
"TOS는 연결되지 않은 메서드를 호출할 때 :opcode:`CALL_METHOD`\\에서 첫 번째 인자(``self``)로 "
"사용됩니다. 그렇지 않으면, ``NULL``\\과 어트리뷰트 조회에 의해 반환된 객체가 푸시 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1129
msgid ""
"Calls a method.  *argc* is the number of positional arguments. Keyword "
"arguments are not supported.  This opcode is designed to be used with "
":opcode:`LOAD_METHOD`.  Positional arguments are on top of the stack. "
"Below them, the two items described in :opcode:`LOAD_METHOD` are on the "
"stack (either ``self`` and an unbound method object or ``NULL`` and an "
"arbitrary callable). All of them are popped and the return value is "
"pushed."
msgstr ""
"메서드를 호출합니다. *argc*\\는 위치 인자의 수입니다. 키워드 인자는 지원되지 않습니다. 이 옵코드는 "
":opcode:`LOAD_METHOD`\\와 함께 사용하도록 설계되었습니다. 위치 인자는 스택 맨 위에 있습니다. 그 아래에, "
":opcode:`LOAD_METHOD`\\에 설명된 두 항목이 스택에 있습니다 (``self``\\와 연결되지 않은 메서드 객체 "
"또는 ``NULL``\\과 임의의 콜러블). 이것들이 모두 팝 되고 반환 값이 푸시 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1141
msgid ""
"Pushes a new function object on the stack.  From bottom to top, the "
"consumed stack must consist of values if the argument carries a specified"
" flag value"
msgstr "스택에 새 함수 객체를 푸시합니다. 바닥에서 맨 위로, 인자가 지정된 플래그 값을 전달하면 소비되는 스택은 값으로 구성되어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1144
msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr "``0x01`` 위치 전용과 위치-키워드 매개 변수를 위한 기본값의 위치 순서 튜플"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1146
msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr "``0x02`` 키워드 전용 매개 변수의 기본값 딕셔너리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1147
msgid "``0x04`` an annotation dictionary"
msgstr "``0x04`` 어노테이션 딕셔너리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1148
msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr "``0x08`` 자유 변수를 위한 셀을 포함하는 튜플, 클로저를 만듭니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1149
msgid "the code associated with the function (at TOS1)"
msgstr "함수와 연관된 코드 (TOS1에)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1150
msgid "the :term:`qualified name` of the function (at TOS)"
msgstr "함수의 :term:`정규화된 이름 <qualified name>` (TOS에)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1157
msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"``slice(TOS1, TOS)`` is pushed; if it is 3, ``slice(TOS2, TOS1, TOS)`` is"
" pushed. See the :func:`slice` built-in function for more information."
msgstr ""
"스택에 슬라이스 객체를 푸시합니다. *argc*\\는 2나 3이어야 합니다. 2이면, ``slice(TOS1, TOS)``\\가 "
"푸시 됩니다; 3이면, ``slice(TOS2, TOS1, TOS)``\\가 푸시 됩니다. 자세한 정보는 :func:`slice` "
"내장 함수를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1164
msgid ""
"Prefixes any opcode which has an argument too big to fit into the default"
" one byte. *ext* holds an additional byte which act as higher bits in the"
" argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"너무 커서 기본 1바이트에 맞지 않는 인자를 가진 옵코드에 접두어로 붙입니다. *ext*\\는 인자에서 더 높은 비트로 작동하는 "
"추가 바이트를 보유합니다. 각 옵코드마다, 최대 3개의 접두사 ``EXTENDED_ARG``\\가 허용되며, 2바이트에서 4바이트 "
"사이의 인자를 형성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1172
msgid ""
"Used for implementing formatted literal strings (f-strings).  Pops an "
"optional *fmt_spec* from the stack, then a required *value*. *flags* is "
"interpreted as follows:"
msgstr ""
"포맷 문자열 리터럴(f-문자열)을 구현하는 데 사용됩니다. 스택에서 선택적 *fmt_spec*\\을 팝 한 다음, 필수 "
"*value*\\를 팝 합니다. *flags*\\는 다음과 같이 해석됩니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1176
msgid "``(flags & 0x03) == 0x00``: *value* is formatted as-is."
msgstr "``(flags & 0x03) == 0x00``: *value*\\는 있는 그대로 포맷됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1177
msgid ""
"``(flags & 0x03) == 0x01``: call :func:`str` on *value* before formatting"
" it."
msgstr "``(flags & 0x03) == 0x01``: 포맷하기 전에 *value*\\에 대해 :func:`str`\\을 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1179
msgid ""
"``(flags & 0x03) == 0x02``: call :func:`repr` on *value* before "
"formatting it."
msgstr "``(flags & 0x03) == 0x02``: 포맷하기 전에 *value*\\에 대해 :func:`repr`\\을 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1181
msgid ""
"``(flags & 0x03) == 0x03``: call :func:`ascii` on *value* before "
"formatting it."
msgstr "``(flags & 0x03) == 0x03``: 포맷하기 전에 *value*\\에 대해 :func:`ascii`\\를 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1183
msgid ""
"``(flags & 0x04) == 0x04``: pop *fmt_spec* from the stack and use it, "
"else use an empty *fmt_spec*."
msgstr ""
"``(flags & 0x04) == 0x04``: 스택에서 *fmt_spec*\\을 팝 하고 그것을 사용합니다, 그렇지 않으면 빈 "
"*fmt_spec*\\을 사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1186
msgid ""
"Formatting is performed using :c:func:`PyObject_Format`.  The result is "
"pushed on the stack."
msgstr ":c:func:`PyObject_Format`\\을 사용하여 포맷이 수행됩니다. 결과는 스택에 푸시 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1194
msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes which don't use their argument and those that do (``< "
"HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"이것은 진짜 옵코드가 아닙니다. 인자를 사용하지 않는 옵코드와 사용하는 옵코드 사이의 구분 선을 식별합니다 (각각, ``< "
"HAVE_ARGUMENT``\\와 ``>= HAVE_ARGUMENT``)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1198
msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"이제 모든 명령어에는 인자가 있지만, ``< HAVE_ARGUMENT``\\인 옵코드는 이를 무시합니다. 이전에는, ``>= "
"HAVE_ARGUMENT``\\인 옵코드에만 인자가 있었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1206
msgid "Opcode collections"
msgstr "옵코드 모음"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1208
msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr "이 모음은 바이트 코드 명령어의 자동 검사를 위해 제공됩니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1213
msgid "Sequence of operation names, indexable using the bytecode."
msgstr "연산 이름의 시퀀스, 바이트 코드를 사용하여 인덱싱할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1218
msgid "Dictionary mapping operation names to bytecodes."
msgstr "연산 이름을 바이트 코드로 매핑하는 딕셔너리."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1223
msgid "Sequence of all compare operation names."
msgstr "모든 비교 연산 이름의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1228
msgid "Sequence of bytecodes that access a constant."
msgstr "상수에 액세스하는 바이트 코드의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1233
msgid ""
"Sequence of bytecodes that access a free variable (note that 'free' in "
"this context refers to names in the current scope that are referenced by "
"inner scopes or names in outer scopes that are referenced from this "
"scope.  It does *not* include references to global or builtin scopes)."
msgstr ""
"자유 변수에 액세스하는 바이트 코드의 시퀀스 (이 문맥에서 '자유'는 내부 스코프에서 참조되는 현재 스코프의 이름이나 이 스코프에서"
" 참조되는 외부 스코프의 이름을 나타냅니다. 전역이나 내장 스코프에 대한 참조는 포함하지 *않습니다*)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1241
msgid "Sequence of bytecodes that access an attribute by name."
msgstr "어트리뷰트를 이름으로 액세스하는 바이트 코드의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1246
msgid "Sequence of bytecodes that have a relative jump target."
msgstr "상대 점프 대상이 있는 바이트 코드의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1251
msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "절대 점프 대상이 있는 바이트 코드의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1256
msgid "Sequence of bytecodes that access a local variable."
msgstr "지역 변수에 액세스하는 바이트 코드의 시퀀스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/dis.rst:1261
msgid "Sequence of bytecodes of Boolean operations."
msgstr "불리언 연산의 바이트 코드의 시퀀스."

#~ msgid ""
#~ "Cleans up the value stack and the"
#~ " block stack.  If *preserve_tos* is "
#~ "not ``0`` TOS first is popped from"
#~ " the stack and pushed on the "
#~ "stack after performing other stack "
#~ "operations:"
#~ msgstr ""
#~ "값 스택과 블록 스택을 정리합니다. *preserve_tos*\\가"
#~ " ``0``\\이 아니면 TOS가 먼저 스택에서 팝 되고"
#~ " 다른 스택 연산을 수행한 후 스택으로 푸시 "
#~ "됩니다:"

#~ msgid ""
#~ "If TOS is ``NULL`` or an integer"
#~ " (pushed by :opcode:`BEGIN_FINALLY` or "
#~ ":opcode:`CALL_FINALLY`) it is popped from "
#~ "the stack."
#~ msgstr ""
#~ "TOS가 ``NULL``\\이거나 정수(:opcode:`BEGIN_FINALLY`\\나 "
#~ ":opcode:`CALL_FINALLY`\\로 푸시 된)이면 스택에서 팝 "
#~ "됩니다."

#~ msgid ""
#~ "If TOS is an exception type "
#~ "(pushed when an exception has been "
#~ "raised) 6 values are popped from "
#~ "the stack, the last three popped "
#~ "values are used to restore the "
#~ "exception state.  An exception handler "
#~ "block is removed from the block "
#~ "stack."
#~ msgstr ""
#~ "TOS가 예외 형(예외가 발생했을 때 푸시 된)이면 "
#~ "스택에서 6개의 값이 팝 됩니다, 마지막 3개의 팝"
#~ " 된 값이 예외 상태를 복원하는 데 사용됩니다. "
#~ "예외 처리기 블록이 블록 스택에서 제거됩니다."

#~ msgid ""
#~ "It is similar to :opcode:`END_FINALLY`, "
#~ "but doesn't change the bytecode counter"
#~ " nor raise an exception.  Used for"
#~ " implementing :keyword:`break`, :keyword:`continue` "
#~ "and :keyword:`return` in the "
#~ ":keyword:`finally` block."
#~ msgstr ""
#~ ":opcode:`END_FINALLY`\\와 비슷하지만, 바이트 코드 카운터를"
#~ " 변경하거나 예외를 발생시키지 않습니다. :keyword:`finally`"
#~ " 블록에 있는 :keyword:`break`, :keyword:`continue` "
#~ "및 :keyword:`return`\\을 구현하는 데 사용됩니다."

#~ msgid ""
#~ "Pushes ``NULL`` onto the stack for "
#~ "using it in :opcode:`END_FINALLY`, "
#~ ":opcode:`POP_FINALLY`, :opcode:`WITH_CLEANUP_START` and"
#~ " :opcode:`WITH_CLEANUP_FINISH`.  Starts the "
#~ ":keyword:`finally` block."
#~ msgstr ""
#~ ":opcode:`END_FINALLY`\\, :opcode:`POP_FINALLY`, "
#~ ":opcode:`WITH_CLEANUP_START` 및 "
#~ ":opcode:`WITH_CLEANUP_FINISH`\\에서 사용하기 위해 "
#~ "``NULL``\\을 스택으로 푸시합니다. :keyword:`finally` 블록을"
#~ " 시작합니다."

#~ msgid ""
#~ "Terminates a :keyword:`finally` clause.  The"
#~ " interpreter recalls whether the exception"
#~ " has to be re-raised or "
#~ "execution has to be continued depending"
#~ " on the value of TOS."
#~ msgstr ""
#~ ":keyword:`finally` 절을 종료합니다. 인터프리터는 TOS의 "
#~ "값에 따라 예외를 다시 발생시켜야 하는지 또는 "
#~ "실행을 계속해야 하는지 기억합니다."

#~ msgid ""
#~ "If TOS is ``NULL`` (pushed by "
#~ ":opcode:`BEGIN_FINALLY`) continue from the "
#~ "next instruction. TOS is popped."
#~ msgstr ""
#~ "TOS가 ``NULL``\\(:opcode:`BEGIN_FINALLY`\\에 의해 푸시 "
#~ "된)이면 다음 명령어부터 계속합니다. TOS가 팝 됩니다."

#~ msgid ""
#~ "If TOS is an integer (pushed by"
#~ " :opcode:`CALL_FINALLY`), sets the bytecode "
#~ "counter to TOS.  TOS is popped."
#~ msgstr ""
#~ "TOS가 정수(:opcode:`CALL_FINALLY`\\에 의해 푸시 된)이면,"
#~ " 바이트 코드 카운터를 TOS로 설정합니다. TOS가 팝"
#~ " 됩니다."

#~ msgid ""
#~ "If TOS is an exception type "
#~ "(pushed when an exception has been "
#~ "raised) 6 values are popped from "
#~ "the stack, the first three popped "
#~ "values are used to re-raise the"
#~ " exception and the last three popped"
#~ " values are used to restore the "
#~ "exception state.  An exception handler "
#~ "block is removed from the block "
#~ "stack."
#~ msgstr ""
#~ "TOS가 예외 형(예외가 발생했을 때 푸시 된)이면 "
#~ "스택에서 6개의 값이 팝 되고, 처음 3개의 팝"
#~ " 된 값이 예외를 다시 발생시키는 데 사용되고 "
#~ "마지막 3개의 팝 된 값이 예외 상태를 복원하는"
#~ " 데 사용됩니다. 예외 처리기 블록이 블록 스택에서"
#~ " 제거됩니다."

#~ msgid ""
#~ "Starts cleaning up the stack when "
#~ "a :keyword:`with` statement block exits."
#~ msgstr ":keyword:`with` 문 블록이 종료될 때 스택 정리를 시작합니다."

#~ msgid ""
#~ "At the top of the stack are "
#~ "either ``NULL`` (pushed by "
#~ ":opcode:`BEGIN_FINALLY`) or 6 values pushed"
#~ " if an exception has been raised "
#~ "in the with block.  Below is the"
#~ " context manager's :meth:`~object.__exit__` or"
#~ " :meth:`~object.__aexit__` bound method."
#~ msgstr ""
#~ "스택의 맨 위에는 ``NULL``\\(:opcode:`BEGIN_FINALLY`\\가 "
#~ "푸시한)이나 with 블록에서 예외가 발생했으면 6개의 값이"
#~ " 푸시 됩니다. 아래는 컨텍스트 관리자의 "
#~ ":meth:`~object.__exit__`\\나 :meth:`~object.__aexit__` 연결된"
#~ " 메서드입니다."

#~ msgid ""
#~ "If TOS is ``NULL``, calls ``SECOND(None,"
#~ " None, None)``, removes the function "
#~ "from the stack, leaving TOS, and "
#~ "pushes ``None`` to the stack.  Otherwise"
#~ " calls ``SEVENTH(TOP, SECOND, THIRD)``, "
#~ "shifts the bottom 3 values of the"
#~ " stack down, replaces the empty spot"
#~ " with ``NULL`` and pushes TOS.  "
#~ "Finally pushes the result of the "
#~ "call."
#~ msgstr ""
#~ "TOS가 ``NULL``\\이면, ``SECOND(None, None, "
#~ "None)``\\을 호출하고, 스택에서 함수를 제거하고, TOS를 "
#~ "남겨두고, ``None``\\을 스택으로 푸시합니다. 그렇지 않으면"
#~ " ``SEVENTH(TOP, SECOND, THIRD)``\\를 호출하고, "
#~ "스택의 맨 아래 3개 값을 아래로 시프트하고, 빈"
#~ " 지점을 ``NULL``\\로 바꾸고, TOS를 푸시합니다. "
#~ "마지막으로 호출 결과를 푸시합니다."

#~ msgid ""
#~ "Finishes cleaning up the stack when "
#~ "a :keyword:`with` statement block exits."
#~ msgstr ":keyword:`with` 문 블록이 종료될 때 스택 정리를 완료합니다."

#~ msgid ""
#~ "TOS is result of ``__exit__()`` or "
#~ "``__aexit__()`` function call pushed by "
#~ ":opcode:`WITH_CLEANUP_START`.  SECOND is ``None``"
#~ " or an exception type (pushed when"
#~ " an exception has been raised)."
#~ msgstr ""
#~ "TOS는 :opcode:`WITH_CLEANUP_START`\\에 의해 푸시 된"
#~ " ``__exit__()``\\나 ``__aexit__()`` 함수 호출의 "
#~ "결과입니다. SECOND는 ``None``\\이나 예외 형(예외가 발생할"
#~ " 때 푸시 된)입니다."

#~ msgid ""
#~ "Pops two values from the stack.  "
#~ "If SECOND is not None and TOS "
#~ "is true unwinds the EXCEPT_HANDLER block"
#~ " which was created when the exception"
#~ " was caught and pushes ``NULL`` to"
#~ " the stack."
#~ msgstr ""
#~ "스택에서 두 값을 팝 합니다. SECOND가 None이 "
#~ "아니고 TOS가 참이면 예외가 잡혔을 때 만들어진 "
#~ "EXCEPT_HANDLER 블록을 되감고 ``NULL``\\을 스택으로 "
#~ "푸시합니다."

#~ msgid ""
#~ "Pops *count* iterables from the stack,"
#~ " joins them in a single tuple, "
#~ "and pushes the result.  Implements "
#~ "iterable unpacking in tuple displays "
#~ "``(*x, *y, *z)``."
#~ msgstr ""
#~ "스택에서 *count* 이터러블을 팝하고, 단일 튜플로 "
#~ "연결하여, 결과를 푸시합니다. 튜플 디스플레이에서의 이터러블 "
#~ "언 패킹을 구현합니다 ``(*x, *y, *z)``."

#~ msgid ""
#~ "This is similar to "
#~ ":opcode:`BUILD_TUPLE_UNPACK`, but is used for"
#~ " ``f(*x, *y, *z)`` call syntax. The"
#~ " stack item at position ``count + "
#~ "1`` should be the corresponding callable"
#~ " ``f``."
#~ msgstr ""
#~ "이것은 :opcode:`BUILD_TUPLE_UNPACK`\\과 유사하지만, ``f(*x,"
#~ " *y, *z)`` 호출 문법에 사용됩니다. ``count "
#~ "+ 1`` 위치의 스택 항목은 해당 콜러블 "
#~ "``f``\\여야 합니다."

#~ msgid ""
#~ "This is similar to "
#~ ":opcode:`BUILD_TUPLE_UNPACK`, but pushes a "
#~ "list instead of tuple.  Implements "
#~ "iterable unpacking in list displays "
#~ "``[*x, *y, *z]``."
#~ msgstr ""
#~ "이것은 :opcode:`BUILD_TUPLE_UNPACK`\\과 비슷하지만, 튜플 "
#~ "대신 리스트를 푸시합니다. 리스트 디스플레이에서의 이터러블 언"
#~ " 패킹을 구현합니다 ``[*x, *y, *z]``."

#~ msgid ""
#~ "This is similar to "
#~ ":opcode:`BUILD_TUPLE_UNPACK`, but pushes a set"
#~ " instead of tuple.  Implements iterable "
#~ "unpacking in set displays ``{*x, *y, "
#~ "*z}``."
#~ msgstr ""
#~ "이것은 :opcode:`BUILD_TUPLE_UNPACK`\\과 비슷하지만, 튜플 "
#~ "대신 집합을 푸시합니다. 집합 디스플레이에서의 이터러블 언"
#~ " 패킹을 구현합니다 ``{*x, *y, *z}``."

#~ msgid ""
#~ "Pops *count* mappings from the stack,"
#~ " merges them into a single "
#~ "dictionary, and pushes the result.  "
#~ "Implements dictionary unpacking in dictionary"
#~ " displays ``{**x, **y, **z}``."
#~ msgstr ""
#~ "스택에서 *count* 매핑을 팝 하여, 단일 딕셔너리에"
#~ " 병합하고, 결과를 푸시합니다. 딕셔너리 디스플레이에서의 딕셔너리"
#~ " 언 패킹을 구현합니다 ``{**x, **y, **z}``."

#~ msgid ""
#~ "This is similar to :opcode:`BUILD_MAP_UNPACK`,"
#~ " but is used for ``f(**x, **y, "
#~ "**z)`` call syntax.  The stack item "
#~ "at position ``count + 2`` should "
#~ "be the corresponding callable ``f``."
#~ msgstr ""
#~ "이것은 :opcode:`BUILD_MAP_UNPACK`\\과 유사하지만, ``f(**x,"
#~ " **y, **z)`` 호출 문법에 사용됩니다. ``count"
#~ " + 2`` 위치의 스택 항목은 해당 콜러블 "
#~ "``f``\\여야 합니다."

#~ msgid ""
#~ "The position of the callable is "
#~ "determined by adding 2 to the "
#~ "opcode argument instead of encoding it"
#~ " in the second byte of the "
#~ "argument."
#~ msgstr "콜러블의 위치는 인자의 두 번째 바이트에 인코딩하는 대신 옵코드 인자에 2를 더해서 결정됩니다."

#~ msgid ""
#~ "Pushes the address of the next "
#~ "instruction onto the stack and "
#~ "increments bytecode counter by *delta*.  "
#~ "Used for calling the finally block "
#~ "as a \"subroutine\"."
#~ msgstr ""
#~ "다음 명령어의 주소를 스택으로 푸시하고 바이트 코드 "
#~ "카운터를 *delta*\\만큼 증가시킵니다. finally 블록을 "
#~ "\"서브 루틴\"으로 호출하는 데 사용됩니다."

