# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-08 03:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:2
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`itertools` --- 효율적인 루핑을 위한 이터레이터를 만드는 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:16
msgid ""
"This module implements a number of :term:`iterator` building blocks "
"inspired by constructs from APL, Haskell, and SML.  Each has been recast "
"in a form suitable for Python."
msgstr ""
"이 모듈은 APL, Haskell 및 SML의 구성물들에서 영감을 얻은 여러 :term:`이터레이터 <iterator>` 빌딩 "
"블록을 구현합니다. 각각을 파이썬에 적합한 형태로 개선했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:20
msgid ""
"The module standardizes a core set of fast, memory efficient tools that "
"are useful by themselves or in combination.  Together, they form an "
"\"iterator algebra\" making it possible to construct specialized tools "
"succinctly and efficiently in pure Python."
msgstr ""
"이 모듈은 자체적으로 혹은 조합하여 유용한 빠르고 메모리 효율적인 도구의 핵심 집합을 표준화합니다. 함께 모여, 순수 파이썬에서 "
"간결하고 효율적으로 특수화된 도구를 구성할 수 있도록 하는 \"이터레이터 대수(iterator algebra)\"를 형성합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:25
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which "
"produces a sequence ``f(0), f(1), ...``.  The same effect can be achieved"
" in Python by combining :func:`map` and :func:`count` to form ``map(f, "
"count())``."
msgstr ""
"예를 들어, SML은 테이블 화 도구를 제공합니다: 시퀀스 ``f(0), f(1), ...``\\를 생성하는 "
"``tabulate(f)``. :func:`map`\\과 :func:`count`\\를 결합하여 ``map(f, "
"count())``\\를 형성해서 파이썬에서도 같은 효과를 얻을 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:29
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(map(operator.mul, vector1, vector2))``."
msgstr ""
"이러한 도구와 그들의 내장 대응물들은 :mod:`operator` 모듈의 고속 함수와도 잘 작동합니다. 예를 들어, 곱셈 연산자는 "
"두 벡터에 걸쳐 map 되어 효율적인 내적(dot-product)을 형성할 수 있습니다: ``sum(map(operator.mul,"
" vector1, vector2))``."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:35
msgid "**Infinite iterators:**"
msgstr "**무한 이터레이터:**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:38
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:48
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:67
msgid "Iterator"
msgstr "이터레이터"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:38
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:48
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:67
msgid "Arguments"
msgstr "인자"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:38
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:48
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:67
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:76
msgid "Results"
msgstr "결과"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:38
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:48
msgid "Example"
msgstr "예"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:40
msgid ":func:`count`"
msgstr ":func:`count`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:40
msgid "start, [step]"
msgstr "start, [step]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:40
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:40
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:41
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:41
msgid "p"
msgstr "p"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:41
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:41
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:42
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:42
msgid "elem [,n]"
msgstr "elem [,n]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:42
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 끝없이 또는 최대 n 번"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:42
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:45
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**가장 짧은 입력 시퀀스에서 종료되는 이터레이터:**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:50
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:50
msgid "p [,func]"
msgstr "p [,func]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:50
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:50
msgid "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:51
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:61
msgid "p, q, ..."
msgstr "p, q, ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:51
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:52
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:51
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:52
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:52
msgid "iterable"
msgstr "iterable"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:52
msgid "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:53
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:53
msgid "data, selectors"
msgstr "data, selectors"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:53
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:53
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:54
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:54
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:55
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:59
msgid "pred, seq"
msgstr "pred, seq"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:54
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], pred가 실패할 때 시작"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:54
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:55
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:55
msgid "elements of seq where pred(elem) is false"
msgstr "pred(elem)이 거짓인 seq의 요소들"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:55
msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:56
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:56
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:56
msgid "sub-iterators grouped by value of key(v)"
msgstr "key(v)의 값으로 그룹화된 서브 이터레이터들"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "seq[start:stop:step]의 요소들"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:57
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:58
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:58
msgid "func, seq"
msgstr "func, seq"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:58
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:58
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:59
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:59
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], pred가 실패할 때까지"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:59
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:60
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:60
msgid "it, n"
msgstr "it, n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:60
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn 하나의 이터레이터를 n개의 이터레이터로 나눕니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:61
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:61
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:61
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:64
msgid "**Combinatoric iterators:**"
msgstr "**조합형 이터레이터:**"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:69
msgid ":func:`product`"
msgstr ":func:`product`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:69
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:69
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "데카르트 곱(cartesian product), 중첩된 for 루프와 동등합니다"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:70
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:70
msgid "p[, r]"
msgstr "p[, r]"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:70
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "r-길이 튜플들, 모든 가능한 순서, 반복되는 요소 없음"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:71
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:71
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:72
msgid "p, r"
msgstr "p, r"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:71
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "r-길이 튜플들, 정렬된 순서, 반복되는 요소 없음"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:72
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:72
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "r-길이 튜플들, 정렬된 순서, 반복되는 요소 있음"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:76
msgid "Examples"
msgstr "예"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:78
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:78
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:79
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:79
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:80
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:80
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:81
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:81
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:88
msgid "Itertool functions"
msgstr "이터레이터 도구 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:90
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""
"다음 모듈 함수는 모두 이터레이터를 생성하고 반환합니다. 일부는 길이가 무한한 스트림을 제공해서, 스트림을 자르는 함수나 루프로만 "
"액세스해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:96
msgid ""
"Make an iterator that returns accumulated sums, or accumulated results of"
" other binary functions (specified via the optional *func* argument)."
msgstr "누적 합계나 다른 이항 함수(선택적 *func* 인자를 통해 지정됩니다)의 누적 결과를 반환하는 이터레이터를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:100
msgid ""
"If *func* is supplied, it should be a function of two arguments. Elements"
" of the input *iterable* may be any type that can be accepted as "
"arguments to *func*. (For example, with the default operation of "
"addition, elements may be any addable type including "
":class:`~decimal.Decimal` or :class:`~fractions.Fraction`.)"
msgstr ""
"*func*\\가 제공되면, 두 인자를 취하는 함수여야 합니다. 입력 *iterable*\\의 요소는 *func*\\에 대한 인자로"
" 허용될 수 있는 모든 형일 수 있습니다. (예를 들어, 기본 더하기 연산에서 요소는 "
":class:`~decimal.Decimal`\\이나 :class:`~fractions.Fraction`\\을 포함하는 모든 더할 "
"수 있는 형일 수 있습니다.)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:107
msgid ""
"Usually, the number of elements output matches the input iterable. "
"However, if the keyword argument *initial* is provided, the accumulation "
"leads off with the *initial* value so that the output has one more "
"element than the input iterable."
msgstr ""
"일반적으로, 출력되는 요소 수는 입력 iterable과 일치합니다. 그러나, 키워드 인자 *initial*\\이 제공되면, 누적이 "
"*initial* 값으로 시작하여 출력에 입력 iterable보다 하나 많은 요소가 있게 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:112
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:210
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:259
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:495
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:577
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:630
msgid "Roughly equivalent to::"
msgstr "대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:131
msgid ""
"There are a number of uses for the *func* argument.  It can be set to "
":func:`min` for a running minimum, :func:`max` for a running maximum, or "
":func:`operator.mul` for a running product.  Amortization tables can be "
"built by accumulating interest and applying payments.  First-order "
"`recurrence relations "
"<https://en.wikipedia.org/wiki/Recurrence_relation>`_ can be modeled by "
"supplying the initial value in the iterable and using only the "
"accumulated total in *func* argument::"
msgstr ""
"*func* 인자는 여러 가지 용도가 있습니다. 누적 최솟값을 위해서는 :func:`min`, 누적 최댓값을 위해서는 "
":func:`max`, 누적 곱을 위해서는 :func:`operator.mul`\\로 설정할 수 있습니다. 할부 상환 표는 이자를 "
"누적하고 지불을 적용하여 만들 수 있습니다. 일차 `점화식 "
"<https://en.wikipedia.org/wiki/Recurrence_relation>`_\\은 iterable에 초깃값을 "
"제공하고 *func* 인자에서 누적 합계만 사용하여 모델링 할 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:161
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the"
" final accumulated value."
msgstr "최종 누적값만 반환하는 유사한 함수에 대해서는 :func:`functools.reduce`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:166
msgid "Added the optional *func* parameter."
msgstr "선택적 *func* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:169
msgid "Added the optional *initial* parameter."
msgstr "선택적 *initial* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:174
msgid ""
"Make an iterator that returns elements from the first iterable until it "
"is exhausted, then proceeds to the next iterable, until all of the "
"iterables are exhausted.  Used for treating consecutive sequences as a "
"single sequence. Roughly equivalent to::"
msgstr ""
"첫 번째 이터러블에서 소진될 때까지 요소를 반환한 다음 이터러블로 넘어가고, 이런 식으로 iterables의 모든 이터러블이 소진될"
" 때까지 진행하는 이터레이터를 만듭니다. 여러 시퀀스를 단일 시퀀스처럼 처리하는 데 사용됩니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:188
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a "
"single iterable argument that is evaluated lazily.  Roughly equivalent "
"to::"
msgstr ""
":func:`chain`\\의 대체 생성자. 게으르게 평가되는 단일 이터러블 인자에서 연쇄 입력을 가져옵니다. 대략 다음과 "
"동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:200
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "입력 *iterable*\\에서 요소의 길이 *r* 서브 시퀀스들을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:202
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:251
msgid ""
"The combination tuples are emitted in lexicographic ordering according to"
" the order of the input *iterable*. So, if the input *iterable* is "
"sorted, the combination tuples will be produced in sorted order."
msgstr ""
"조합(combination) 튜플은 입력 *iterable*\\의 순서에 따라 사전식 순서로 방출됩니다. 따라서, 입력 "
"*iterable*\\이 정렬되어있으면, 조합 튜플이 정렬된 순서로 생성됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:206
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  So if the input elements are unique, there will be no repeat "
"values in each combination."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 각 조합에 반복 값이 없습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:232
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence "
"of :func:`permutations` after filtering entries where the elements are "
"not in sorted order (according to their position in the input pool)::"
msgstr ""
":func:`combinations`\\의 코드는 요소가 정렬된 순서(입력 풀에서의 위치에 따라)가 아닌 항목을 걸러내어 만들어지는"
" :func:`permutations`\\의 서브 시퀀스로 표현될 수도 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:243
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n``"
" or zero when ``r > n``."
msgstr ""
"반환되는 항목 수는 ``0 <= r <= n``\\일 때는 ``n! / r! / (n-r)!`` 이고 ``r > n``\\일 때는 "
"0입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:248
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "입력 *iterable*\\에서 요소의 길이 *r* 서브 시퀀스들을 반환하는데, 개별 요소를 두 번 이상 반복할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:255
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  So if the input elements are unique, the generated combinations "
"will also be unique."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 생성된 조합도 고유합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:278
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed "
"as a subsequence of :func:`product` after filtering entries where the "
"elements are not in sorted order (according to their position in the "
"input pool)::"
msgstr ""
":func:`combinations_with_replacement`\\의 코드는 요소가 정렬된 순서(입력 풀에서의 위치에 따라)가 "
"아닌 항목을 걸러내어 만들어지는 :func:`product`\\의 서브 시퀀스로 표현될 수도 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:289
msgid "The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr "반환되는 항목 수는 ``n > 0``\\일 때 ``(n+r-1)! / r! / (n-1)!`` 입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:296
msgid ""
"Make an iterator that filters elements from *data* returning only those "
"that have a corresponding element in *selectors* that evaluates to "
"``True``. Stops when either the *data* or *selectors* iterables has been "
"exhausted. Roughly equivalent to::"
msgstr ""
"*data*\\에서 요소를 필터링하여 *selectors*\\에서 ``True``\\로 평가되는 해당 요소들만 반환하는 이터레이터를"
" 만듭니다. *data*\\나 *selectors* 이터러블이 모두 소진되면 중지합니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:310
msgid ""
"Make an iterator that returns evenly spaced values starting with number "
"*start*. Often used as an argument to :func:`map` to generate consecutive"
" data points. Also, used with :func:`zip` to add sequence numbers.  "
"Roughly equivalent to::"
msgstr ""
"숫자 *start*\\로 시작하여 균등 간격의 값을 반환하는 이터레이터를 만듭니다. 연속적인 데이터 포인트를 생성하기 위해 "
":func:`map`\\에 대한 인자로 종종 사용됩니다. 또한, 시퀀스 번호를 추가하기 위해 :func:`zip`\\과 함께 "
"사용됩니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:322
msgid ""
"When counting with floating point numbers, better accuracy can sometimes "
"be achieved by substituting multiplicative code such as: ``(start + step "
"* i for i in count())``."
msgstr ""
"부동 소수점 숫자로 count 할 때, ``(start + step * i for i in count())``\\와 같은 곱셈 "
"코드를 대체하여 때로 더 나은 정확도를 얻을 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:326
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "*step* 인자를 추가하고 정수가 아닌 인자를 허용했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:331
msgid ""
"Make an iterator returning elements from the iterable and saving a copy "
"of each. When the iterable is exhausted, return elements from the saved "
"copy.  Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"iterable에서 요소를 반환하고 각 사본을 저장하는 이터레이터를 만듭니다. iterable이 소진되면, 저장된 사본에서 요소를 "
"반환합니다. 무한히 반복합니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:345
msgid ""
"Note, this member of the toolkit may require significant auxiliary "
"storage (depending on the length of the iterable)."
msgstr "툴킷의 이 멤버에는 iterable의 길이에 따라 상당한 보조 기억 장치가 필요할 수 있음에 유의하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:351
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator"
" does not produce *any* output until the predicate first becomes false, "
"so it may have a lengthy start-up time.  Roughly equivalent to::"
msgstr ""
"술어(predicate)가 참인 한 iterable에서 요소를 걸러내는 이터레이터를 만듭니다; 그 후에는 모든 요소를 반환합니다. "
"술어(predicate)가 처음 거짓이 될 때까지 이터레이터는 *아무런* 출력도 생성하지 않아서 시작 소요 시간이 길어질 수 있음에"
" 유의하십시오. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:368
msgid ""
"Make an iterator that filters elements from iterable returning only those"
" for which the predicate is ``False``. If *predicate* is ``None``, return"
" the items that are false. Roughly equivalent to::"
msgstr ""
"iterable에서 요소를 걸러내어 술어(predicate)가 ``False``\\인 요소만 반환하는 이터레이터를 만듭니다. "
"*predicate*\\가 ``None``\\이면, 거짓인 항목을 반환합니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:383
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each "
"element.  If not specified or is ``None``, *key* defaults to an identity "
"function and returns the element unchanged.  Generally, the iterable "
"needs to already be sorted on the same key function."
msgstr ""
"*iterable*\\에서 연속적인 키와 그룹을 반환하는 이터레이터를 만듭니다. *key*\\는 각 요소의 키값을 계산하는 "
"함수입니다. 지정되지 않거나 ``None``\\이면, *key*\\의 기본값은 항등함수(identity function)이고 요소를"
" 변경하지 않고 반환합니다. 일반적으로, iterable은 같은 키 함수로 이미 정렬되어 있어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:389
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in "
"Unix.  It generates a break or new group every time the value of the key "
"function changes (which is why it is usually necessary to have sorted the"
" data using the same key function).  That behavior differs from SQL's "
"GROUP BY which aggregates common elements regardless of their input "
"order."
msgstr ""
":func:`groupby`\\의 작동은 유닉스의 ``uniq`` 필터와 유사합니다. 키 함수의 값이 변경될 때마다 "
"중단(break)이나 새 그룹을 생성합니다 (이것이 일반적으로 같은 키 함수를 사용하여 데이터를 정렬해야 하는 이유입니다). 이 "
"동작은 입력 순서와 관계없이 공통 요소를 집계하는 SQL의 GROUP BY와 다릅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:395
msgid ""
"The returned group is itself an iterator that shares the underlying "
"iterable with :func:`groupby`.  Because the source is shared, when the "
":func:`groupby` object is advanced, the previous group is no longer "
"visible.  So, if that data is needed later, it should be stored as a "
"list::"
msgstr ""
"반환되는 그룹 자체는 :func:`groupby`\\와 하부 이터러블(iterable)을 공유하는 이터레이터입니다. 소스가 "
"공유되므로, :func:`groupby` 객체가 진행하면, 이전 그룹은 이 더는 보이지 않게 됩니다. 따라서, 나중에 데이터가 "
"필요하면, 리스트로 저장해야 합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:407
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby`\\는 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:440
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until "
"start is reached. Afterward, elements are returned consecutively unless "
"*step* is set higher than one which results in items being skipped.  If "
"*stop* is ``None``, then iteration continues until the iterator is "
"exhausted, if at all; otherwise, it stops at the specified position.  "
"Unlike regular slicing, :func:`islice` does not support negative values "
"for *start*, *stop*, or *step*.  Can be used to extract related fields "
"from data where the internal structure has been flattened (for example, a"
" multi-line report may list a name field on every third line).  Roughly "
"equivalent to::"
msgstr ""
"iterable에서 선택된 요소를 반환하는 이터레이터를 만듭니다. *start*\\가 0이 아니면, iterable의 요소는 "
"start에 도달할 때까지 건너뜁니다. 그 후에는 *step*\\이 1보다 크게 설정(이때는 항목을 건너뛰게 됩니다)되지 않는 한 "
"요소가 연속적으로 반환됩니다. *stop*\\이 ``None``\\이면, 이터레이터가 완전히 소진될 때까지 이터레이션이 계속됩니다 "
"(소진한다면); 그렇지 않으면, 지정된 위치에서 멈춥니다. 일반 슬라이싱과 달리, :func:`islice`\\는 *start*, "
"*stop* 또는 *step*\\에 대해 음수 값을 지원하지 않습니다. 내부 구조가 평탄화된 데이터에서 관련 필드를 추출하는 데 "
"사용할 수 있습니다 (예를 들어, 여러 줄 보고서가 세 번째 줄마다 이름 필드를 나열할 수 있습니다). 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:475
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""
"*start*\\가 ``None``\\이면, 이터레이션은 0에서 시작합니다. *step*\\이 ``None``\\이면, step의 "
"기본값은 1입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:481
msgid "Return successive *r* length permutations of elements in the *iterable*."
msgstr "*iterable*\\에서 요소의 연속된 길이 *r* 순열을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:483
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length "
"of the *iterable* and all possible full-length permutations are "
"generated."
msgstr ""
"*r*\\이 지정되지 않았거나 ``None``\\이면, *r*\\의 기본값은 *iterable*\\의 길이이며 가능한 모든 최대 "
"길이 순열이 생성됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:487
msgid ""
"The permutation tuples are emitted in lexicographic ordering according to"
" the order of the input *iterable*. So, if the input *iterable* is "
"sorted, the combination tuples will be produced in sorted order."
msgstr ""
"순열(permutation) 튜플은 입력 *iterable*\\의 순서에 따라 사전식 순서로 방출됩니다. 따라서, 입력 "
"*iterable*\\이 정렬되어 있으면, 순열 튜플이 정렬된 순서로 생성됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:491
msgid ""
"Elements are treated as unique based on their position, not on their "
"value.  So if the input elements are unique, there will be no repeat "
"values in each permutation."
msgstr "요소는 값이 아니라 위치로 고유성을 다룹니다. 따라서 입력 요소가 고유하면, 각 순열에 반복 값이 없습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:522
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence "
"of :func:`product`, filtered to exclude entries with repeated elements "
"(those from the same position in the input pool)::"
msgstr ""
":func:`permutations`\\의 코드는 반복되는 요소(입력 풀에서 같은 위치에 있는 요소)가 있는 항목을 제외하도록 "
"걸러낸 :func:`product`\\의 서브 시퀀스로 표현될 수도 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:534
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr "반환되는 항목 수는 ``0 <= r <= n``\\일 때는 ``n! / (n-r)!`` 이고 ``r > n``\\일 때는 0입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:539
msgid "Cartesian product of input iterables."
msgstr "입력 이터러블들(iterables)의 데카르트 곱."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:541
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y "
"in B)``."
msgstr ""
"대략 제너레이터 표현식에서의 중첩된 for-루프와 동등합니다. 예를 들어, ``product(A, B)``\\는 ``((x,y) "
"for x in A for y in B)``\\와 같은 것을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:544
msgid ""
"The nested loops cycle like an odometer with the rightmost element "
"advancing on every iteration.  This pattern creates a lexicographic "
"ordering so that if the input's iterables are sorted, the product tuples "
"are emitted in sorted order."
msgstr ""
"중첩된 루프는 매 이터레이션마다 가장 오른쪽 요소가 진행되는 주행 거리계처럼 순환합니다. 이 패턴은 사전식 순서를 만들어서 입력의 "
"이터러블들이 정렬되어 있다면, 곱(product) 튜플이 정렬된 순서로 방출됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:549
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"이터러블의 자신과의 곱을 계산하려면, 선택적 *repeat* 키워드 인자를 사용하여 반복 횟수를 지정하십시오. 예를 들어, "
"``product(A, repeat=4)``\\는 ``product(A, A, A, A)``\\와 같은 것을 뜻합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:553
msgid ""
"This function is roughly equivalent to the following code, except that "
"the actual implementation does not build up intermediate results in "
"memory::"
msgstr "이 함수는 실제 구현이 메모리에 중간 결과를 쌓지 않는다는 점을 제외하고 다음 코드와 대략 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:566
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly,"
" it only useful with finite inputs."
msgstr ""
":func:`product`\\가 실행되기 전에, 입력 이터러블을 완전히 소비하여, 곱을 생성하기 위해 값의 풀(pool)을 "
"메모리에 유지합니다. 따라서, 유한 입력에만 유용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:572
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument "
"to :func:`map` for invariant parameters to the called function.  Also "
"used with :func:`zip` to create an invariant part of a tuple record."
msgstr ""
"*object*\\를 반복해서 반환하는 이터레이터를 만듭니다. *times* 인자가 지정되지 않으면 무기한 실행됩니다. 호출되는 "
"함수에 대한 불변 매개 변수를 위해 :func:`map`\\에 대한 인자로 사용됩니다. :func:`zip`\\과 함께 사용하여 "
"튜플 레코드의 불변 부분을 만들기도 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:588
msgid ""
"A common use for *repeat* is to supply a stream of constant values to "
"*map* or *zip*::"
msgstr "*repeat*\\의 일반적인 용도는 *map*\\이나 *zip*\\에 상숫값 스트림을 제공하는 것입니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:596
msgid ""
"Make an iterator that computes the function using arguments obtained from"
" the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been "
"\"pre-zipped\").  The difference between :func:`map` and :func:`starmap` "
"parallels the distinction between ``function(a,b)`` and ``function(*c)``."
" Roughly equivalent to::"
msgstr ""
"iterable에서 얻은 인자를 사용하여 함수를 계산하는 이터레이터를 만듭니다. 인자 매개 변수가 이미 단일 이터러블에 튜플로 "
"그룹화되어있을 때 (데이터가 \"미리 zip\" 되었을 때) :func:`map` 대신 사용됩니다. :func:`map`\\과 "
":func:`starmap`\\의 차이는 ``function(a,b)``\\와 ``function(*c)``\\의 차이와 "
"유사합니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:610
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr "술어(predicate)가 참인 한 iterable에서 요소를 반환하는 이터레이터를 만듭니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:624
msgid "Return *n* independent iterators from a single iterable."
msgstr "단일 iterable에서 *n* 개의 독립 이터레이터를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:626
msgid ""
"The following Python code helps explain what *tee* does (although the "
"actual implementation is more complex and uses only a single underlying "
":abbr:`FIFO (first-in, first-out)` queue)."
msgstr ""
"다음 파이썬 코드는 *tee*\\의 기능을 설명하는 데 도움이 됩니다 (하지만 실제 구현은 더 복잡하고 단일 하부 "
":abbr:`FIFO (선입 선출 - first-in, first-out)` 큐만 사용합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:647
msgid ""
"Once :func:`tee` has made a split, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without "
"the tee objects being informed."
msgstr ""
"일단 :func:`tee`\\가 분할되면, 원래 *iterable*\\을 다른 곳에서 사용해서는 안 됩니다; 그렇지 않으면, tee"
" 객체에 알리지 않고 *iterable*\\이 진행할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:651
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised"
" when using simultaneously iterators returned by the same :func:`tee` "
"call, even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` 이터레이터는 스레드 안전하지 않습니다. 원래 *iterable*\\이 스레드 안전해도, 같은 :func:`tee` "
"호출로 반환된 이터레이터를 동시에 사용하면 :exc:`RuntimeError`\\가 발생할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:655
msgid ""
"This itertool may require significant auxiliary storage (depending on how"
" much temporary data needs to be stored). In general, if one iterator "
"uses most or all of the data before another iterator starts, it is faster"
" to use :func:`list` instead of :func:`tee`."
msgstr ""
"이 이터레이터 도구에는 상당한 보조 기억 장치가 필요할 수 있습니다 (일시적으로 저장해야 하는 데이터양에 따라 다릅니다). "
"일반적으로, 다른 이터레이터가 시작하기 전에 하나의 이터레이터가 대부분이나 모든 데이터를 사용하면, :func:`tee` 대신 "
":func:`list`\\를 사용하는 것이 더 빠릅니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:663
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If "
"the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted."
"  Roughly equivalent to::"
msgstr ""
"iterables의 각각에서 요소를 집계하는 이터레이터를 만듭니다. 이터러블들의 길이가 고르지 않으면, 누락된 값이 "
"*fillvalue*\\로 채워집니다. 가장 긴 이터러블이 소진될 때까지 이터레이션이 계속됩니다. 대략 다음과 동등합니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:687
msgid ""
"If one of the iterables is potentially infinite, then the "
":func:`zip_longest` function should be wrapped with something that limits"
" the number of calls (for example :func:`islice` or :func:`takewhile`).  "
"If not specified, *fillvalue* defaults to ``None``."
msgstr ""
"이터러블 중 하나가 무한할 수 있으면, :func:`zip_longest` 함수는 호출 수를 제한하는 것으로 감싸야 합니다 (예를 "
"들어 :func:`islice`\\나 :func:`takewhile`). 지정하지 않으면, *fillvalue*\\의 기본값은 "
"``None``\\입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:696
msgid "Itertools Recipes"
msgstr "Itertools 조리법"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:698
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "이 섹션에서는 기존 itertools를 빌딩 블록으로 사용하여 확장 도구 집합을 만드는 방법을 보여줍니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:701
msgid ""
"Substantially all of these recipes and many, many others can be installed"
" from the `more-itertools project <https://pypi.org/project/more-"
"itertools/>`_ found on the Python Package Index::"
msgstr ""
"실질적으로 이 모든 조리법과 더 많은 조리법이 파이썬 패키지 색인(Python Package Index)에서 찾을 수 있는 "
"`more-itertools 프로젝트 <https://pypi.org/project/more-itertools/>`_\\로 설치할 "
"수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/itertools.rst:707
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements "
"one at a time rather than bringing the whole iterable into memory all at "
"once. Code volume is kept small by linking the tools together in a "
"functional style which helps eliminate temporary variables.  High speed "
"is retained by preferring \"vectorized\" building blocks over the use of "
"for-loops and :term:`generator`\\s which incur interpreter overhead."
msgstr ""
"확장 도구는 하부 도구 집합과 같은 고성능을 제공합니다. 전체 이터러블을 한 번에 메모리로 가져오지 않고 한 번에 하나씩 요소를 "
"처리하여 뛰어난 메모리 성능을 유지합니다. 도구를 함수형(functional) 스타일로 연결하여 임시 변수를 제거함으로써 코드 "
"크기를 작게 유지합니다. 인터프리터 오버헤드가 발생하는 for-루프와 :term:`제너레이터 <generator>`\\를 사용하는 "
"것보다 \"벡터화된\" 빌딩 블록을 선호하여 고속을 유지합니다."

